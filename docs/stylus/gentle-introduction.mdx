---
id: gentle-introduction
title: 'A gentle introduction to Stylus'
description: 'An educational introduction that provides a high-level understanding of Stylus, a new way to write EVM-compatible smart contracts using your favorite programming languages.'
author: amarrazza
sme: amarrazza
target_audience: 'Developers who want to build on Arbitrum using popular programming languages, like Rust'
sidebar_position: 1
displayed_sidebar: buildAppsSidebar
---

import ImageZoom from '@site/src/components/ImageZoom';

# A gentle introduction: Stylus

### In a nutshell:

- Stylus lets you write smart contracts in programming languages that compile to WASM, such as **Rust, C, C++, and many others**, allowing you to tap into their ecosystem of libraries and tools. Rich language and tooling support already exist for Rust. You can try the SDK and CLI with the [quickstart](/stylus/quickstart.mdx).
- Solidity contracts and Stylus contracts are **fully interoperable**. In Solidity, you can call a Rust program and vice versa, thanks to a second, coequal WASM virtual machine.
- Stylus contracts offer significantly **faster execution and lower gas fees** for memory and compute-intensive operations, thanks to the superior efficiency of <a data-quicklook-from="wasm">WASM</a> programs.

### What's Stylus?

Stylus is an upgrade to Arbitrum Nitro [(ArbOS 32)](/run-arbitrum-node/arbos-releases/arbos32.mdx), the tech stack powering Arbitrum One, Arbitrum Nova, and Arbitrum chains. This upgrade adds a second, coequal virtual machine to the EVM, where EVM contracts continue to behave exactly as they would in Ethereum. We call this paradigm **MultiVM** since **everything is entirely additive.**

<ImageZoom src="/img/stylus-multivm.jpg" alt="Stylus gives you MultiVM" className="img-600px" />

This second virtual machine executes WebAssembly (WASM) rather than EVM bytecode. WASM is a modern binary format popularized by its use in major web standards, browsers, and companies to speed up computation. WASM is built to be fast, portable, and human-readable. It has sandboxed execution environments for security and simplicity. Working with WASM is nothing new for Arbitrum chains. Ever since the [Nitro upgrade](https://medium.com/offchainlabs/arbitrum-nitro-one-small-step-for-l2-one-giant-leap-for-ethereum-bc9108047450), WASM has been a fundamental component of Arbitrum's fully functioning fraud proofs.

With a WASM VM, any programming language compilable to WASM is within Stylus's scope. While many popular programming languages can compile into WASM, some compilers are more suitable for smart contract development than others, like Rust, C, and C++. Other languages like Go, Sway, Move, and Cairo are also supported. Languages that include their own runtimes, like Python and Javascript, are more complex for Stylus to support, although not impossible. Compared to Solidity, WASM programs are much more efficient for memory-intensive applications. There are many reasons for this, including the decades of compiler development for Rust and C. WASM also has a faster runtime than the EVM, resulting in faster execution. Third-party contributions in the form of libraries for new and existing languages are welcomed!

### How Stylus works

Bringing a Stylus program to life involves four stages: **coding, activation, execution, and proving**. Here's what happens at each step.

#### Coding

You write your smart contract in any programming language that compiles to WASM. Right now, Rust has the richest support with an open-source SDK that makes smart contract development straightforward. C and C++ are also supported, so you can deploy existing contracts in those languages onchain with minimal modifications.

The [Stylus SDK for Rust](/stylus/reference/rust-sdk-guide.md) gives you the development framework and language features you'll need. It also provides access to all EVM-specific functionality that smart contract developers use.

#### Activation

Once you've written your contract, you compile it to WASM using the Stylus CLI (or another compiler like Clang for C/C++). Then you post the compiled WASM onchain.

Before your contract can be called, it goes through an activation process. During activation, the WASM gets compiled down to a node's native machine code (like ARM or x86). This step also applies safety checks, including gas metering, depth-checking, and memory charging, to ensure your program runs safely and can be fraud-proven.

One thing to know: Stylus measures computational costs using **ink** instead of gas. Ink works just like gas but is thousands of times smaller. Why? Because WASM executes so much faster than the EVM that a single EVM operation takes as long as thousands of WASM operations. Having a finer-grained unit makes pricing more precise.

:::note
Stylus contracts need to be reactivated once per year (365 days) or after any Stylus upgrade. You can do this using [`cargo-stylus`](/stylus/using-cli.mdx#cargo-stylus-commands-reference) or the [ArbWasm precompile](/build-decentralized-apps/precompiles/reference.mdx#arbwasm). If a contract isn't reactivated, it becomes uncallable.
:::

#### Execution

When your Stylus program runs, it executes in a fork of [Wasmer](https://wasmer.io/), a leading WebAssembly runtime optimized for blockchain use cases. Wasmer runs native code much faster than Geth executes EVM bytecode, which is where the gas savings come from.

The best part? EVM contracts keep working exactly as before. When a contract is called, the system checks whether it's an EVM contract or a WASM program and routes it to the right runtime. Solidity and WASM contracts can call each other freely, so you never have to worry about which language a contract was written in. Everything is interoperable.

#### Proving

Stylus builds on Nitro's fraud-proving technology. In normal operation, execution compiles to native code for speed. But if there's a dispute, the execution history compiles to WASM so validators can run interactive fraud proofs on Ethereum.

This is what makes Stylus possible: Nitro can already replay and verify disputes using WASM. Stylus extends this capability to verify not just execution history, but also the WASM programs you deploy. The result is a system where any program compiled to WASM can be deterministically fraud-proven. For more details, see the [Nitro architecture documentation](/how-arbitrum-works/01-inside-arbitrum-nitro.mdx).

### Use Cases

While many developers will be drawn to new use cases, rebuilding existing applications in Stylus will also open the door to innovation and optimization. dApps have never been faster, cheaper, or safer. Stylus can integrate easily into existing Solidity projects by calling a Stylus contract to optimize specific parts of your dApp or building the entire dApp with Stylus. It's impossible to list all of the use cases Stylus enables; think about the properties of all WASM-compatible languages! That said, here are some particularly exciting ideas:

- **Efficient Onchain Verification with ZK-Proofs**: Enable cost-effective onchain verification
  using zero-knowledge proving systems for privacy, interoperability, and more (see [case
  study](https://blog.arbitrum.io/renegade-stylus-case-study/)).
- **Advanced DeFi Instruments**: Power complex financial instruments and processes like custom
  pricing curves for AMMs, synthetic assets, options, and futures with onchain computation via
  extending current protocols (i.e., Uniswap V4 hooks) or building your own.
- **High-Performance Onchain Logic**: Support memory and compute-intensive applications like
  onchain games and generative art either by writing all of the application in Stylus or enhance
  performance of existing Solidity contracts by optimizing specific parts.
- **Endless Possibilities**: Enable innovative use cases such as generative art, compute-heavy
  AI models, onchain games, and projects utilizing advanced cryptography, unlocking the full potential
  of resource-intensive applications onchain.

### Getting Started

1. Utilize our [quickstart](/stylus/quickstart.mdx), [Rust SDK](/stylus/reference/overview.md), to help you start building.
2. Join our Stylus Developer [Telegram](https://t.me/arbitrum_stylus) group and [Arbitrum Discord](https://discord.gg/arbitrum) for support as well as the official Arbitrum ([@Arbitrum](https://twitter.com/arbitrum)) and Arbitrum Developers ([@ArbitrumDevs](https://twitter.com/ArbitrumDevs)) X accounts for announcements.
3. Check out the [Awesome Stylus](https://github.com/OffchainLabs/awesome-stylus) repository for various community contributed Stylus projects and tools. If you build something useful, we'd be happy to add it there.
4. Stay updated with the latest from the Stylus community through tutorials, builder interviews, technical deep dives, and more with the [Stylus Saturdays](https://stylus-saturdays.com/) newsletter.
