---
title: 'Differences between Arbitrum and Ethereum: Overview'
sidebar_position: 1
description: This concept page provides information about the differences between Arbitrum and Ethereum so developers can easily understand what to expect when deploying to Arbitrum
author: jose-franco
sme: jose-franco
target_audience: developers who want to build on Arbitrum
content_type: concept
displayed_sidebar: buildAppsSidebarFromGetStarted
---

Arbitrum's design is to be as compatible and consistent with Ethereum as possible, from its high-level RPCs to its low-level bytecode and everything in between. <a data-quicklook-from="dapp">Decentralized app (dApp)</a> developers with experience building on Ethereum will likely find that little to no new specific knowledge is required to build on Arbitrum.

This article outlines the key differences, benefits, and potential pitfalls that devs should be aware of when working with Arbitrum. This first page serves as an outline, with links to the relevant pages.

## Block numbers and time

Time in Arbitrum chains is tricky. The timing assumptions one is used to making about Ethereum blocks don't exactly carry over into the timing of Arbitrum blocks. See [Block numbers and time](/build-decentralized-apps/arbitrum-vs-ethereum/02-block-numbers-and-time.mdx) for details about how block numbers and time work in Arbitrum.

## RPC methods

Although the majority of RPC methods follow the same behavior as Ethereum, some methods may produce a different result or add additional information when used on an Arbitrum chain. You can find more information about these differences in [RPC methods](/build-decentralized-apps/arbitrum-vs-ethereum/03-rpc-methods.mdx).

## Solidity support

You can deploy Solidity contracts onto Arbitrum just like you do on Ethereum. There are only a few minor functional differences. For more information, refer to [Solidity support](/build-decentralized-apps/arbitrum-vs-ethereum/04-solidity-support.mdx).

## Fees

The fees for executing an Arbitrum transaction function similarly to gas fees on Ethereum. However, Arbitrum transactions must also pay a fee component to cover the cost of posting their calldata to the parent chain (for example, calldata on Arbitrum One, a child chain, is posted to Ethereum, a parent chain). Find more information about the two components of gas fees in [Gas and fees](/how-arbitrum-works/09-gas-fees.mdx) and parent chain pricing.

## Cross-chain messaging

Arbitrum chains support arbitrary message passing from a parent chain (e.g., Ethereum) to a child chain (e.g., Arbitrum One). These messages are commonly referred to as "parent chain to child chain messages." Developers using this functionality should familiarize themselves with how messaging works. For more information, refer to [Parent chain to child chain messaging](/how-arbitrum-works/10-l1-to-l2-messaging.mdx).

Similarly, Arbitrum chains can also send messages to the parent chainâ€”more information about this is available in [Child Chain to Parent Chain Messaging and the Outbox](/how-arbitrum-works/11-l2-to-l1-messaging.mdx).

## Precompiles

Besides supporting all precompiles available in Ethereum, Arbitrum provides child chain-specific precompiles with methods that smart contracts can call in the same way as Solidity functions. You can find a full reference to them on the [Precompiles](/build-decentralized-apps/precompiles/01-overview.mdx) page.

## NodeInterface

The Arbitrum Nitro software includes a special `NodeInterface` contract, available at address `0xc8`, that is only accessible via RPCs (deployed offchain, making it inaccessible to smart contracts). Find more information about this interface in [NodeInterface](build-decentralized-apps/nodeinterface/01-overview.mdx).
