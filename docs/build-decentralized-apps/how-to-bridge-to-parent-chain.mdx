---
title: How to bridge from child chain to parent chain
description: Learn how to programmatically withdraw ETH and send messages from an Arbitrum child chain to a parent chain
content_type: how-to
---

import ImageZoom from '@site/src/components/ImageZoom';

This guide explains how to programmatically send messages and withdraw assets from an Arbitrum child chain back to a parent chain (like Ethereum). For conceptual information about the messaging protocol, see [Child to parent chain messaging](/how-arbitrum-works/deep-dives/l2-to-l1-messaging.mdx).

## Prerequisites

- A child chain wallet with funds
- Access to parent chain infrastructure (for executing the final step)
- Awareness that child-to-parent messages require ~7 days to finalize

## Overview of the process

Child-to-parent chain messaging follows these steps:

1. **Send message on child chain**: Call `ArbSys.sendTxToL1` to initiate the message
2. **Wait for finalization**: The message enters a ~7 day challenge period
3. **Execute on parent chain**: After finalization, call `Outbox.executeTransaction` to complete the transfer

## Sending a message from child to parent chain

To send a message from the child chain to the parent chain, use the `ArbSys` precompile:

```solidity
ArbSys(100).sendTxToL1(destAddress, calldata);
```

The `ArbSys` precompile is located at address `0x0000000000000000000000000000000000000064`.

**Example**: Sending a simple message

```javascript
const arbSys = new ethers.Contract(
  '0x0000000000000000000000000000000000000064',
  arbSysABI,
  childChainSigner,
);

const tx = await arbSys.sendTxToL1(
  parentChainDestination,
  ethers.utils.toUtf8Bytes('Hello from L2!'),
);
const receipt = await tx.wait();
```

## Executing the message on the parent chain

After the ~7 day challenge period, you can execute the message on the parent chain.

### Step 1: Retrieve proof data

Use the `NodeInterface` contract to get the Merkle proof:

```javascript
const nodeInterface = new ethers.Contract(
  '0x00000000000000000000000000000000000000C8',
  nodeInterfaceABI,
  childChainProvider,
);

const proofData = await nodeInterface.constructOutboxProof(batchNumber, indexInBatch);
```

:::note

`NodeInterface` is a "virtual" contract accessible at `0x00000000000000000000000000000000000000C8`. It's not a true precompile but provides Arbitrum-specific data without requiring a custom RPC.

:::

### Step 2: Execute on the parent chain

Call `Outbox.executeTransaction` with the proof data:

```javascript
const outbox = new ethers.Contract(outboxAddress, outboxABI, parentChainSigner);

const tx = await outbox.executeTransaction(
  proofData.proof,
  proofData.path,
  proofData.l2Sender,
  proofData.l1Dest,
  proofData.l2Block,
  proofData.l1Block,
  proofData.timestamp,
  proofData.amount,
  proofData.calldataForL1,
);
await tx.wait();
```

## Withdrawing ETH

To withdraw ETH from the child chain, use the `ArbSys` precompile's `withdrawEth` method:

```solidity
ArbSys(100).withdrawEth{ value: amountToWithdraw }(destAddress)
```

### How ETH withdrawal works

1. **On the child chain**: The ETH balance is burned
2. **Challenge period**: Wait ~7 days for the assertion to finalize
3. **On the parent chain**: Execute via `Outbox.executeTransaction` to claim your ETH

`ArbSys.withdrawEth` is equivalent to calling `ArbSys.sendTxToL1` with empty calldata. Like any child-to-parent message, it requires executing on the parent chain after the dispute period.

### Example: Withdrawing ETH

```javascript
const arbSys = new ethers.Contract(
  '0x0000000000000000000000000000000000000064',
  arbSysABI,
  childChainSigner,
);

// Withdraw 0.1 ETH
const tx = await arbSys.withdrawEth(parentChainAddress, {
  value: ethers.utils.parseEther('0.1'),
});
const receipt = await tx.wait();

// After 7 days, execute on parent chain using the steps above
```

The withdrawal process:

<ImageZoom
  src="/img/apps-withdrawing-ether.svg"
  alt="Process funds follow during withdrawal operation"
  className="img-800px"
/>

## Withdrawing ERC-20 tokens

To withdraw ERC-20 tokens, use Arbitrum's canonical token bridge through the `L2GatewayRouter`:

### Step 1: Initiate withdrawal on child chain

```javascript
const l2GatewayRouter = new ethers.Contract(
  l2GatewayRouterAddress,
  gatewayRouterABI,
  childChainSigner,
);

// Approve the gateway to transfer your tokens
const token = new ethers.Contract(tokenAddress, erc20ABI, childChainSigner);
await token.approve(l2GatewayRouterAddress, amountToWithdraw);

// Initiate the withdrawal
const tx = await l2GatewayRouter.outboundTransfer(
  l1TokenAddress, // Parent chain token address
  parentChainDestination, // Where to send tokens on parent chain
  amountToWithdraw,
  '0x', // Extra data (usually empty)
);
await tx.wait();
```

### Step 2: Execute on parent chain

After the ~7 day challenge period:

1. The tokens are burned on the child chain
2. An encoded message to `L1ERC20Gateway.finalizeInboundTransfer` is created
3. Execute via `Outbox.executeTransaction` (similar to ETH withdrawal)
4. Your tokens are released from the parent chain gateway's escrow

The token withdrawal process:

<ImageZoom
  src="/img/apps-bridge_withdrawals.png"
  alt="Withdrawal process using the gateway"
  className="img-800px"
/>

## Using the Arbitrum SDK

The Arbitrum SDK simplifies child-to-parent messaging:

```javascript
import { L2ToL1MessageStatus, L2TransactionReceipt } from '@arbitrum/sdk';

// Get the L2 transaction receipt
const l2Receipt = await childChainProvider.getTransactionReceipt(l2TxHash);
const l2TxReceipt = new L2TransactionReceipt(l2Receipt);

// Get L2ToL1 messages from the transaction
const messages = await l2TxReceipt.getL2ToL1Messages(parentChainSigner);

// Wait for the message to be executable
const message = messages[0];
await message.waitUntilReadyToExecute(childChainProvider);

// Execute the message on the parent chain
const executeResult = await message.execute(childChainProvider);
await executeResult.wait();
```

## Message lifecycle

Child-to-parent messages go through these stages:

| Stage                                    | Description                                                                 |
| ---------------------------------------- | --------------------------------------------------------------------------- |
| Posted on child chain                    | The message is sent via `ArbSys.sendTxToL1`                                 |
| Waiting for finalization                 | The assertion containing the message is in the challenge period (~6.4 days) |
| Confirmed and executable on parent chain | The assertion is confirmed, and the message can be executed in the outbox   |

## Next steps

- For protocol-level details, see [Child to parent chain messaging](/how-arbitrum-works/deep-dives/l2-to-l1-messaging.mdx)
- For token bridging concepts, see [Token bridging overview](/how-arbitrum-works/token-bridging/overview.mdx)
- For the Arbitrum SDK documentation, see [SDK reference](/sdk)
