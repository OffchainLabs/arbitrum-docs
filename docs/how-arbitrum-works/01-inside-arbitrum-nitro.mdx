---
title: 'Inside Arbitrum Nitro'
description: "Follow a transaction's journey through the complete Arbitrum Nitro stack, from submission to finality."
author: pete-vielhaber
sme: mehdi salehi
user_story: "As a developer, I need to understand how transactions flow through Arbitrum's architecture and how the system ensures security and performance."
content_type: get-started
---

import ImageWithCaption from '@site/src/components/ImageCaptions/';

Imagine you're a developer sending a transaction to Arbitrum. What happens from the moment you submit it until it achieves finality? Let's trace this journey step by step, exploring how Arbitrum's architecture ensures your transaction is processed correctly, efficiently, and securely.

This article will take us through the complete Arbitrum Nitro stack—from the Sequencer that orders your transaction, through the State Transition Function that executes it, to the validation system that ensures its correctness. Along the way, we'll discover how Arbitrum achieves Ethereum-level security while offering 10 times lower fees and 100 times faster transactions.

## The Foundation: Arbitrum's core architecture overview

Before we begin our journey, let's understand the fundamental architecture that makes everything possible. Arbitrum operates on a simple but powerful principle: **deterministic state transitions**.

<ImageWithCaption
  caption="Original napkin sketch drawn by Arbitrum co-founder Ed Felten"
  src="/img/haw-eds-napkin-drawing.png"
/>

**The Core Components:**

1. **Inbox**: Where transactions enter the system
2. **State Transition Function (STF)**: Processes transactions deterministically
3. **Outputs**: Produces results and state updates

This deterministic model ensures that given the same inputs, all honest nodes will produce identical outputs. This property is crucial for Arbitrum's security model, as it enables fraud proofs and dispute resolution mechanisms that can verify execution correctness without re-running entire transactions.

## Nitro's four big ideas

Arbitrum Nitro's design is rooted in four fundamental innovations that enable its performance and security characteristics:

### 1. Sequencing, followed by deterministic execution

Nitro processes transactions with a two-phase strategy. First, transactions get organized into a single ordered sequence, and Nitro commits to that sequence. Then, the transactions are processed in that sequence by a deterministic State Transition Function (STF).

### 2. Geth at the core

Nitro supports Ethereum's data structures, formats, and virtual machine by compiling in the core code of the popular go-ethereum (Geth) Ethereum node software. Using Geth as a library ensures a very high degree of compatibility with Ethereum.

### 3. Separate execution from proving

Nitro compiles the same source twice: once to native code for execution in a Nitro node (optimized for speed), and again to WASM for use in proving (optimized for portability and security).

### 4. Optimistic rollup with interactive fraud proofs

Nitro settles transactions on the Layer 1 Ethereum chain using an Optimistic Rollup protocol, which includes the interactive fraud proofs pioneered by Arbitrum.

:::info Why do these matter

These four innovations collectively enable Arbitrum to achieve Ethereum-level security with substantially improved performance characteristics while maintaining complete compatibility with existing Ethereum applications.

:::

## Step 1: The journey begins: Submitting a transaction

Your transaction's journey starts when you submit it to Arbitrum. You have several routes available, each with different characteristics:

<ImageWithCaption caption="Transaction lifecycle" src="/img/haw-transaction-lifecycle.svg" />

### Route 1: Through the Sequencer

Most transactions take the standard path through the **Sequencer**—a specialized node responsible for ordering transactions and providing immediate confirmations. The Sequencer offers several methods to submit a transaction:

- **Public RPC**: For development and light usage
- **Third-party RPC**: For higher throughput and better performance
- **Direct Sequencer endpoint**: For the lowest possible latency
- **Self-hosted Arbitrum nodes**: For maximum control and privacy

### Route 2: Bypassing the Sequencer

To mitigate censorship, you can submit transactions directly to the **Delayed Inbox** contract on Ethereum. This method ensures your transaction will be processed even if the Sequencer refuses to handle it (censorship resistance).

**How It Works:**

- **Delayed Inbox Queue**: Messages submitted by non-Sequencer nodes go into the "delayed inbox" queue
- **Sequencer Release**: A well-behaved Sequencer typically releases delayed messages after about ten minutes
- **Force Inclusion**: If a message has been in the delayed inbox queue for longer than 24 hours, anyone can force it into the main inbox
- **Censorship Resistance**: This ensures the Sequencer can only delay messages but can't censor (refuse) them

**Trade-offs:**

- **Sequencer Path**: Finality is faster (immediate soft finality)
- **Delayed Inbox Path**: Finality is slower (roughly double the time) but provides censorship resistance

:::info Why does this matter

The Sequencer provides immediate "soft finality" by promising to include your transaction in a specific order. "Soft finality" enables fast user experience while maintaining the option for censorship-resistant submission when needed.

:::

## Step 2: Ordering and broadcasting: The Sequencer

Once your transaction reaches the Sequencer, it enters a sophisticated ordering and broadcasting system designed for both performance and security.

### Real-time transaction feed

The Sequencer immediately publishes your transaction through its **real-time feed**, providing instant visibility to all nodes in the network. This feed serves multiple critical functions:

- **Immediate Confirmation**: You receive instant feedback that your transaction has been accepted and ordered
- **State Synchronization**: All nodes stay synchronized with the latest transaction sequence
- **Soft Finality**: You can act on your transaction immediately, knowing the Sequencer has ordered it properly

### Batching and compression

The Sequencer doesn't process transactions individually. Instead, it collects multiple transactions into **batches** for efficient processing and lower costs:

**Batch Formation Criteria:**

- **Size Threshold**: The creation of batches occurs when enough accumulated transactions reach a predefined size limit
- **Time Constraints**: Batches are also created based on elapsed time to prevent undue delays

**Compression Process:**
The Sequencer uses the **Brotli compression algorithm** to minimize the data required to post to Ethereum:

- **Dynamic Compression Levels**: Compression level adjusts based on network backlog (0-11 scale)
- **Cost Optimization**: Higher compression reduces L1 posting costs but requires more computation
- **Adaptive Strategy**: System prioritizes speed over compression when the backlog is high

### Posting to Ethereum

Once batched and compressed, transaction data posts to Ethereum through the **Sequencer Inbox Contract**. The Sequencer uses two primary methods:

**1. Blob Transactions ([EIP-4844](https://eips.ethereum.org/EIPS/eip-4844))** (default)

- **Default Method**: When Ethereum supports [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)
- **Cost Efficient**: Blobs provide cheaper data inclusion than calldata
- **Scalable**: Enables handling of large transaction volumes

**2. Calldata Transactions**

- **Fallback Method**: When blob fees are high or [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) unavailable
- **Direct Inclusion**: Transaction data included directly in calldata
- **Compatibility**: Works with all Ethereum configurations

:::info Why does this matter

The batching and compression system enables Arbitrum to achieve 10-100x cost reduction compared to posting individual transactions to Ethereum. This dual posting strategy ensures optimal cost efficiency under varying network conditions.

:::

:::note Sequencer deep-dive

To learn more about the inner workings of the Sequencer and how it works in specific detail, refer to the [Sequencer deep-dive](/how-arbitrum-works/deep-dives/sequencer.mdx).

:::

## Step 3: Where execution happens: State Transition Function

Now that your transaction has been ordered and batched, execution occurs next. Execution happens in the **State Transition Function (STF)**—the heart of Arbitrum's execution engine.

### The Geth integration: Complete EVM compatibility

Arbitrum achieves full Ethereum compatibility through a sophisticated three-layer architecture:

<ImageWithCaption caption="Geth sandwich" src="/img/haw-geth-sandwich.svg" />

**Layer 1: Geth Core**

- The foundation consists of the core Geth components that handle EVM execution
- Ensures behavioral consistency with Ethereum
- Provides proven security through rigorously tested code

**Layer 2: ArbOS (Arbitrum Operating System)**

- Provides Layer 2-specific functionality, including cross-chain messaging
- Handles fee accounting and gas price management
- Manages deposits, withdrawals, and advanced features like Stylus

**Layer 3: Node Interface**

- Handles RPC connections and API requests
- Provides Ethereum-compatible node functionality for client applications

### How transactions are processed

When your transaction reaches the STF, it follows this execution path:

1. **Transaction Validation**: ArbOS validates your transaction format and checks sufficient funds
2. **Gas Charging**: The system calculates and adds the cost for both L2 execution and L1 data posting costs
3. **EVM Execution**: Geth processes your transaction according to standard EVM protocols
4. **State Updates**: ArbOS updates Layer 2-specific state and handles cross-chain operations
5. **Receipt Generation**: The system produces transaction receipts and logs

### Stylus integration: Beyond EVM

If your transaction interacts with a **Stylus contract** (WebAssembly (WASM)-based), the execution flow differs:

- **WASM Runtime**: ArbOS routes execution to the WASM runtime instead of the EVM
- **Host I/O Operations**: Stylus contracts use specialized host I/O calls for blockchain state access
- **Enhanced Performance**: Stylus contracts can execute 10-70x faster than EVM equivalents
- **Full Interoperability**: Stylus contracts can seamlessly call EVM contracts and vice versa

:::info Why does this matter

The Geth integration ensures that existing Ethereum applications work without modification, while ArbOS adds Layer 2 capabilities and Stylus enables high-performance alternatives for new applications.

:::

:::note State Transition Function deep-dive

To learn more about the inner workings of the STF and how it works in specific detail, refer to the [State Transition Function deep-dive](/how-arbitrum-works/deep-dives/stf-inputs.mdx).

:::

## Step 4: Finality

Your transaction now has two levels of finality, each serving different purposes in Arbitrum's security model.

### Soft finality: Immediate confirmation

The moment the Sequencer includes your transaction in its feed, you achieve **soft finality** (from [Step 1](#step-1-transaction-submission-the-journey-begins)):

- **Instant Feedback**: You receive immediate confirmation that your transaction is accepted
- **Sequencer Promise**: The Sequencer commits to including your transaction in a specific order
- **User Experience**: You can act on your transaction immediately without waiting

:::info Trust model

Soft finality relies on the Sequencer's honesty and availability. While this provides an excellent user experience, it's not cryptographically secured.

:::

### Hard finality: Cryptographic security

**Hard finality** is achieved when your transaction's batch is posted to **and** confirmed on Ethereum:

- **Ethereum Security**: Your transaction inherits Ethereum's consensus security
- **Data Availability**: All transaction data is publicly available on Ethereum
- **Irreversibility**: Once confirmed, your transaction is not reversible

:::info Timeline

Hard finality typically takes 10-20 minutes, depending on Ethereum block times and the frequency of batch posting.

::::

### The Security guarantee

This dual-finality model provides the best of both worlds:

- **Fast User Experience**: Soft finality enables immediate transaction confirmation
- **Cryptographic Security**: Hard finality provides Ethereum-level security guarantees
- **Censorship Resistance**: Alternative submission routes ensure your transaction can and will always be processed

:::info Why does this matter

You get immediate feedback for optimal user experience while maintaining the security guarantees that make Arbitrum suitable for high-value transactions.

:::

## Step 5: Ensuring correctness: Validation and dispute resolution

Now that your transaction has undergone execution, how does Arbitrum ensure it was processed correctly? We'll cover that in the next section.

### The BoLD Protocol: Permissionless validation

Arbitrum uses **BoLD (Bounded Liquidity Delay)**, a next-generation dispute protocol that enables **permissionless validation**. Unlike traditional optimistic rollups, BoLD allows anyone to participate in validation without permission while guaranteeing time-bounded dispute resolution.

BoLD implements a new dispute system that allows any single entity to defend Arbitrum against malicious parties—effectively enabling anyone to validate, propose, and defend Arbitrum's chain state without needing permission to do so.

This defense occurs through a challenge game where different parties asserting claims with supporting evidence eventually narrow down their disagreement to a single step of execution within a block, known as a one-step proof (OSP). Ethereum can then verify this OSP by itself and, as the neutral referee, declare a winner.

BoLD is quite complex—it is too extensive to cover here. If you would like to learn more about BoLD and the challenge protocol in-depth, refer to the BoLD: Gentle introduction and the BoLD: Economics of Disputes.

## Step 6: Bridging: Cross-chain communication

Your transaction might involve moving assets or data between Ethereum and Arbitrum. Let's explore how Arbitrum handles cross-chain communication.

### L1 to L2 Messaging: From Ethereum to Arbitrum

When you want to send assets or data from Ethereum to Arbitrum, you have several options:

**1. Native Token Bridging**

- **ETH Deposits**: Direct ETH deposits through the bridge contract
- **ERC-20 Bridging**: Token transfers using the canonical bridge
- **Custom Gas Tokens**: Support for chains using custom gas tokens

**2. Retryable Tickets**

- **Atomic Operations**: L1 transactions that trigger L2 execution
- **Guaranteed Execution**: If initial execution fails, tickets can be retried (retryables)
- **Gas Management**: Predictable costs with automatic retry mechanisms
- **Ticket Lifecycle**: Tickets remain valid for approximately one week, and anyone can redeem them

**3. Direct Messaging**

- **Signed Messages**: From EOAs with signature verification
- **Unsigned Messages**: From contracts with address aliasing for security

:::note L1-to-L2 messaging deep-dive

To learn more about the inner workings of the L1-to-L2 messaging and how it works in specific detail, refer to the [L1-to-L2 messaging deep-dive](/how-arbitrum-works/deep-dives/l1-to-l2-messaging.mdx).

:::

### L2 to L1 Messaging: From Arbitrum to Ethereum

Moving assets or data from Arbitrum back to Ethereum follows a different pattern:

**The Process:**

1. **Message Creation**: A contract or user sends a message from the child chain by calling: [`ArbSys.sendTxToL1()`](/for-devs/dev-tools-and-resources/partials/precompile-tables/_arbsys.mdx)
2. **Inclusion in Assertion**: A rollup assertion will include the message
3. **Challenge Period**: 6.4-day window for potential challenges
4. **Manual Execution**: After confirmation, anyone can execute the message on L1

**Key Characteristics:**

- **Manual Execution Required**: Ethereum doesn't support scheduled execution
- **Merkle Proofs**: Messages are proven using Merkle inclusion proofs
- **Unlimited Lifetime**: Messages persist until successfully executed

:::note L2-to-L1 messaging deep-dive

To learn more about the inner workings of the L2-to-L1 messaging and how it works in specific detail, refer to the [L2-to-L1 messaging deep-dive](/how-arbitrum-works/deep-dives/l2-to-l1-messaging.mdx).

:::

### The Canonical bridge architecture

Arbitrum's canonical bridge uses a sophisticated three-component system:

**1. Asset Contracts**: The actual token contracts on both chains
**2. Gateways**: Pairs of contracts that handle specific bridging logic
**3. Routers**: Contracts that route each asset to its appropriate gateway

**Security Model**: The bridge ensures that for every token locked on L1, an equivalent amount gets minted on L2, and vice versa. The seven-day challenge period provides security against invalid withdrawals.

:::info Why does this matter

Cross-chain communication enables seamless asset movement and data transfer between Ethereum and Arbitrum, providing an experience similar to a single unified system while maintaining the security of both chains.

:::

## Step 7: The economics of execution: Gas and fees

Throughout your transaction's journey, various fees are collected to cover the costs of processing and securing the network.

### The two-component fee model

Arbitrum uses a sophisticated two-component fee system:

**1. L2 Gas Fees**

- **EVM Execution**: Standard gas costs for computation and storage
- **Dynamic Pricing**: Uses [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)-style exponential pricing mechanism
- **Speed Limit**: 7,000,000 gas per second target on Arbitrum One
- **Backlog Management**: Gas price adjusts based on network congestion

**2. L1 Calldata Fees**

- **Data Posting Costs**: Covers the cost of posting transaction data to Ethereum
- **Compression Estimation**: Fees based on the transaction's contribution to the compressed batch
- **Dynamic Pricing**: Algorithm adjusts to align collected fees with actual posting costs
- **Sequencer Transactions Only**: Only applies to transactions submitted through the Sequencer

### Protecting infrastructure: The speed limit

Arbitrum implements a **gas speed limit** as a protective mechanism to prevent chain infrastructure from being overloaded:

- **Throughput Threshold**: Currently set to 7,000,000 gas per second on Arbitrum One and Nova
- **Dynamic Pricing**: When cumulative usage exceeds the speed limit, L2 base fees rise using an [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)-style algorithm
- **Infrastructure Protection**: Prevents validator nodes from experiencing loads that could cause downtime or chain halting
- **User Experience**: Ensures high-priority transactions can still be processed during congestion while deterring low-priority transactions

:::info Why does this matter?

The speed limit is fundamentally a protective mechanism. If the chain load exceeds what Nitro validator nodes can process, the chain risks halting due to downtime among validator nodes. Maintaining security and liveness occurs through parent chain contracts; the best user experience requires validators and the sequencer to remain online.

:::

### Fee calculation process

When your transaction is processed (from [Step 3](#step-3-where-execution-happens-state-transition-function)), the system:

1. **Calculates L2 Gas**: Standard EVM gas costs for your transaction
2. **Estimates L1 Impact**: Determines your transaction's contribution to batch size
3. **Applies Dynamic Pricing**: Uses current L1 and L2 price algorithms
4. **Collects Fees**: Charges you the total amount in ETH

:::info Why does this matter?

The dual-fee model ensures that both L2 execution costs and L1 data posting costs are properly covered. Simultaneously, the speed limit ensures security by allowing validators to keep up with the chain's progress.

:::

:::note Gas and fees deep-dive

To learn more about the inner workings of how gas and fees work in specific detail, refer to the [Gas and fees deep-dive](/how-arbitrum-works/deep-dives/gas-and-fees.mdx).

:::

## Step 8: Advanced features

Arbitrum features several advanced capabilities that extend its functionality beyond standard Layer 2 features.

### Stylus: WebAssembly smart contracts

**Stylus** enables smart contract development in multiple programming languages:

- **Performance**: 10-70x faster execution compared to EVM
- **Memory Efficiency**: 100-500x improvement in memory usage
- **Language Support**: Rust, C, C++, and other WASM-compatible languages
- **Full Interoperability**: Seamless calls between Stylus and EVM contracts

**Technical Implementation**: Stylus contracts execute in a coequal WASM virtual machine alongside the EVM, with specialized host I/O operations for blockchain state access.

For more in-depth information about Stylus, refer to the [Stylus Gentle Intro]().

### Timeboost: MEV-aware transaction ordering

**Timeboost** implements advanced transaction ordering policies:

- **MEV Capture**: Chain owners can capture a portion of available MEV
- **User Protection**: Maintains protection against front-running and sandwich attacks
- **Spam Reduction**: Reduces MEV-driven network congestion
- **Configurable Parameters**: Chain owners can customize ordering policies

For more information about Timeboost, refer to the [Timeboost Gentle introduction]().

### AnyTrust: Alternative Data Availability (DA)

**AnyTrust** provides a cost-optimized alternative to standard rollups by accepting a mild trust assumption about data availability:

**Architecture:**

- **Data Availability Committee (DAC)**: Uses a committee of N members to store transaction data
- **Trust Assumption**: Assumes at least 2-of-N committee members are honest
- **Data Availability Certificates (DACerts)**: Cryptographic proofs using BLS signatures
- **Fallback Mechanism**: Falls back to posting full data to L1 if committee is unavailable

**Technical Implementation:**

- **Keysets**: Specify BLS public keys of committee members and signature requirements
- **DACert Contents**: Hash of data block, expiration time, and proof of N-1 member signatures
- **Data Availability Servers (DAS)**: Committee members run servers with Sequencer API and public REST API
- **Storage Options**: Local files, Badger database, Amazon S3, or redundant multi-store configurations

**Sequencer-Committee Interaction:**

1. Sequencer sends a data batch with an expiration time to all committee members
2. Members store data and sign (hash, expiration) pairs using BLS keys
3. Sequencer aggregates signatures to create DACert
4. Sequencer posts DACert to L1 inbox contract
5. If insufficient signatures are collected, the Sequencer falls back to posting full data

**Use Cases**: Optimized for applications requiring very low costs and willing to accept mild trust assumptions, such as gaming or social applications. Arbitrum Nova utilizes AnyTrust to achieve lower fees compared to Arbitrum One.

For more in-depth information about AnyTrust, refer to the [AnyTrust protocol]().

## Additional deep dive resources

This journey has covered the high-level flow of transactions through Arbitrum. For detailed technical information about specific components not already mentioned, check out these additional deep-dives:

- **[Transaction Lifecycle](/how-arbitrum-works/deep-dives/transaction-lifecycle.mdx)**: Detailed transaction submission and processing
- **[Geth Integration](/how-arbitrum-works/deep-dives/geth.mdx)**: How Arbitrum modifies Geth for L2 execution
- **[ArbOS](/how-arbitrum-works/deep-dives/arbos.mdx)**: Layer 2 operating system and precompiles
- **[Assertions](/how-arbitrum-works/deep-dives/assertions.mdx)**: How assertions work in the rollup protocol
