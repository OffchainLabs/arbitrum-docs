---
title: 'Inside Arbitrum Nitro'
description: 'Learn the fundamentals of the Arbitrum Nitro stack.'
author: pete-vielhaber
sme: edfelten
user_story: As a current or prospective Arbitrum user, I need learn more about Nitros design.
content_type: get-started
---

import ImageWithCaption from '@site/src/components/ImageCaptions/';

This document provides a comprehensive explanation of Arbitrum Nitro's design and the rationale behind it. This document isn't API documentation, nor is it a guided tour of the code - look elsewhere for those. "Inside Arbitrum Nitro" is for individuals who want to gain a deeper understanding of Nitro's design.

The body of this document will describe Arbitrum Rollup, the primary use case of the Nitro technology, used on the Arbitrum One chain. There is a variant use case, called AnyTrust, deployed on the Arbitrum Nova chain. AnyTrust is a configuration that introduces mild trust assumptions and utilizes alternative data availability (Alt-DA), as discussed in a section at the end of this document.

## Why use Arbitrum? Why use Nitro?

Arbitrum is an L2 scaling solution for Ethereum, offering a unique combination of benefits:

- **Trustless security**: security rooted in Ethereum, with any one party able to ensure correct Layer 2 results
- **Compatibility with Ethereum**: able to run unmodified EVM contracts and unmodified Ethereum transactions
- **Scalability**: moving contracts' computation and storage off of the main Ethereum chain, allowing much higher throughput
- **Minimum cost**: designed and engineered to minimize the L1 gas footprint of the system, minimizing per-transaction cost

Some other Layer 2 systems offer some of these features, but to our knowledge, no other system provides the same combination of features at the same cost.

Nitro is a major upgrade to Arbitrum, improving over "classic" Arbitrum in several ways:

- **Advanced Calldata Compression**, which further drives down transaction costs on Arbitrum by reducing the amount of data posted to L1.
- **Separate Contexts for Common Execution and Fault Proving**, increasing the performance of L1 nodes, and thus offering lower fees.
- **Ethereum L1 Gas Compatibility**, bringing pricing and accounting for EVM operations perfectly in line with Ethereum.
- **Additional L1 Interoperability**, including tighter synchronization with L1 block numbers, and full support for all Ethereum L1 precompiles.
- **Safe retryables**, eliminating the failure mode where a retryable ticket fails to get created.
- **Geth Tracing**, for even broader debugging support.
- Any many, many more changes.

## The big picture

At the most basic level, an Arbitrum chain works like this:

<ImageWithCaption
  caption="Original napkin sketch drawn by Arbitrum co-founder Ed Felten"
  src="/img/haw-eds-napkin-drawing.png"
/>

People and contracts put messages into the inbox. The chain reads the messages one at a time and processes each one. This processing updates the state of the chain and produces some outputs.

If you want an Arbitrum chain to process a transaction for you, you need to put that transaction into the chain's inbox. Then, the chain will process your transaction, execute it, and produce some outputs: a transaction receipt and any withdrawals that your transaction initiated.

Execution is deterministic—which means that the contents of its inbox uniquely determine the chain's behavior. Because of this, the result of your transaction is knowable as soon as it gets placed in the inbox. Any Arbitrum node will be able to tell you the result. (And you can run an Arbitrum node yourself if you want.)

All of the technical details in this document connect to this diagram (shown above). To get from this diagram to a full description of Arbitrum, we'll need to answer questions like these:

- Who keeps track of the inbox, chain state, and outputs?
- How does Arbitrum make sure that the chain state and outputs are correct?
- How can Ethereum users and contracts interact with Arbitrum?
- How does Arbitrum support Ethereum-compatible contracts and transactions?
- How are `ETH` and tokens transferred into and out of Arbitrum chains, and how are they managed while on chain?
- How can I run my own Arbitrum node or validator?

## Nitro's design: The four big ideas

The essence of Nitro, and its key innovations, lie in four big ideas. We'll list them here with a summary of each, and then we'll unpack them in more detail in later sections.

- **Sequencing, Followed by Deterministic Execution**: Nitro processes transactions with a two-phase strategy. First, transactions get organized into a single ordered sequence, and Nitro commits to that sequence. Then, the transactions are processed in that sequence by a deterministic State Transition Function (STF).
- **Geth at the Core**: Nitro supports Ethereum's data structures, formats, and virtual machine by compiling in the core code of the popular go-ethereum (Geth) Ethereum node software. Using Geth as a library in this way ensures a very high degree of compatibility with Ethereum.
- **Separate Execution from Proving**: Nitro takes the same source and compiles it twice, once to native code for execution in a Nitro node, optimized for speed, and again to WASM for use in proving, optimized for portability and security.
- **Optimistic Rollup with Interactive Fraud Proofs**: Nitro settles transactions to the Layer 1 Ethereum chain using an optimistic rollup protocol, including the interactive fraud proofs pioneered by Arbitrum.

## Sequencing, followed by deterministic execution

This diagram illustrates the process of how transaction processing works in Nitro.

<ImageWithCaption caption="Transaction lifecycle" src="/img/haw-transaction-lifecycle.svg" />

Let's follow a user's transaction through this process.

First, the user creates a transaction, uses their wallet to sign it, and sends it to the Nitro chain's Sequencer. The Sequencer's job, as its name implies, is to take the arriving transactions, put them into an ordered sequence, and publish that sequence.

Once the transactions are sequenced, they go to the _State Transition Function (STF)_ for processing, one by one, in order. The STF takes as input the current state of the chain (account balances, contract code, and so on), along with the next transaction. It updates the state and sometimes emits a new Layer 2 block on the Nitro chain.

Because the protocol doesn't trust the Sequencer not to put garbage into its sequence, the STF will detect and discard any invalid (e.g., improperly formed) transactions in the sequence. A well-behaved Sequencer will filter out invalid transactions, so the STF never sees them—and this reduces cost and therefore keeps transaction fees low—but Nitro will still work correctly no matter what the Sequencer puts into its feed. (Transactions in the fees are signed by their senders, so the Sequencer can't create forged transactions.)

The state transition function is deterministic, meaning its behavior depends only on the current state and the contents of the next transaction, and nothing else. Because of this determinism, the result of a transaction `T` will depend only on the genesis state of the chain, the transactions before `T` in the sequence, and `T` itself.

Anyone who knows the transaction sequence can compute the STF independently, and all honest parties who do so are guaranteed to obtain identical results. Nitro nodes normally operate as follows: retrieve the transaction sequence and execute the State Transition Function locally. There is no requirement for a consensus mechanism.

:::info More information

For additional reading on STF inputs, see the [STF Inputs deep-dive](/how-arbitrum-works/deep-dives/stf-inputs.mdx).

:::

## How the Sequencer publishes the sequence

So how do nodes get the sequence? The Sequencer publishes it in two ways: a real-time feed and batches posted on L1 Ethereum.

The real-time feed is published by the Sequencer so that anyone who subscribes to the feed receives instant notifications of each transaction as it is sequenced. Nitro nodes can subscribe to the feed directly from the Sequencer, or through a relay that forwards the feed. The feed represents the Sequencer's promise to record transactions in a particular order. If the Sequencer is honest and doesn't experience prolonged downtime, the Sequencer will fulfill its promise. Anyone who trusts the Sequencer to keep its promises can rely on the feed to obtain instant information about the transaction sequence. They can then run the sequenced transactions through the STF to immediately learn the results of each transaction. This process is called "soft finality" for transactions; it's "soft" because it relies on the Sequencer keeping its promises.

The Sequencer also publishes its sequence on the L1 Ethereum chain. Periodically, every few minutes in production, the Sequencer concatenates the next group of transactions in the feed, compresses them for efficiency, and posts the result as calldata (blobs) on Ethereum. This process is the final and official record of the transaction sequence.

As soon as this Ethereum transaction achieves finality on the Ethereum blockchain, the Layer 2 Nitro transactions it records will also achieve finality. These transactions are final because their position in the sequence has finality, and the outcome of the transactions is deterministic and knowable to any party. This process is "hard finality."

The Sequencer compresses its batches using the Brotli algorithm at its highest compression setting.

:::info More information

To learn more about the Sequencer in depth, take a look at the [Sequencer Deep Dive](/how-arbitrum-works/deep-dives/sequencer.mdx)

:::

## Geth at the core

The second key design idea in Nitro is "Geth at the Core." Here, "Geth" refers to go-ethereum, the most common node software for Ethereum. As its name suggests, go-ethereum is written in the Go programming language, as is almost all of Nitro.

<ImageWithCaption caption="Geth sandwich" src="/img/haw-geth-sandwich.svg" />

You can think of the software that comprises a Nitro node as being organized into three primary layers (shown above):

- The base layer is the core of Geth - the parts of Geth that emulate the execution of EVM contracts and maintain the data structures that make up the Ethereum state. Nitro compiles in this code as a library, with a few minor modifications to add necessary hooks.
- The middle layer, which we call ArbOS, is custom software that provides additional functions associated with Layer 2 functionality, such as decomopressing the parsing the Sequencer's data batches, accounting for Layer 1 gas costs and collecting fees to reimburse for them, and supporting cross-chain bridge functionalities such as deposits of Ether and tokens from L1 and withdrawals of the same back to L1. We'll delve into the details of ArbOS below.
- The top layer consists of node software, mostly drawn from Geth. This layer handles connections, incoming RPC requests from clients, and provides the other top-level functionality required to operate an Ethereum-compatible blockchain node.

Because the top and bottom layers rely heavily on code from Geth, this structure has been dubbed a "Geth sandwich." Strictly speaking, Geth plays the role of the bread in the sandwich, and ArbOS is the filling, but this sandwich receives its name from the bread.

The State Transition Function consists of the bottom Geth layer and a portion of the middle ArbOS layer. In particular, the STF is a designated function in the source code, and implicitly includes all of the code called by that function. The STF takes as input the bytes of a transaction received in the inbox and has access to a modifiable copy of the Ethereum state tree. Executing the STF may modify the state, and it will ultimately emit the header of a new block (in Ethereum's block header format), which will be appended to the Nitro chain.

:::info More information

For a deep dive into the Geth, refer to the [Geth Deep Dive](/how-arbitrum-works/deep-dives/geth.mdx)

:::

## Separating execution from proving

One of the challenges in designing a practical rollup system is the tension between wanting the system to perform well in ordinary execution and being able to reliably prove the results of execution. Nitro resolves this tension by using the same source code for both execution and proving, but compiling it to different targets for the two cases.

The Go compiler compiles the Nitro node software for _execution_, producing native code for the target architecture, which, of course, differs for each node deployment. (The node software distribution is in source code form, and as a Docker image containing a compiled binary.)

Separately, for _proving_, the portion of the code that is the State Transition Function is compiled by the Go compiler to WebAssembly (WASM), a typed and portable machine code format. The WASM code then undergoes a simple transformation into a format we call WAVM, which is described in detail below. If there is a dispute about the correct result of computing the STF, achieving a resolution comes from referencing the WAVM code.

### WAVM

The WASM format has many features that make it a good vehicle for fraud proofs - it is portable, structured, well-specified, and has reasonably good tools and support - but it requires a few modifications to do the job completely. Nitro uses a slightly modified version of WASM, which we call WAVM. A simple transformation stage turns the WASM code produced by the Go compiler into WAVM code suitable for proving.

WAVM differs from WASM in three main ways. First, WAVM removes certain features of WASM that are not generated by the Go compiler; the transformation phase ensures that these features are not present.

Second, WAVM restricts a few features of WASM. For example, WAVM does not contain floating-point instructions, so the transformer replaces floating-point instructions with calls to the Berkeley SoftFloat library. (We use software floating-point to reduce the risk of floating-point incompatibilities between architectures. The core Nitro functions never use floating-point, but the Go runtime does use some floating-point operations.) WAVM does not contain nested control flow, so the transformer flattens control flow constructs by turning control flow instructions into jumps. Some WASM instructions take a variable amount of time to execute, which we avoid in WAVM by transforming them into constructs using fixed cost instructions. These transformations simplify proving.

Third, WAVM introduces a few additional opcodes to facilitate interaction with the blockchain environment. For example, new instructions enable the WAVM code to read and write the chain's global state, retrieve the next message from the chain's inbox, or signal a successful completion of executing the State Transition Function.

### `ReadPreImage` and the Hash Oracle Trick

The most interesting new instruction is `ReadPreImage` which takes as input a hash `H` and a offest `I`, and returns the word of data at offset `I` of the preimage of `H` (and the number of bytes written, which is zero if `I` is at or after the end of the preimage). Of course, it is not feasible in general to produce a preimage from an arbitrary hash. For safety, the `ReadPreImage` instructions are only usable in a context where the preimage is publicly known and the size of the preimage is known to be less than a fixed upper bound of approximately 110 kbytes.

(In this context, "publicly known" information is information that can be derived or recovered efficiently by any honest party, assuming that the full history of the L1 Ethereum chain is available. For convenience, providing a hash preimage by a third party, such as a public server, and the correctness of the supplied value is easily verified.)

As an example, maintaining the state of a Nitro chain mimics Ethereum's state tree format, which is a Merkle tree. Nodes of the tree are stored in a database, indexed by the Merkle hash of the node. In Nitro, the state tree is kept outside of the State Transition Function's storage, with the STF only knowing the root hash of the tree. Given the hash of a tree node, the STF can recover the tree node's contents by using `ReadPreImage`, relying on the fact that the full contents of the tree are publicly known and that nodes in the Ethereum state tree will always be smaller than the upper bound on preimage size. In this manner, the STF can arbitrarily read and write to the state tree, despite only storing its root hash.

The only other use of `ReadPreImage` is to fetch the contents of recent L2 block headers, given the header hash. This method is safe because the block headers are publicly known and have a bounded size.

The "Hash Oracle Trick" of storing the Merkle hash of a data structure and relying on protocol participants to store the full structure, thereby supporting fetch-by-hash of the contents, dates back to the original Arbitrum design.

## Optimistic Rollup

Arbitrum is an optimistic rollup. Let's unpack that term.

_Rollup_

Arbitrum is a rollup, which means that the inputs to the chain—the messages that go into the inbox—are all recorded on the Ethereum chain as calldata. Because of this, everyone has the information they need to determine the current correct state of the chain. They have the full history of the inbox, and the inbox history uniquely determines the results, allowing them to reconstruct the state of the chain based only on public information, if needed.

This posting of calldata enables anyone to be a full participant in the Arbitrum protocol, allowing them to run an Arbitrum node or participate as a validator. Nothing about the history or state of the chain is a secret.

_Optimistic_

Arbitrum is optimistic, which means that Arbitrum advances the state of its chain by allowing any party (a "validator") to post a rollup block on Layer 1 that the party claims is correct, and then giving everyone else the opportunity to challenge that claim. If the challenge period (roughly a week) passes and nobody has challenged the claimed rollup block, Arbitrum confirms the rollup block as correct. If someone challenges the claim during the challenge period, then Arbitrum uses an efficient dispute resolution protocol (detailed below) to identify which party is lying. The liar will forfeit a deposit, and the truth-teller will receive part of that deposit as a reward for their efforts (some of the deposit is burned, guaranteeing that the liar is punished even if collusion is involved.)

Because a party that tries to cheat will lose a deposit, attempts to cheat should be very rare. The normal case will be a single party posting a correct rollup block, with nobody challenging it.

### Resolving disputes using interactive fraud proofs

Among optimistic rollups, the most important design decision is how to resolve disputes. Suppose Alice claims that the chain will produce a particular result, and Bob disagrees. How will the protocol decide which version to accept?

There are basically two options: interactive proving or re-executing transactions. Arbitrum uses interactive proving, which we believe is more efficient and more flexible. Much of Arbitrum's design follows from this fact.

### Interactive proving

The idea of interactive proving is that Alice and Bob will engage in a back-and-forth protocol, mediated by an L1 contract, to resolve their dispute with minimal work required from any L1 contract.

Arbitrum's approach involves dissecting the dispute. If Alice's claim covers `N` steps of execution, she posts two claims of size `N/2`, which combine to yield her initial `N-step` claim. Then, Bob picks one of Alice's `N/2-step` claims to challenge. Now the size of the dispute has been halved. This process continues, cutting the dispute in half at each stage, until they are disagreeing about a single step of execution. Note that so far, the L1 referee hasn't had to think about execution "on the merits." It is only once the dispute narrows to a single step that the L1 mediator (referee) needs to resolve the dispute by looking at what the instruction does and whether Alice's claim about it is correct.

The key principle behind interactive proving is that if Alice and Bob are in a dispute, they should perform as much offchain work as possible to resolve it, rather than delegating that work to a Layer 1 (L1) contract.

### Re-executing transactions

The alternative to interactive proving would be to have a rollup block contain a claimed machine state hash after every individual transaction. In the event of a dispute, the L1 referee would emulate the execution of an entire transaction to determine whether the outcome matches Alice's claim.

### Why interactive proving is better

We strongly believe that interactive proving is the superior approach for the following reasons.

- **More efficient in the optimistic case**: Because interactive proving can resolve disputes that are larger than one transaction, it can allow a rollup block to contain only a single claim about the end state of the chain after all of the execution covered by the block. By contrast, re-execution requires posting a state claim for each transaction within the rollup block. With hundreds or thousands of transactions per rollup block, this represents a substantial difference in L1 footprint, which is the main component of the cost.
- **More efficient in the pessimistic case**: In the case of a dispute, interactive proving requires the L1 referee contract only to check that Alice and Bob's actions "have the right shape," for example, that Alice has divided her `N-step` claim into two claims half as large. (The referee doesn't need to evaluate the correctness of Alice's claims—Bob does that, offchain.) Only one instruction needs to be re-executed. By contrast, re-execution requires the L1 referee to emulate the execution of an entire transaction.
- **Higher per-transaction gas limit**: Interactive proving can escape from Ethereum's tight per-transaction gas limit. The gas limit isn't infinite, for obvious reasons, but it can be larger than on Ethereum. As far as Ethereum is concerned, the only downside of a gas-heavy Arbitrum transaction is that it may require an interactive fraud proof with slightly more steps (and only if the transaction is indeed fraudulent). By contrast, re-execution of the transaction (which is more expensive than executing it directly) is within a single Ethereum transaction.
- **More implementation flexibility**: Interactive proving allows more flexibility in implementation. All that is necessary is the ability to verify a one-step proof on Ethereum. By contrast, re-execution approaches have limitations based on the EVM.

### Interactive proving drives the design of Arbitrum

Much of Arbitrum's design is driven by the opportunities opened up by interactive proving. Suppose you're reading about a feature of Arbitrum and wondering why it exists. In that case, two good questions to ask are: "How does this support interactive proving?" and "How does this take advantage of interactive proving?" The answers to most "why questions" about Arbitrum relate to interactive proving.

## Arbitrum Rollup Protocol

Before diving into the rollup protocol, there are two things we need to cover.

First, _if you're an Arbitrum user or developer, you don't need to understand the rollup protocol_. You don't ever need to think about it, unless you want to. Your relationship with it can be like a train passenger's relationship with the train's engine: you know it exists, you rely on it to keep working. Still, you don't spend your time monitoring it or studying its inner workings.

You're welcome to study, observe, and even participate in the rollup protocol, but it's not required, and most people won't. So if you're a typical train passenger who wants to read or talk to your neighbor, you can skip right to the [next section](#validators) of this document. If not, read on!

The second thing to understand about the rollup protocol is that _the protocol doesn't decide the results of transactions, it only confirms the results_. The results are uniquely determined by the sequence of messages in the chain's inbox. So once your transaction message is in the chain's inbox, its result is knowable - and Arbitrum nodes will report that your transaction is complete. The role of the rollup protocol is to confirm transaction results that, from the perspective of Arbitrum users, have already occurred. (This is why Arbitrum users can effectively ignore the rollup protocol.)

You might wonder why we need the rollup protocol. If everyone already knows the results of transactions, why bother confirming them? The rollup protocol exists for two reasons. First, somebody might lie about a result, and we need a definitive, trustless way to tell who is lying. Second, Ethereum doesn't know the results. The primary purpose of a Layer 2 scaling system is to process transactions without requiring Ethereum to handle all the work. Indeed, Arbitrum can execute transactions at a speed that Ethereum cannot match, while monitoring every transaction on Arbitrum. However, once a result is confirmed, Ethereum is aware of it and can rely on it, enabling operations on Ethereum, such as processing withdrawals of funds from Nitro back to L1.

With those preliminaries behind us, let's jump into the details of the rollup protocol.

Some parties that participate in the protocol are _validators_. Some validators will choose to be bonders; they will place an `ETH` deposit, which they can recover if they're not cheating. In the common case, the expectation is that only one validator will be bonded, since as long as it's bonded on the current outcome, and there are no conflicting claims, there's no need for other parties to bond/take any action. The protocol allows for these roles to be permissionless in principle; currently on Arbitrum One, validators/bonders are allowlisted (see "State of Progressive Decentralization"). "Watchtower validators," who monitor the chain but don't take any onchain actions, can be run permissionlessly (see "validators" below).

The key security property of the rollup protocol is that any one honest validator can ensure the correct execution of the chain is confirmed. This security means that execution of an Arbitrum chain is as trustless as Ethereum. You, and you alone (or someone you hire), can ensure that your transactions are processed correctly. And that is true no matter how many malicious people are trying to stop you.

## The Rollup Chain

The rollup protocol tracks a chain of rollup blocks, which we'll refer to as "assertions" for clarity. They're not the same as Layer 1 Ethereum blocks, and also not the same as Layer 2 Nitro blocks. You can think of assertions as forming a separate chain, which the Arbitrum rollup protocol manages and oversees.

Validators can propose assertions. New assertions will be _unresolved_ at first. Eventually, every assertion will be _resolved_, either by being _confirmed_ or _rejected_. The confirmed assertions make up the confirmed history of the chain.

Each assertion contains:

- the assertion number
- the predecessor assertion number: assertion number of the last assertion before this one that is (claimed to be) correct
- the number of L2 blocks that have been created in the chain's history
- the number of inbox messages that have been consumed in the chain's history
- a hash of the outputs produced over the chain's history

Except for the assertion number, the contents of the assertion consist solely of claims made by the assertion's proposer. Arbitrum doesn't initially know whether any of these fields are correct. If all of these fields are correct, the protocol should eventually confirm the assertion. If one or more of these fields are incorrect, the protocol should eventually reject the assertion.

An assertion implicitly claims that its predecessor assertion is correct. This claim implies, transitively, that an assertion implicitly claims the correctness of a complete history of the chain: a sequence of ancestor assertions that reaches back to the birth of the chain.

An assertion also implicitly claims that its older siblings (older assertions with the same predecessor, if any) are incorrect. If two assertions are siblings, and the older sibling is correct, then the younger sibling is considered incorrect, even if everything else in the younger sibling is true.

The assertion is assigned a deadline, which says how long other validators have to respond to it. If you're a validator, and you agree that an assertion is correct, you don't need to do anything. If you disagree with an assertion, you can post another assertion with a different result, and you'll probably end up in a challenge against the first assertion's bonder. (More on [challenges](#challenges) below.)

In the normal case, the rollup chain will look like this:

<ImageWithCaption caption="Normal Rollup chain" src="/img/haw-normal-rollup-chain.svg" />

On the left, representing an earlier part of the chain's history, we have confirmed assertions. These have been fully accepted and recorded by the Layer 1 contracts that manage the chain. The newest of the confirmed assertions, assertion 94, is referred to as the "latest confirmed assertion." On the right, we see a set of newer proposed assertions. The protocol can't yet confirm or reject them, because their deadlines have not yet expired. The oldest assertion whose fate remains to be determined, assertion 95, is referred to as the "first unresolved assertion."

Notice that a proposed assertion can build on an earlier proposed assertion. This "building" allows validators to continue proposing assertions without needing to wait for the protocol to confirm the previous one. Normally, all of the proposed assertions will be valid, so they will all eventually be accepted.

Here's another example of what the chain state might look like if several validators are being malicious. It's a contrived example, designed to illustrate various cases that can arise in the protocol, all condensed into a single scenario.

<ImageWithCaption caption="Malicious Rollup chain" src="/img/haw-malicious-rollup-chain.svg" />

A lot is going on here, so let's unpack it.

- Assertion 100 has been confirmed
- Assertion 101 claimed to be a correct successor to assertion 100, but 101 was rejected (hence the X drawn in it)
- Assertion 102 was eventually confirmed as the correct successor to 100
- Assertion 103 received confirmation and is now the latest confirmed assertion
- Assertion 104 is the proposed successor to assertion 103, and 105 is the proposed successor to 104. 104 was rejected as incorrect, and as a consequence, 105 was rejected because its predecessor was rejected
- Assertion 106 is unresolved. It claims to be a correct successor to assertion 103, but the protocol hasn't yet decided whether to confirm or reject it. It is the first unresolved assertion
- Assertions 107 and 108 claim to chain from 106. They are also unresolved. If 106 rejects, 107 and 108 will automatically reject too
- Assertion 109 disagrees with assertion 106, because they both claim the same predecessor. Eventually, 109 or 106 will be rejected, but the protocol hasn't yet resolved them.
- Assertion 110 claims to follow 109. It is unresolved. If 109 is rejected, 110 will also be rejected automatically.
- Assertion 111 claims to follow 104. 111 will be rejected because its predecessor has already been denied. However, it hasn't been rejected yet, because the protocol resolves assertions in assertion number order. Therefore, the protocol must resolve assertions 106 through 110 in order before it can resolve assertion 111. After 110 has resolved, 111 can be rejected immediately.

Again, this is very unlikely in practice. In this diagram, at least four parties must have bonded on wrong assertions, and when the dust settles, at least four parties will have lost their bonds. The protocol handles these cases correctly, of course, but they're rare corner cases. This diagram aims to illustrate the variety of situations that are possible in principle and how the protocol would address them.

### Bonding

At any given time, some validators will be bonders, and some will not. Bonders deposit funds that are held by the Arbitrum Layer 1 contracts, and if the bonder loses a challenge, the contract will confiscate the funds. Nitro chains accept bonds in `ETH`.

A single bond can cover a chain of assertions. Every bonder places a bond on the latest confirmed assertion, and if you bond on an assertion, you can also bond on one successor of that assertion. You might bond to a sequence of assertions that represent a single, coherent claim about the correct history of the chain. A single bond suffices to commit you to that sequence of assertions.

To create a new assertion, you must be a bonder, and you must already have a bond on the predecessor of the new assertion you're creating. The bond requirement for assertion creation ensures that anyone who makes a new assertion has something to lose if that assertion becomes rejected.

The protocol tracks the current required bond amount. Normally, this will equal the base bond amount, which is a parameter of the Nitro chain. But if the chain has been slow to make progress lately, the required bond will increase, as described in more detail below.

The rules for bonding are as follows:

- If you have no active bond, you can bond on the latest confirmed assertion. When doing this, you deposit the current minimum bond amount.
- If you have a bond on an assertion, you can also add your bond to any one successor of that assertion. (The protocol tracks the assertion number that you have a bond with, and lets you add your bond to any successor of that assertion, updating your maximum to that successor.) This new assertion doesn't require you to place a new bond.
  - A special case of adding your bond to a successor assertion is when you create a new assertion as a successor to an assertion for which you already have a bond.
- If you're bonded only on the latest confirmed assertion (and possibly earlier assertions), you or anyone else can ask to have your bond refunded. Your bonded funds will be returned to you, and you will no longer be a bonded individual.
- If you lose a challenge, your bond is removed from all assertions, and you forfeit your bonded funds.

Notice that once you have a bond on an assertion, there is no way to unbond. You are committed to that assertion. Eventually, one of two things will happen: that assertion will be confirmed, or you will lose your bond. The only way to get your bond back is to wait until all of the assertions to which you have a bond are confirmed.

#### Setting the current minimum bond amount

One detail we deferred earlier is determining the current minimum bond amount. Typically, this is just equal to the base bond amount, which is a parameter of the Nitro chain. However, if the chain has been slow to make progress in confirming assertions, the bond requirement will escalate temporarily. Specifically, the base bond amount is multiplied by a factor that is exponential in the time since the deadline of the first unresolved assertion passed. This bond amount ensures that if malicious parties place false bonds to try to delay progress (despite losing those bonds), the bond requirement increases. Consequently, the cost of such a delay attack increases exponentially. As assertion resolution starts advancing again, the bond requirement will decrease.

### Rules for Confirming or Rejecting assertions

The rules for resolving assertions are fairly simple.
The first unresolved assertion can be confirmed if:

- the assertion's predecessor is the latest confirmed assertion, and
- the assertion's deadline has passed, and
- there is at least one bonder, and
- all bonders are bonded on the assertion

The first unresolved assertion will be rejected if:

- The assertion's predecessor has been rejected, or
- All the following are true:
  - The assertion's deadline has passed, and
  - There is at least one bonder, and
  - No bonder is bonded on the assertion

A consequence of these rules is that once the first unresolved assertion's deadline has passed (and assuming there is at least one bonder bonded on something other than the latest confirmed assertion), the only way the assertion can be unresolvable is if at least one bonder is bonded on it and at least one bonder is bonded on a different assertion with the same predecessor. If this happens, the two bonders disagree about which assertion is correct. It's time for a challenge, to resolve the disagreement.

### Challenges

Suppose the rollup chain looks like this:

<ImageWithCaption caption="Rollup challenges" src="/img/haw-rollup-challenges.svg" />

Assertions 93 and 95 are siblings (they both have 92 as a predecessor). Alice has a bond on 93, and Bob has a bond on 95.

At this point, we know that Alice and Bob disagree about the correctness of assertion 93, with Alice committed to 93 being correct and Bob committed to 93 being incorrect. (Bob has a bond on 95, and 95 implicitly claims that 92 is the last correct assertion before it, which implies that 93 must be incorrect.)

Whenever two bonders have bonds on sibling assertions, and neither of those bonders is already in a challenge, anyone can start a challenge between the two. The rollup protocol will record the challenge and referee it, eventually declaring a winner and confiscating the loser's bond. The loser will also no longer be bound to their assertion.

The challenge is a game in which Alice and Bob alternate moves, with an Ethereum contract as the referee. Alice, the defender, moves first.

The game will operate in two phases: dissection, followed by a one-step proof. Dissection will narrow down the size of the dispute until it is a dispute about just one instruction of execution. Then the one-step proof will determine who is right about that one instruction.

We'll describe the dissection part of the protocol twice. First, we'll give a simplified version that is easier to understand but less efficient. We will then explain how the real version differs from the simplified one.

:::info More information

For further reading on Assertions and how to create them, refer to the [Assertion Deep-dive](/how-arbitrum-works/deep-dives/assertions.mdx).

:::

### Dissection Protocol: Simplified Version

Alice is defending the claim that starting with the state in the predecessor assertion, the state of the Virtual Machine can advance to the state specified in assertion A. Essentially she is claiming that the Virtual Machine can execute `N` instructions, and that that execution will consume `M` inbox messages and transform the hash of outputs from `H` to `H`.

Alice's first move requires her to dissect her claims about intermediate states between the beginning (0 instructions executed) and the end (`N` instructions executed). Therefore, we require Alice to divide her claim in half and post the state at the halfway point, after executing `N/2` instructions.

Now Alice has effectively bisected her `N-step` assertion into two (`N/2`)-step assertions. Bob has to point to one of those two half-size assertions and claim it is wrong.

At this point, we're effectively back in the original situation: Alice having asserted that Bob disagrees with. But we have cut the size of the assertion in half, from `N` to `N/2`. We can apply the same method again, with Alice bisecting and Bob choosing one of the halves, to reduce the size to `N/4`. And we can continue bisecting, so that after a logarithmic number of rounds, Alice and Bob will be disagreeing about a single step of execution. That's where the dissection phase of the protocol ends, and Alice must provide a one-step proof, which the EthBridge will verify.

### Why Dissection Correctly Identifies a Cheater

Before discussing the complexities of the real challenge protocol, let's pause to understand why the simplified version of the protocol is correct. Here, correctness means two things: (1) if Alice's initial claim is correct, Alice can always win the challenge, and (2) if Alice's initial claim is incorrect, Bob can always win the challenge.

To prove (1), observe that if Alice's initial claim is correct, she can offer a truthful midpoint claim, and both of the implied half-size claims will be correct. So whichever half Bob objects to, Alice will again be in the position of defending an accurate claim. At each stage of the protocol, Alice will be defending a correct claim. At the end, Alice will have a correct one-step claim to prove so that that claim will be provable and Alice can win the challenge.

To prove (2), observe that if Alice's initial claim is incorrect, this can only be because her claimed endpoint after `N` steps is incorrect, then when Alice offers her midpoint state claim, that midpoint claim is either correct or incorrect. If it's incorrect, then Bob can challenge Alice's first-half claim, which will be incorrect. If Alice's midpoint state claim is correct, then her second-half claim must be incorrect so that Bob can challenge that. So whatever Alice does, Bob will be able to challenge an incorrect half-size claim. At each stage of the protocol, Bob can identify an incorrect claim to challenge. Ultimately, Alice will have an incorrect one-step claim to prove, which she will be unable to do, allowing Bob to win the challenge.

(If you're a stickler for mathematical precision, it should be clear how these arguments can be turned into proofs by induction on `N`.)

### The Real Dissection Protocol

The real dissection protocol is conceptually similar to the simplified one described above, but with several modifications that enhance efficiency or address necessary corner cases. Here is a list of the differences.

- **Dissection over L2 blocks, then over instructions**: Alice's assertion is over an assertion, which asserts the results of creating some number of Layer 2 Nitro blocks. Dissection first occurs over these Layer 2 blocks, to narrow the dispute down to a dispute about a single Layer 2 Nitro block. At this point, the dispute shifts to a dispute about a single execution of the State Transition Function, or in other words, about the execution of a sequence of WAVM instructions. The protocol then executes the recursive dissection sub-protocol again, this time over WAVM instructions, to narrow the dispute to a single instruction. The dispute concludes with a one-step proof of a single instruction (or a party failing to act and losing by timeout).
- **K-way dissection**: Rather than dividing a claim into two segments of size `N/2`, we divide it into `K` segments of size `N/K`. This division requires posting `K-1` intermediate claims at points evenly spaced through the claimed execution, which reduces the number of rounds by a factor of log(`K`)/log(`2`).
- **Answer a dissection with a dissection**: Rather than having each round of the protocol require two moves, where Alice dissects and Bob chooses a segment to challenge, we instead require Bob, in challenging a segment, to post his own claimed endpoint state for that segment. Alice will then respond by identifying a subsegment, posting an alternative endpoint for that segment, and dissecting it. This segmentation reduces the number of moves in the game by an additional factor of 2, because the size is cut by a factor of `K` for every move, rather than for every two moves.
- **Deal With The Empty-Inbox Case**: The real AVM can't always execute `N` units of gas without getting stuck. The machine might halt, or it might have to wait because its inbox is exhausted, so it cannot proceed until more messages arrive. So Bob must be allowed to respond to Alice's claim of `N` units of execution by claiming that `N` steps are not possible. The real protocol thus allows any response (except the initial claim) to claim a special end state, which means that the specified amount of execution is not possible under the current conditions.
- **Time Limits**: Each player has a time allowance. The total time a player uses for all of their moves must be less than the time allowance, or they lose the game. Consider the time allowance to be approximately one week.

These changes don't affect the basic correctness of the challenge protocol. They do, however, improve its efficiency and enable it to handle all the cases that can arise in practice.

### Efficiency

The challenge protocol design is to resolve disputes with a minimal amount of work required by the protocol (via its Layer 1 Ethereum contracts) in its role as referee. When it is Alice's turn, the protocol only needs to keep track of the time Alice uses and ensure that her move includes `K-1` intermediate points as required. The protocol doesn't need to pay attention to whether those claims are correct in any way; it only needs to know whether Alice's move "has the right shape."

The only point where the protocol needs to evaluate a move "on the merits" is at the one-step proof, where it must examine Alice's proof to determine whether it establishes that the virtual machine transitions from the before state to the claimed after state after one step of computation.

## Validators

Some Arbitrum nodes will choose to act as _validators_, meaning they monitor the progress of the rollup protocol and participate in it to advance the state of the chain securely.

Not all nodes will choose to do this. Because the rollup protocol doesn't dictate what the chain will do but merely confirms the correct behavior, determined by the inbox messages, a node can ignore the rollup protocol and compute the correct behavior itself. For more on what such nodes might do, see the Full Nodes section.

Offchain Labs provides open source validator software, including a pre-built Docker image.

Every validator can choose which strategy to employ, but we expect validators to follow three common strategies:

- The _active validator_ strategy tries to advance the state of the chain by proposing new assertions. An active validator is always bonded, because creating an assertion requires being bonded. A chain only needs one honest active validator; any more is an inefficient use of resources. For the Arbitrum One chain, Offchain Labs runs an active validator.
- The _defensive validator_ strategy watches the rollup protocol operate. If only correct assertions get proposed, this strategy doesn't bond. However, if an incorrect assertion is proposed, this strategy intervenes by posting a correct assertion or bonding to a correct assertion that another party has already posted. This strategy avoids bonding when things are going well, but if someone is dishonest, it bonds to defend the correct outcome.
- The _watchtower validator_ strategy never bonds. It simply monitors the rollup protocol and, if an incorrect assertion is proposed, it raises the alarm (by whatever means it chooses) so that others can intervene. This strategy assumes that other parties who are willing to bond will be willing to intervene to take some of the dishonest proposer's bond, and that that can happen before the dishonest assertion's deadline expires. (In practice, this will allow several days for a response.)

Under normal conditions, validators using the defensive and watchtower strategies won't do anything except observe. A malicious actor considering whether to cheat won't be able to determine how many defensive and watchtower validators are operating incognito. Some defensive validators may announce themselves, but others won't, so a would-be attacker will always have to worry that defenders are waiting to emerge.

The underlying protocol supports permissionless validation, meaning that anyone can participate. Currently, on Arbitrum One, validators that require a bond (i.e., active and defensive validators) are allowlisted; see the State of Progressive Decentralization.

Who will be validators? Anyone can do it, but most people will choose not to. In practice, we expect people to validate a chain for several reasons.

- Validators could be paid for their work by the party that created the chain or someone else. A chain is configurable, allowing a portion of the funds from user transaction fees to be paid directly to validators.
- Parties that have significant assets bonded on a chain, such as dApp developers, exchanges, power-users, and liquidity providers, may choose to validate to protect their investment.
- Anyone who chooses to validate can do so. Some users will probably choose to validate to protect their interests or just to be good citizens. But ordinary users don't need to validate, and we expect that the vast majority of users won't.

## ArbOS

<!-- contains edited content from ArbOS merged into Ed's original work -->

ArbOS is a trusted "system glue" component that acts as the hypervisor, facilitating the State Transition Function (execution environment) on the child chain. ArbOS provides functions necessary for a Layer 2 system, including cross-chain communication, resource accounting, Layer 2-related fee economics, and chain management.

### Why ArbOS?

In Arbitrum, much of the work that would otherwise have to be done expensively at Layer 1 is instead done by ArbOS, trustlessly performing these functions at the speed and low cost of Layer 2.

Supporting these functions in Layer 2 trusted software, rather than building them into the L1-enforced rules of the architecture as Ethereum does, offers significant advantages in cost because these operations can benefit from the lower cost of computation and storage at Layer 2, instead of having to manage those resources as part of a Layer 1 contract. Having a trusted operating system at Layer 2 also offers significant advantages in flexibility, as Layer 2 code is easier to evolve or customize for a particular chain than a Layer 1-enforced architecture would be.

<!-- Below is content from ArbOS merged into Ed's original paper -->

ArbOS also provides child chain-specific precompiles with methods that smart contracts can call the same way they can Solidity functions. Visit the [precompiles conceptual page](/build-decentralized-apps/precompiles/01-overview.mdx) for more information about how these work and the [precompiles reference page](/build-decentralized-apps/precompiles/02-reference.mdx) for a full reference of the precompiles available in Arbitrum chains.

## Full Nodes

As the name suggests, full nodes in Arbitrum play the same role as full nodes in Ethereum: they maintain the state of the chain and provide an API that others can use to interact with the chain.

Arbitrum full nodes normally "live at Layer 2," which means that they don't worry about the rollup protocol but treat their Arbitrum chain as a mechanism that feeds inbox messages to the State Transition Function to evolve the Layer 2 chain and produce outputs.

## The Sequencer

The Sequencer is a specially designated full node, which has limited power to control the ordering of transactions. This ordering allows the Sequencer to guarantee the results of user transactions immediately, without requiring any wait for events on Ethereum. So, there's no need to wait five minutes or so for block confirmations - and no need to wait even 15 seconds for Ethereum to make a block.

Clients interact with the Sequencer in the same way they would with any full node, for example, by providing their wallet software with a network URL that happens to point to the Sequencer.

Currently, on the Arbitrum One and Arbitrum Nova chains, the Sequencer is run by Offchain Labs.

### Instant confirmation

Without a Sequencer, a node can predict the results of a client transaction. However, it cannot determine the order of transactions in the inbox, as it lacks control over how these transactions are arranged compared to those submitted by other nodes.

The Sequencer does have control over ordering, allowing it to assign its clients' transactions a position in the inbox queue, thereby ensuring that it can determine the results of client transactions immediately. The Sequencer's power to reorder has limits (see below for details), but it does have more power than anyone else to influence transaction ordering.

### Inboxes, fast and slow

When we add a Sequencer, the operation of the inbox changes.

- Only the Sequencer can put new messages directly into the inbox. The Sequencer tags the messages it is submitting with an Ethereum block number and timestamp. (ArbOS ensures that these are non-decreasing, adjusting them upward if necessary to avoid decreases.)
- Anyone else can submit a message, but messages submitted by non-Sequencer nodes will go into the "delayed inbox" queue (managed by an L1 Ethereum contract).
  - Messages in the delayed inbox queue will wait there until the Sequencer chooses to "release" them into the main inbox, where they will be added to the end of the inbox. A well-behaved Sequencer will typically release delayed messages after about ten minutes, for reasons explained below.
  - Alternatively, if a message has been in the delayed inbox queue for longer than a maximum delay interval (currently 24 hours on Arbitrum One), then anyone can force it to be promoted to the main inbox. (This ensures that the Sequencer can only delay messages but can't censor them.)

### If the Sequencer is well-behaved

A well-behaved Sequencer will accept transactions from all requesters and treat them fairly, providing each one with a promised transaction result as quickly as possible.

It will also minimize the delay it imposes on non-Sequencer transactions by promptly releasing delayed messages, consistent to provide strong guarantees of transaction results. Specifically, if the Sequencer believes that 40 confirmation blocks are required to achieve confidence in finality on Ethereum, then it will release delayed messages after 40 blocks. This belief is enough to ensure that the Sequencer knows exactly which transactions will precede its current transaction, because those preceding transactions have finality. There is no need for a benign Sequencer to delay non-Sequencer messages more than that, so it won't.

However, this belief does mean that transactions that go through the delayed inbox will take longer to get finality. Their time to finality will double (roughly), because they will have to wait one finality period for promotion, then another finality period for the Ethereum transaction that promoted them to achieve finality.

This delay is the tradeoff of having a Sequencer: if your message uses the Sequencer, finality is `C` blocks faster; but if your message doesn't use the Sequencer, finality is `C` blocks slower. This balance is usually a good tradeoff, as most transactions will utilize the Sequencer, and because the practical difference between instant and 10-minute finality is greater than the difference between 10-minute and 20-minute finality.

A Sequencer is generally a win if the Sequencer is well-behaved.

### If the Sequencer is malicious

A malicious Sequencer, on the other hand, could cause some pain. If it refuses to handle your transactions, you must go through the delayed inbox, which has a longer delay. A malicious Sequencer has the power to front-run everyone's transactions so that it could profit greatly at users' expense.

On Arbitrum One, Offchain Labs currently operates a well-behaved Sequencer - we promise! This Sequencer will be useful, but it's not decentralized. Over time, we'll switch to decentralized, fair sequencing, as described below.

Since a trusted party will initially run the Sequencer and it will be decentralized later, we haven't built a mechanism to punish a misbehaving Sequencer directly. We're asking users to trust the centralized Sequencer initially, until we transition to decentralized fair sequencing later.

### Decentralized fair sequencing

Viewed from 30,000 feet, decentralized fair sequencing isn't too complicated. Instead of being a single centralized server, the Sequencer is a committee of servers. As long as a large enough supermajority of the Committee is honest, the Sequencer will establish a fair ordering over transactions.

Achieving this is more complicated. Research by a team at Cornell Tech, including Offchain Labs and Co-founder Steven Goldfeder, developed the first-ever decentralized fair sequencing algorithm. With some improvements currently under development, these concepts will form the basis for our longer-term solution: a fair, decentralized Sequencer.

## Bridging

We have already covered how users interact with L2 contracts - they submit transactions by putting messages into the chain's inbox, or having a full node Sequencer or aggregator do so on their behalf. Let's talk about how contracts interact between L1 and L2 - how an L1 contract calls an L2 contract, and vice versa.

The L1 and L2 chains operate asynchronously, so it is not possible to make a cross-chain call that produces a result within the same transaction as the caller. Instead, cross-chain calls must be asynchronous, meaning that the caller submits the call at some point in time, and the call runs later. As a consequence, a cross-chain contract-to-contract call can never produce a result that is available to the calling contract (except for acknowledgement that the call was submitted successfully for later execution).

### L1 contracts can submit L2 transactions

An L1 contract can submit an L2 transaction, just like a user would, by calling the Nitro chain's inbox contract on Ethereum. This L2 transaction will run later, producing results that will not be available to the L1 caller. The transaction will execute at L2, but the L1 caller won't be able to see any results from the L2 transaction.

The advantage of this method is that it is simple and has relatively low latency. The disadvantage compared to the other method we'll describe soon is that the L2 transaction might revert if the L1 caller doesn't set the L2 gas price and maximum gas amount correctly. Because the L1 caller can't see the result of its L2 transaction, it can't be sure that its L2 transaction will succeed.

Doing this would introduce a serious problem for certain types of L1-to-L2 interactions. Consider a transaction that involves depositing a token on L1 to be made available at a specific address on L2. If the L1 side succeeds, but the L2 side reverts, you've just sent some tokens to the L1 inbox contract that are unrecoverable on either L2 or L1. Not good.

### L1 to L2 ticket-based transactions

Fortunately, we have another method for L1 and L2 calls, which is more robust against gas-related failures, that uses a ticket-based system. The idea is that an L1 contract can submit a "retryable" transaction. The Nitro chain will try to run that transaction. If the transaction is successful, no further action is required. But if the transaction fails, Nitro will create a "ticketID" that identifies that failed transaction. Later, anyone can call a special pre-compiled contract at L2, providing the `ticketID`, to attempt to redeem the ticket and re-execute the transaction.

When saving a transaction for retry, Nitro records the sender's address, destination address, callvalue, and calldata. All of this gets saved, and the callvalue is deducted from the sender's account and (logically) attached to the saved transaction.

If the redemption is successful, the transaction completes, a receipt is issued, and the `ticketID` is canceled and can't be used again. If the redemption fails, for example, because the packaged transaction fails, the redemption reports failure, and the `ticketID` remains available for redemption.

Normally, the original submitter will attempt to ensure their transaction succeeds immediately, so it never needs to be recovered or retried. As an example, our "token deposit" use case above should, in the happy, common case, still only require a single signature from the user. If this initial execution fails, the `ticketID` will still exist as a backstop, which others can redeem later.

Submitting a transaction in this way carries a price in'ETH` which the submitter must pay, which varies based on the calldata size of the transaction. Once submitted, the ticket remains valid for approximately one week. If the ticket redemption doesn't occur within that period, it will get deleted.

When the ticket is redeemed, the pre-packaged transaction runs with the sender and origin equal to the original submitted values, and with the destination, callvalue, and calldata provided by the submitter at the time of submission.

This mechanism is more cumbersome than ordinary L1 to L2 transactions. However, it has the advantage that the submission cost is predictable and the ticket will always be available for redemption if the submission cost is paid. As long as a user is willing to redeem the ticket, the Layer 2 transaction will eventually be executed and will not be deleted.

:::info More information

For a deeper look into L1-to-L2 Messaging, read more in the [deep dive](/how-arbitrum-works/deep-dives/l1-to-l2-messaging.mdx).

:::

### L2 to L1 ticket-based calls

Calls from L2 and L1 operate similarly, utilizing a ticket-based system. An L2 contract can call a method of the precompiled ArbSys contract to send a transaction to L1. When the execution of the L2 transaction containing the submission receives confirmation on L1 (potentially some days later), a ticket gets created in the L1 outbox contract. The ticket is triggerable by anyone who calls an L1 outbox method and submits the `ticketID`. The ticket is only marked as redeemed if the L1 transaction does not revert.

These L2-to-L1 tickets have an unlimited lifetime, until they're successfully redeemed. No rent is required, as a record of the ticket (actually a Merkle hash of the tickets) gets stored on Ethereum storage, which does not require rent. (L2 transaction fees cover the cost of allocating storage for the ticket Merkle roots.)

:::info More information

For further reading, take a look at the [L2-to-L1-messaging](/how-arbitrum-works/deep-dives/l2-to-l1-messaging.mdx) deep dive.

## Gas and Fees

NitroGas (so-called to avoid confusion with Layer 1 Ethereum gas) is used by Arbitrum to track the execution cost on a Nitro chain. It works similarly to Ethereum gas, in that every EVM instruction incurs the same amount of gas as it would on Ethereum.

## The Speed Limit

The security of Nitro chains relies on the assumption that when one validator creates an assertion, other validators will verify it and respond with a correct assertion and a challenge if it is incorrect. This assumption requires that the other validators have the time and resources to check each assertion quickly enough to issue a timely challenge. The Arbitrum protocol takes this into account in setting deadlines for assertions.

This security feature sets an effective speed limit on execution of a Nitro chain: in the long run, the chain cannot make progress faster than a validator can emulate its execution. If assertions are published at a rate faster than the speed limit, their deadlines will go further into the future. Due to the limit imposed by the rollup protocol contracts on how far into the future a deadline can be, this will eventually cause new assertions to be slowed down, thereby enforcing the effective speed limit.

Being able to set the speed limit accurately depends on being able to estimate the time required to validate an assertion, with some accuracy. Any uncertainty in estimating validation time will force us to set the speed limit lower to ensure safety. We do not want to lower the speed limit, so we aim to enable accurate estimation of the speed limit.

## Fees

User transactions pay fees to cover the operating costs of the chain. These fees are assessed and collected by ArbOS at L2 (denominated in `ETH`).

Two types of resources can incur fees during a transaction:

- **L2 gas**: an Ethereum-equivalent amount of gas, as required to execute the transaction on the Nitro chain
- **L1 calldata**: a fee per unit of L1 calldata attributable to the transaction, only chargeable if the transaction came in via the Sequencer, and is paid to the Sequencer to cover its costs

## L2 gas fees

L2 gas fees work very similarly to gas on Ethereum. A transaction consumes a certain amount of gas, which gets multiplied by the current base fee to determine the L2 gas fee for the transaction..

A version of the "exponential mechanism" sets the L2 base fee, which has been widely discussed in the Ethereum community and shown to be equivalent to Ethereum's EIP-1559 gas pricing mechanism.

The algorithm compares gas usage against a parameter called the "speed limit," which is the target amount of gas per second that the chain can handle sustainably over time. (Currently, the speed limit on Arbitrum One is 7,000,000 gas per second.) The algorithm tracks a gas backlog. Whenever a transaction consumes gas, that gas gets added to the backlog. Whenever the clock ticks one second, the speed limit gets subtracted from the backlog; however, the backlog can never go below zero.

Intuitively, if the backlog grows, the algorithm should increase the gas price to slow gas usage, as usage exceeds the sustainable level. If the backlog shrinks, the price should decrease again because usage has been below the sustainable limit, allowing for the accommodation of more gas usage.

To make this more precise, the basefee is an exponential function of the backlog, $$ F = exp(-a(B-b)) $$, where `a' and `b`are suitably chosen constants:`a' controls how rapidly the price escalates with backlog, and `b` allows a small backlog before the basefee escalation begins.

### L1 calldata fees

L1 calldata fees exist because the Sequencer, or the batch poster, which posts the Sequencer's transaction batches on Ethereum, incurs costs in L1 gas to post transactions on Ethereum as calldata. Funds collected in L1 calldata fees are credited to the batch poster to cover its costs.

Every transaction that comes in through the Sequencer will pay an L1 calldata fee. Transactions that come in through the delayed inbox do not incur this fee because they don't contribute to batch posting costs. However, these transactions do pay gas fees to Ethereum when added to the delayed inbox.

The L1 pricing algorithm assigns an L1 calldata fee to each Sequencer transaction. First, it computes the transaction's size, which is an estimate of the number of bytes the transaction will add to the compressed batch it is in; the formula for this calculation includes an estimate of how compressible the transaction is. Second, it multiplies the computed size estimate by the current price per estimated byte to determine the transaction's L1 calldata `wei`, in `wei`. Finally, it divides this cost by the current L2 base fee to translate the fee into L2 gas units. The result gets reported as the "poster fee" for the transaction.

The dynamic algorithm determines the price per estimated byte by comparing the total L1 calldata fees collected to the total fees paid by batch posters. It aims to align these two amounts as closely as possible. If batch posters pay less than the collected fees, the algorithm will adjust the price accordingly. Conversely, if their costs exceed the collected fees, it will result in a decrease in the price.

### Total fee and gas estimation

The total fee charged for a transaction is the L2 base fee multiplied by the sum of the L2 gas used and the L1 calldata charge. As on Ethereum, a transaction will fail if it fails to supply enough gas, or if it specifies a base fee limit that is below the current base fee. Ethereum also allows a "tip," but Nitro ignores this field and never collects any tips.

## Inside AnyTrust

AnyTrust is a variant of Arbitrum Nitro technology that lowers costs by accepting a mild trust assumption.

The Arbitrum protocol requires that all Arbitrum nodes, including validators, have access to the data of every L2 transaction in the Arbitrum chain's inbox. An Arbitrum rollup provides data access by posting the data (in batched, compressed form) on L1 Ethereum as calldata. The Ethereum gas to pay for this is the largest component of the cost in Arbitrum.

AnyTrust relies instead on an external Data Availability Committee (hereinafter referred to as "the Committee") to store data and provide it on demand. The Committee has `N` members, of which AnyTrust assumes at least two are honest. This assumption means that if `N-1` Committee members promise to provide access to some data, at least one of the promising parties must be honest, ensuring that the data will be available so that the rollup protocol can function correctly.

### Keysets

A Keyset specifies the public keys of Committee members and the number of signatures required for a Data Availability Certificate to be valid. Keysets enable Committee membership changes and provide Committee members with the ability to update their keys.

A Keyset contains:

- the number of Committee members, and
- for each Committee member, a BLS public key, and
- the number of Committee signatures required

Keysets are identifiable by their hashes.
An L1 KeysetManager contract maintains a list of currently valid Keysets. The L2 chain's Owner can add or remove Keysets from this list. When a Keyset becomes valid, the KeysetManager contract emits an L1 Ethereum event containing the Keyset's hash and full contents. This emission allows the contents to be recovered later by anyone, provided only the Keyset hash is known.

Although the API does not limit the number of Keysets that can be valid at the same time, normally, only one Keyset will be valid.

### Data Availability Certificates

A central concept in AnyTrust is the Data Availability Certificate (hereinafter referred to as a "DACert"). A DACert contains:

- The hash of a data block, and
- An expiration, and
- Proof that `N-1` Committee members have signed the (hash, expiration time) pair, consisting of:
  - The hash of the Keyset used in signing, and
  - A bitmap saying which Committee members signed, and
  - A BLS aggregated signature (over the BLS12-381 curve) proving that those parties signed

Because of the `2-of-N` trust assumption, a DACert constitutes proof that the block's data (i.e., the preimage of the hash in the DACert) will be available from at least one honest Committee member, at least until the expiration time.

AnyTrust provides the Sequencer with two options for posting a data block on L1: it can post the full data as described above, or it can post a DACert proving the availability of the data. The L1 inbox contract will reject any DACert that uses an invalid Keyset; the other aspects of DACert validity get checked by L2 code.

In ordinary (non-AnyTrust) Nitro, the Arbitrum sequencer posts data blocks on the L1 chains as calldata. The L1 inbox contract commits the hashes of the data blocks, making the data reliably readable to L2 code.

The L2 code that reads data from the inbox reads a full data block, just like in ordinary Nitro. If it sees a DACert instead, it checks the validity of the DACert, regarding the Keyset specified by the DACert (which is known to be valid because the L1 inbox verified that). The L2 code verifies that:

- The number of signers is at least the number required by the Keyset, and
- The aggregated signature is valid for the claimed signers, and
- The expiration time is at least two weeks after the current L2 timestamp

If the DACert is invalid, the L2 code discards the DACert and moves on to the next data block. If the DACert is valid, the L2 code reads the data block, which is guaranteed to be available because the DACert is valid.

### Data Availability Servers

Committee members run the Data Availability Server (DAS) software. The DAS exposes two APIs:

- The Sequencer API, which is to be called only by the Arbitrum chain's Sequencer, is a JSON-RPC interface allowing the Sequencer to submit data blocks to the DAS for storage. Deployments will typically block access to this API from callers other than the Sequencer.
- The REST API, which is to be available to the world, is a RESTful HTTP(S) based protocol that allows fetching data blocks by hash. This API is fully cacheable, and deployments can utilize a caching proxy or CDN to increase scalability and protect against DoS attacks.
  Only Committee members have reason to support the Sequencer API. We expect others to run the REST API, and that is helpful. (More on that below.)

The DAS software, based on configuration options, can store its data in local files, a Badger database, Amazon S3, or redundantly across multiple backing stores. The software also supports optional caching in memory (using Bigcache) or in a Redis instance.

### Sequencer-Committee Interaction

When the Arbitrum sequencer produces a data batch that it wants to post using the Committee, it sends the batch's data, along with an expiration time (usually three weeks in the future) via RPC to all Committee members in parallel. Each Committee member stores the data in its backing store, indexed by the data's hash. Then, the member signs the (hash, expiration time) pair using its BLS key and returns the signature along with a success indicator to the Sequencer.

Once the Sequencer has collected enough signatures, it can aggregate the signatures and create a valid DACert for the (hash, expiration time) pair. The Sequencer then posts that DACert to the L1 inbox contract, making it available to the AnyTrust chain software at L2.

If the Sequencer fails to collect enough signatures within a few minutes, it will abandon the attempt to use the Committee and "fall back to rollup" by posting the full data directly to the L1 chain, as it would in a non-AnyTrust chain. The L2 software can understand both data posting formats (via DACert or full data) and handles each one correctly.

:::info More information

For a deep dive into AnyTrust, refer to the [AnyTrust Deep Dive](/how-arbitrum-works/deep-dives/anytrust-protocol.mdx).

:::
