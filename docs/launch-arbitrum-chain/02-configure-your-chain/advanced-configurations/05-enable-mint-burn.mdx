---
title: 'Enable native mint and burn'
sidebar_label: 'Enable mint and burn'
description: 'Learn about native mint and burn and how to configure it.'
author: pete-vielhaber
sme: lamtrinh259
user_story: As a current or prospective Arbitrum chain owner, I need to understand how to integrate the native mint and burn feature.
content_type: get-started
---

import ImageZoom from '@site/src/components/ImageZoom';

:::warning Understand the risk

Native Mint/Burn ships with ArbOS 41. We expect it to be included in ArbOS 50, but it will be turned off by default. **Only enable this feature** if your chain needs the gas token to use an external mint/burn bridge and you are comfortable running a fork that is still under active hardening. Our team will be unable to provide extensive technical support for this feature with ArbOS 41. We recommend that teams wait for ArbOS 50 to use this feature, as it will be a more stable release.

:::

Arbitrum chains are designed to “lock and mint” the native gas token in the canonical bridge. This process ensures the child chain's representation of the gas token is always backed by the parent chain's gas token, locked in the canonical bridge.

This "lock and mint" pattern is not compatible with an emerging category of "native interop tokens." These tokens rely on cross-chain messaging layers to facilitate a burn-and-mint approach to cross-chain bridging, meaning the representative asset is burned on the source chain and minted on the destination chain. Examples of tokens with this pattern include: LayerZero OFTs, the xERC-20 standard, or stablecoins such as Circle’s USDC (possible with Circle-supplied adapter).

ArbOS 41 introduces the ability for native-interop tokens to work seamlessly as the gas token of an Arbitrum chain. This feature allows a chain owner (`ArbOwner`) to manage:

1. Permissioning of onchain addresses (typically, a token adapter contract) that have mint and burn access to the chain's native gas token on the child chain.
2. A security switch to time lock changes to Native Mint and Burn permissioned addresses (mitigating the risk of misuse or attack).
3. A collateral-sweeping method to ensure the third-party native interop token’s cross-chain adapter contract always remains properly collateralized.

:::info Important

The Native Mint/Burn feature permits mint & burn capability of the rollup’s native gas token by a permissioned address on the rollup. It does not provide a solution for cross-chain interoperability and is not a replacement for third-party omni-chain gas token products offered by partners such as LayerZero or Hyperlane. The table below helps clarify the components required to enable the use cases listed below.

:::

| Component                                       | Maintainer                                         | Role/purpose                                                                                                                                                                                                |
| ----------------------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ArbOS/Nitro (consensus-v41)                     | Offchain Labs                                      | - Precompile `ArbNativeTokenManager`<br />- Owner allowlist and seven-day time lock<br />-Node rule that blocks value-bearing withdrawals while an owner is present                                         |
| Adapter contract                                | Bridge infra provider (LayerZero, Hyperlane, etc.) | - Verifies cross-chain messages<br />- Calls `mintNativeToken` / `burnNativeToken` on L2<br />- Manages collateral vault on L1                                                                              |
| Chain Configuration and Adjacent Infrastructure | RaaSes                                             | - Permission the adapter address with mint & burn<br />- Run the outbox-sweep bot (this could also be run by LayerZero)<br />- Monitor time lock and supply events (could also be the responsibility of LZ) |

## Use cases

- LayerZero OFTs as gas tokens.
- `xERC-20` token as a gas token.
- Stablecoins (e.g., `USDC`) use mint/burn functionality for cross-chain interop.

:::caution

- **We do not recommend enabling** Native Mint/Burn if your chain relies on the canonical bridge for liquidity or if you cannot comfortably implement the operational safeguards listed below.
- This feature is bridge-agnostic, so it’s possible to migrate from a bridge adapter implementation (e.g., LayerZero-OFT adapter) to another adapter without forking the chain or changing the gas token.
- **Infra-level benefit**: unifies liquidity so Orbit users see only one native gas token and avoid the previous “two bridge pools” condition (LayerZero integration still uses a lockbox/representation model, thus it does not remove wrapping globally).

:::

## Feature architecture

Three components make up the Native Mint/Burn feature:

- **Time lock gate (safety switch)**: a safety feature that tells the chain owners when the feature is live. The default value is seven days to give chain owners sufficient time to identify and prevent a malicious owner addition.
- **Mint and burn precompile**: the primary component that gives access control and admin interface.
	- `mintNativeToken(uint256 amount)`: mints to the caller (the adapter), the adapter then transfers to the end user in the same transaction.
	- `burnNativeToken(uint256 amount)`: burns the caller’s balance as part of an exit.
- **Collateral-safety track**: this ensures that all withdrawals are processed through the adapter and includes an L1 helper contract to sweep any native gas stuck in the bridge to the adapter's escrow.

Below is a high-level data-flow diagram:

<ImageZoom
  src="/img/native-mint-burn-high-level-data-flow.svg"
  alt="High level data flow for Native Mint and Burn"
  className="img-600px"
/>

### Security time lock

As Native Mint/Burn introduces a security risk (an ArbOwner-level attacker can mint unlimited native gas), we will introduce a **speed bump/delay** feature that presents a **hard-coded delay** for enabling Native Mint/Burn capabilities.

Our hard-coded default for this period is seven **days**, commensurate with existing L2BEAT advisories on time locks. This period should give the chain owner time to respond to an attacker’s attempt to mint/burn the native gas token.

Details for the time lock switch are:

- A chain that has already been initialized with Native Mint/Burn disabled must wait seven days for the precompiles to activate
- A chain can disable Native Mint/Burn instantly
- If a chain wants to have a lower delay (e.g., one day, one hour), they will need to maintain a small fork of Nitro that changes the [hard-coded value here](https://github.com/OffchainLabs/go-ethereum/blob/c289e79453d4fdd8644a88337885c8bf27155604/params/config_arbitrum.go#L49). This change will cause your WASM module root to change. Please refer to [customize stf](/launch-arbitrum-chain/05-customize-your-chain/customize-stf.mdx#building-the-modified-node) steps to calculate the new WASM module root and set it on the chain before starting your new node.
  :::caution Take caution
  If you want to change this constant value, make sure this value hasn't been used before and you have never called setNativeTokenManagementFrom before. If not, your chain may experience some reorg issues. If you want to change this value after you have already used it (**not recommended**), you must consider proper version control. One example is [Arb OS version control](/launch-arbitrum-chain/05-customize-your-chain/customize-arbos.mdx).
  :::

A seven-day time lock gates the feature. Call [`ArbOwner.setNativeTokenManagementFrom`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbOwner.sol#L38-L40) with a `UNIX timestamp ≥ now + 7 days` to enable the feature; disabling is instantaneous.

### Native Mint and Burn precompiles

1. The chain exposes the [`ArbNativeTokenManager`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbNativeTokenManager.sol) precompile with these methods:
   - [`mintNativeToken(uint256 amount)`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbNativeTokenManager.sol#L28-L31): when the adapter receives a valid cross-chain message, it forwards a freshly minted gas token to the user in the same transaction.
   - [`burnNativeToken(uint256 amount)`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbNativeTokenManager.sol#L36-L38): destroy native gas token as part of a withdrawal
2. Only addresses in the native-token owners list may call these methods. Chain owners manage that list through [`ArbOwner`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbOwner.sol):
   - [`addNativeTokenOwner(address)`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbOwner.sol#L19-L21)
   - [`removeNativeTokenOwner(address)`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbOwner.sol#L24-L26)

<ImageZoom
  src="/img/native-mint-burn-third-party-messaging-layer.svg"
  alt="A third-party messaging layer triggers its Adapter to unlock to a specific address. The Adapter mints new tokens and distributes them to the user."
  className="img-600px"
/>

A third-party messaging layer triggers its Adapter to unlock to a specific address. The Adapter mints new tokens and distributes them to the user.

### Collateralization technique

The main risk of having two contracts responsible for native token issuance (the third-party contract and the chain’s bridge) is collateralization imbalances. For example, you could end up with:

- 90% of tokens in the third-party contract
- 10% of tokens in the Arbitrum (Orbit) chain bridge

In which case, either could be under-collateralized for a withdrawal at any given time.

#### How to guarantee collateralization of the native mint/burn contract

To resolve the problem stated above, we can implement:

1. **Collateral Sweep:** Allow the parent-chain bridge contract to ‘sweep’ native gas tokens to a designated third-party contract. Presumably, this is the contract that holds collateral for the chain (e.g., in LayerZero’s case, the parent chain Adapter contract).
2. **Disable Orbit Bridge Withdrawals:** Disabling withdrawals on the Orbit chain, which ensures the third-party token contract is the primary way to exit the chain (prevents an under-collateralized withdrawal on the bridge).

The **Collateral Sweep** is implemented by adding an Outbox contract to the bridge that can permissionlessly send **only** native gas tokens locked on the parent chain bridge to a third-party contract. This keeps all collateral in one place when mint/burn is enabled. 

**[This PR contains additional details about the Outbox contract](https://github.com/OffchainLabs/nitro-contracts/pull/339):**
  - Outbox contracts are authorized to spend funds from the bridge. They can be registered using the admin function `setOutbox`.
  - Typically, an Outbox contract requires verification of proof for an authorized withdrawal to occur. We can design one that permissionlessly sends native gas to a destination on the parent chain.

**Disabling Withdrawals** can be achieved by adapting the Nitro node to prevent non-zero value withdrawals. This approach still maintains our censorship-resistant properties, allowing the user to [initiate a withdrawal from L1](https://github.com/OffchainLabs/nitro/pull/3255https://github.com/OffchainLabs/nitro/pull/3255).

1. Value-bearing withdrawals via the canonical bridge are automatically rejected as long as at least one native-token owner exists, ensuring that all exits occur through the external adapter.
2. A helper contract, [**`ERC20MigrationOutbox`**](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/bridge/extra/ERC20MigrationOutbox.sol), can sweep any “dust” that lands in the bridge and transfer it to the external adapter on L1.

## Recommended configuration

### Prerequisites

Before starting, ensure that the chain has:

| Item             | Minimum version                                                                                                                 |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| nitro-contracts  | [v3.1.1](https://github.com/OffchainLabs/nitro-contracts/releases/tag/v3.1.1) (includes the `ArbNativeTokenManager` precompile) |
| nitro-node       | [consensus-v41](https://github.com/OffchainLabs/nitro/releases/tag/consensus-v41) tag                                           |
| go-ethereum fork | Included in ArbOS 41                                                                                                            |

We suggest the following baseline or values for production chains:

- ArbOS version: 41 or later
- Call [`ArbOwner.setNativeTokenManagementFrom`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbOwner.sol#L38-L40) to activate with a future timestamp ≥ 7 days ahead
- Native-token owners list: only the bridge adapter contract(s) to minimize the attack surface
- Outbox sweep bot: run once per hour to prevent stray collateral build-up
- Adapter contract must implement replay‑protection and supply accounting, as these requirements are out-of-scope for ArbOS.

## Enable the feature post-genesis

The steps below demonstrate the flow a RaaS team would use to whitelist a bridge adapter. The example below uses a Foundry call, but you can also use other tools to interact with the precompiles directly.

1. Update your chain to ArbOS 41 binaries and deploy the consensus-v41 WASM root.
2. Set [`NativeTokenManagementFrom`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbOwner.sol#L38-L40) with the chain owner and a UNIX timestamp that is 7+ days in the future to enable the feature; otherwise, the call will fail.
3. Deploy your bridge adapter (e.g., LayerZero OFT) and note the contract address.
4. Add it as a native-token owner:

```bash
cast send 0x0000000000000000000000000000000000000070 \
  "addNativeTokenOwner(address)" \
  {0xTheNewOwnerToBeAdded} \
  --private-key $PRIVATE_KEY \
	--rpc-url $RPC_URL
```

1. (_Optional_) Deploy **`ERC20MigrationOutbox`** on L1 and run a bot to call `sweep()` on a desired cadence.
2. Chain owners should monitor the following events:

- [`OwnerActs`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbOwner.sol#L260)`(0xaeb3a464, address indexed owner, bytes data)` to see adding native owner
- [`OwnerActs`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/ArbOwner.sol#L260)`(0x96a3751d, address indexed owner, bytes data)` to see removing native owner
- `NativeTokenMinted` and `NativeTokenBurned` to see token mint and burn events

The feature becomes live once the chain timestamp passes `NativeTokenManagementFromTime`. Until then, the `add/removeNativeTokenOwner` call will revert.

## Temporarily disabling the Mint/Burn feature

There may be situations where you want to disable the feature temporarily, i.e., to investigate a bridge bug or supply imbalance. All calls below are made from an [`ArbOwner`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/arbos-41/) wallet. These commands are for RaaS teams; bridge teams have their own operating procedures.

1. Inspect the current list of owners:

   ```bash
   cast call 0x000000000000000000000000000000000000006b \
     "getAllNativeTokenOwners()(address[])" \
     --rpc-url $RPC_URL
   ```

2. Remove each owner:

   ```bash
   cast send 0x0000000000000000000000000000000000000070 \
     "removeNativeTokenOwner(address)" \
     {0xTheOwnerToBeRemoved} \
     --private-key $PRIVATE_KEY \
     --rpc-url $RPC_URL
   ```

   - `mintNativeToken` and `burnNativeToken` now revert because no authorized senders remain.
   - Canonical bridge exits are now open, warm liquidity partners.

3. Verify the pause:

   ```bash
   cast call 0x000000000000000000000000000000000000006b \
     "getAllNativeTokenOwners()(address[])" \
     --rpc-url $RPC_URL
   ```

   - The list should be empty

4. (Optional but recommended) Notify downstream infrastructure: Bridges, indexers, and other relevant teams may need to be informed that canonical exits are open again and the adapter is offline.

- To re-enable the feature later, add the adapter back (no delay if `NativeTokenManagementFromTime` is a past timestamp).

```bash
cast send 0x0000000000000000000000000000000000000070 \
  "addNativeTokenOwner(address)" \
  {0xTheNewOwnerToBeAdded} \
  --private-key $PRIVATE_KEY \
  --rpc-url $RPC_URL
```

## Disabling the Native Mint/Burn feature permanently

1. Remove all native-token owners via `removeNativeTokenOwner`.
2. The `ArbOwner` calls the function `SetNativeTokenManagementFrom(0)` to freeze the action to add or remove the list of trusted adapters (owners). Setting this parameter to 0 disables future modifications to `NativeTokenOwners`; do this after the list is empty. In other words, it will lock the token-owner list forever: no new owners can be added, and nobody can re-enable Native Mint/Burn.
3. To verify behavior: `getAllNativeTokenOwners()` should return `[]` (empty list)
4. Canonical-bridge withdrawals resume automatically once the list of native-token owners is empty.

## Security checklist

| Risk                                 | Mitigation                                                                                          |
| ------------------------------------ | --------------------------------------------------------------------------------------------------- |
| Admin key compromise enables minting | Seven-day time lock, set up alerting on `NativeTokenManagementFromTime` updates                     |
| Buggy adapter over-mints tokens      | Remove owner would block mint/burn; users can burn & exit via canonical bridge after owners removed |
| Collateral split across two exits    | Canonical bridge auto-blocks withdrawals when owners exist; run Outbox sweep                        |

## (Future feature) Enable the feature at chain genesis

This feature is currently not available for implementation at chain genesis due to its dependency on another feature that is still under development. Shortly, we expect to have this feature available with the ArbOS 50 release.

## FAQs

### Who should read this page?

- Bridge/infra engineers building an adapter that mints native gas.
- RaaS operators who need to whitelist such an adapter and run the sweeper bot.

### Can I run the feature on an older version of ArbOS?

No. `ArbNativeTokenManager` and the related consensus rules only exist from version 41 onward. Attempting to add native-token owners on earlier versions will revert.

### What happens to value-bearing withdrawals once I disable the feature?

When the last native-token owner is removed, Nitro automatically reopens canonical-bridge withdrawals. No additional action is needed.

### How can developers get the timestamp value of `NativeTokenManagementFromTime`?

Filter event `OwnerActs(bytes4 indexed method, address indexed owner, bytes data)` with first index `0x89190a9f` to get all results, and decode the latest result's data field to get the last valid timestamp. That timestamp would be the point after which `ArbOwner`'s can take action to the `nativeTokenOwner` list.
