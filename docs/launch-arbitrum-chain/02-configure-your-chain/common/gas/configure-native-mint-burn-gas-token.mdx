---
title: 'Use native interop token with mint/burn as your Arbitrum chain gas token'
sidebar_label: 'Configure a native mint/burn gas token'
description: 'Learn how use a native interop token with mint/burn (such as LayerZero OFT, xERC-20, or native USDC) as your Arbitrum chain gas token'
user_story: 'As a developer or researcher of the Arbitrum product suite, I want to learn about using a native interop token with mint/burn for bridging of gas tokens'
content_type: release announcement
---

:::caution Bridge counterparty risk
While this feature allows an Arbitrum chain to use native interop tokens as gas tokens via third-party protocols, it introduces new trust assumptions. In a standard Arbitrum chain, the canonical bridge is the sole authority for minting the chain's gas token, inheriting the security of the parent chain. \
However, by using a third-party bridge for the chain's gas token, your chain's gas token—and thus its liveness—becomes directly dependent on the security and integrity of the third-party bridge provider.
:::

:::info
While Native Mint/Burn was introduced in ArbOS 41, we strongly recommend that teams upgrade to [ArbOS 51 Dia](/run-arbitrum-node/arbos-releases/arbos51) to enable this feature.
:::

Arbitrum chains are designed to “lock and mint” the native gas token in the canonical bridge. This process ensures the child representation of the gas token is always backed by the parent chain's gas token, locked in the canonical bridge.

This "lock and mint" pattern is not compatible with an emerging category of "native interop tokens." These tokens rely on cross-chain messaging layers to facilitate a "burn and mint" approach to cross-chain bridging, meaning the representative asset is burned on the source chain and minted on the destination chain. Examples of tokens with this pattern include: LayerZero OFTs, the xERC-20 standard, or stablecoins such as Circle’s Native USDC (possible with Circle-supplied adapter).

[ArbOS 51 Dia](/run-arbitrum-node/arbos-releases/arbos51) introduces the ability for native-interop tokens to work seamlessly as the gas token of an Arbitrum chain. This feature allows a chain owner (`ArbOwner`) to manage:

1. Permissioning of onchain addresses (typically, a token adapter contract) that have mint and burn access to the chain's native gas token on the child chain.
2. A security switch to timelock changes to Native Mint and Burn permissioned addresses (mitigating the risk of misuse or attack).
3. A collateral-sweeping method to ensure the 3rd-party native interop token’s cross-chain adapter contract always remains properly collateralized.

:::important
The native mint/burn feature permits mint & burn capability of the Rollup’s native gas token by a permissioned address on the Rollup. It does not provide a solution for cross-chain interoperability and is not a replacement for 3rd-party omni-chain gas token products provided by partners such as LayerZero or Hyperlane. The table below helps to clarify the components needed to enable the use cases below.
:::

| Component                                           | Maintainer                                         | Role/purpose                                                                                                                                                                                                            |
| :-------------------------------------------------- | :------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ArbOS/Nitro (consensus-v51 or higher)**           | Offchain Labs                                      | • Precompile `ArbNativeTokenManager`<br/>• Owner allowlist and 7-day timelock<br/>• Node rule that blocks value-bearing withdrawals while an owner is present                                                           |
| **Adapter contract**                                | Bridge infra provider (LayerZero, Hyperlane, etc.) | • Verifies cross-chain messages<br/>• Calls `mintNativeToken` / `burnNativeToken` on L2<br/>• Manages collateral vault on L1                                                                                            |
| **Chain Configuration and Adjacent Infrastructure** | RaaSes                                             | • Permission the adapter address with mint & burn<br/>• Run the outbox-sweep bot (this could also be run by e.g., LayerZero)<br/>• Monitor timelock and supply events (could also be responsibility of e.g., LayerZero) |

## Use cases

- LayerZero OFT as a gas token.
- xERC-20 token as a gas token.
- Stablecoins (e.g. USDC) use mint/burn functionality for cross-chain interop.

### What this feature helps with:

- Launch a new Arbitrum chain with a native mint/burn gas token using a third-party birdge provider.
- Transition an existing native gas token from the canonical bridge (lock-and-mint) to a third-party bridge (e.g., LayerZero OFT) to enable "burn-and-mint" interoperability.

### What this feature does NOT help with:

- **Changing Gas Tokens:** This feature cannot be used to swap your chain's current gas token for a completely different token.
- **Multiple Gas Tokens:** You cannot add additional native mint/burn gas tokens to your Arbitrum chain; an Arbitrum chain only supports a single native gas token.

**_Notes:_**

- We **do not** recommend enabling Native Mint/Burn if your chain relies on the canonical bridge for liquidity or if you cannot comfortably implement the operational safeguards listed below.
- This feature is **bridge-agnostic**, so it’s possible to migrate from a bridge adapter implementation (e.g., LayerZero-OFT adapter) to another adapter without forking the chain or changing the gas token.
- **Infra-level** benefit: unifies liquidity so Arbitrum stack chain users see only one native gas token and avoid the previous “two bridge pools” condition (LayerZero integration still uses a lockbox/representation model, thus it does not remove wrapping globally).

## Feature architecture

There are three components make up the Native mint/burn feature:

- **Timelock gate (safety switch):** a safety feature that tells the chain owners when the feature is live. The default value is seven days to give chain owners sufficient time to identify and prevent a malicious owner addition.
- **Mint and burn precompile:** the main component that gives access control and admin interface.
  - `mintNativeToken(uint256 amount)`: mints to the caller (the adapter), the adapter then transfers to the end user in the same transaction.
  - `burnNativeToken(uint256 amount)`: burns the caller’s balance as part of an exit.
- **Collateral-safety track:** this ensures that all withdrawals are processed through the adapter and includes an L1 helper contract to sweep any native gas stuck in the bridge to the adapter's escrow.

Below is a high-level data-flow diagram:

<ImageZoom
  src="/img/mint-burn-gas-token-hld.png"
  alt="Bridge provider mint and burn"
  className="img-600px"
/>

### Security timeLock

As native mint/burn introduces a security risk (an ArbOwner-level attacker can mint unlimited native gas), we have introduced a **speed bump/delay** feature that introduces a **hard-coded delay** for enabling native mint/burn capabilities (for an already live chain).

Our hard-coded default for this period is **seven days**, commensurate with [existing L2BEAT advisories on time locks](https://medium.com/l2beat/introducing-stages-a-framework-to-evaluate-rollups-maturity-d290bb22befe). This period should give the chain owner time to respond to an attacker’s attempt to mint/burn the native gas token.

Details for the time lock switch are:

- A chain that has already initialized with native mint/burn disabled must wait seven days for the precompiles to activate
- A chain can disable native mint/burn instantly
- If a chain wants to have a lower delay (e.g., one day, one hour), they will need to maintain a small fork of Nitro that changes the hard-coded value:
  - Hard-Coded value here: https://github.com/OffchainLabs/go-ethereum/blob/c289e79453d4fdd8644a88337885c8bf27155604/params/config_arbitrum.go#L49
  - This change will cause your WASM module root to change. Please refer to [customize STF](/launch-arbitrum-chain/customize-your-chain/customize-stf#building-the-modified-node) steps to calculate the new WASM module root and set it on the chain before starting your new node.
    :::warning
    Please note, if you want to change this constant value, make sure it hasn't been used before and you have never called `setNativeTokenManagementFrom` before. If not, your chain may experience some reorg issues. If you want to change this value after you have already used it (**not recommended**), you need to consider proper version control, one example is [ArbOS version control](/launch-arbitrum-chain/customize-your-chain/customize-arbos).
    :::

A seven-day timelock gates the feature. Call [`ArbOwner.setNativeTokenManagementFrom`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/f49a4889b486fd804a7901203f5f663cfd1581c8/ArbOwner.sol#L38-L40) with a UNIX timestamp ≥ _now + 7 days_ to enable the feature; disabling is instantaneous.

### Native mint and burn precompiles

1. The chain exposes the [`ArbNativeTokenManager`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/main/ArbNativeTokenManager.sol) precompile with these methods:
   - [`mintNativeToken(uint256 amount)`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/f49a4889b486fd804a7901203f5f663cfd1581c8/ArbNativeTokenManager.sol#L28-L30): when the adapter receives a valid cross-chain message, it forwards a freshly minted gas token to the user in the same transaction.
   - [`burnNativeToken(uint256 amount)`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/f49a4889b486fd804a7901203f5f663cfd1581c8/ArbNativeTokenManager.sol#L36-L38): destroy native gas token as part of a withdrawal
2. Only addresses in the native-token owners list may call these methods. Chain owners manage that list through [`ArbOwner`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/main/ArbOwner.sol):
   - [`addNativeTokenOwner(address)`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/f49a4889b486fd804a7901203f5f663cfd1581c8/ArbOwner.sol#L44-L46)
   - [`removeNativeTokenOwner(address)`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/f49a4889b486fd804a7901203f5f663cfd1581c8/ArbOwner.sol#L50-L52)

<ImageZoom
  src="/img/bridge-provider-mint-burn-diagram.png"
  alt="Bridge provider mint and burn"
  caption="A 3rd-party messaging layer triggers its Adapter to unlock to a specific address. The Adapter mints new tokens and distributes them to the user."
  className="img-600px"
/>

### Collateralization technique

**Guarantee collateralization of the native mint/burn contract**

The main risk of having two contracts responsible for native token issuance (the 3rd-party contract and the chain’s bridge) is collateralization imbalances. For example, you could end up with:

- 90% of tokens in the 3rd-party contract
- 10% of tokens in the Arbitrum Stack chain bridge

In which case, either could be under-collateralized for a withdrawal at any given time.

To resolve this problem, you may implement the options below:

1. **Collateral sweep:** Allow the parent-chain bridge contract to ‘sweep’ native gas tokens to a designated 3rd-party contract. Presumably, this is the contract that holds collateral for the chain (e.g., in LayerZero’s case, the parent chain's Adapter contract).
2. **Disable Arbitrum chain bridge withdrawals:** Disabling withdrawals on the Arbitrum stack chain, which ensures the 3rd-party token contract is the primary way to exit the chain (prevents an under-collateralized withdrawal on the bridge).

The **collateral sweep** is implemented by adding an outbox contract to the bridge that can permissionlessly send **only** native gas tokens locked on the parent chain bridge to a 3rd-party contract. This keeps all collateral in one place when mint/burn is enabled.

- [Outbox contracts](https://github.com/OffchainLabs/nitro-contracts/pull/339) are authorized to spend funds from the bridge. They can be registered using the admin function `setOutbox`.

  Typically, an Outbox contract requires verification of a proof for an authorized withdrawal to occur. A custom contract can be designed that permissionlessly sends native gas to a destination on the parent chain.

**Disabling withdrawals** is achievable by adapting the Nitro node to prevent non-zero value withdrawals. This approach still maintains our censorship-resistant properties, allowing the user to initiate a withdrawal from L1.

1. Value-bearing withdrawals via the canonical bridge are automatically rejected as long as at least one native-token owner exists, ensuring that all exits occur through the external adapter.
2. A helper contract, [**`ERC20MigrationOutbox`**](https://github.com/OffchainLabs/nitro-contracts/blob/main/src/bridge/extra/ERC20MigrationOutbox.sol), can sweep any “dust” that lands in the bridge and transfer it to the external adapter on L1.

## Recommended configuration

### Prerequisites

Before starting, ensure that the chain has:

| Item             | Minimum version                                                                                                                                   |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| nitro-contracts  | [v3.1.1](https://github.com/OffchainLabs/nitro-contracts/releases/tag/v3.1.1) or higher (includes the ERC20MigrationOutbox)                       |
| nitro-node       | [v3.9.3](https://github.com/OffchainLabs/nitro/releases/tag/v3.9.3) or higher (includes the fix for `ArbNativeTokenManager` precompile inclusion) |
| go-ethereum fork | Included in [ArbOS 51 Dia](/run-arbitrum-node/arbos-releases/arbos51) (please use the latest WASM module root, see below) or later                |

We suggest the following baseline or values for production chains:

- ArbOS version 51 or later. The latest WASM module root for ArbOS 51 Dia is `0x8a7513bf7bb3e3db04b0d982d0e973bcf57bf8b88aef7c6d03dba3a81a56a499`
- Call [`ArbOwner.setNativeTokenManagementFrom`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/f49a4889b486fd804a7901203f5f663cfd1581c8/ArbOwner.sol#L38-L40) to activate with a future timestamp ≥ 7 days ahead. This is recommended for chains which are already live.
- Native-token owners list: only the bridge adapter contract(s) to minimize the attack surface.
- Outbox sweep bot: run once per hour to prevent stray collateral build-up.
- Adapter contract must implement replay‑protection and supply accounting as these requirements are out-of-scope for ArbOS.

## How to configure the feature for your chain

:::info
The native token mint/burn feature is currently not available for implementation at chain genesis. The ability to activate it during chain initialization will be part of a future release.
:::

### Enable the feature post-genesis

Below steps show the flow a RaaS / chain team can use to whitelist a bridge adapter. The example below uses a Foundry call, but you can also use other tools to interact with the precompiles directly.

1. Update your chain to ArbOS 51 Dia binaries and deploy the consensus-v51 WASM root.
2. Call [`setNativeTokenManagementFrom`](https://github.com/OffchainLabs/nitro-precompile-interfaces/blob/f49a4889b486fd804a7901203f5f663cfd1581c8/ArbOwner.sol#L38-L40) with the chain owner and a UNIX timestamp that is 7+ days in the future to enable the feature, otherwise the call will fail.  
   :::important
   The feature becomes live once the chain timestamp passes `NativeTokenManagementFromTime`. Until then, the `add/removeNativeTokenOwner` call will revert.
   :::
3. Deploy your bridge adapter (e.g., LayerZero OFT) and note the contract address.
4. Add the deployed bridge adapter as a native-token owner:
   ```shell
   cast send 0x0000000000000000000000000000000000000070 \
     "addNativeTokenOwner(address)" \
     {0xTheNewOwnerToBeAdded} \
     --private-key $PRIVATE_KEY \
     --rpc-url $RPC_URL
   ```
5. _(Optional)_ Deploy `ERC20MigrationOutbox` on L1 and run a bot to call `sweep()` on a desired cadence.
6. Chain owners should monitor the following events:
   - `OwnerActs(0xaeb3a464, address indexed owner, bytes data)` to see adding native owner
   - `OwnerActs(0x96a3751d, address indexed owner, bytes data)` to see removing native owner
   - `NativeTokenMinted` and `NativeTokenBurned` to see token mint and burn events

### Temporarily disabling the mint/burn feature

There may be situations where you want to disable the feature temporarily, e.g., to investigate a bridge bug or supply imbalance. All calls below are made from an [**ArbOwner**](https://github.com/OffchainLabs/nitro-precompile-interfaces/) wallet. These commands are for RaaS / chain teams, bridge teams have their own operating procedures.

1. Inspect the current list of owners.

   ```shell
   cast call 0x000000000000000000000000000000000000006b \
     "getAllNativeTokenOwners()(address[])" \
     --rpc-url $RPC_URL
   ```

2. Remove each owner.

   ```shell
   cast send 0x0000000000000000000000000000000000000070 \
     "removeNativeTokenOwner(address)" \
     {0xTheOwnerToBeRemoved} \
     --private-key $PRIVATE_KEY \
     --rpc-url $RPC_URL
   ```

   `mintNativeToken` and `burnNativeToken` now revert because no authorized senders remain.

   Canonical bridge exits are now open, warn liquidity partners.

3. Verify the pause.

   ```shell
   cast call 0x000000000000000000000000000000000000006b \
     "getAllNativeTokenOwners()(address[])" \
     --rpc-url $RPC_URL
   ```

   The list should be empty

4. _(Optional but **recommended**)_ Notify downstream infrastructure: Bridges, indexers, and other relevant teams may need to be informed that canonical exits are open again and the adapter is offline.

**To re-enable the feature later**

- Add the adapter back (no delay if `NativeTokenManagementFromTime` is a past timestamp).

  ```bash
  cast send 0x0000000000000000000000000000000000000070 \
    "addNativeTokenOwner(address)" \
    {0xTheNewOwnerToBeAdded} \
    --private-key $PRIVATE_KEY \
    --rpc-url $RPC_URL
  ```

- You can call `GetNativeTokenManagementFrom` to verify `NativeTokenManagementFromTime` value:

  ```jsx

  cast send 0x000000000000000000000000000000000000006b \
    "getNativeTokenManagementFrom()(uint64)" \
    {0xTheNewOwnerToBeAdded} \
    --private-key $PRIVATE_KEY \
    --rpc-url $RPC_URL
  ```

### Disabling the native mint/burn feature permanently

1. Remove all native-token owners via `removeNativeTokenOwner`.
2. The `ArbOwner` calls the function `SetNativeTokenManagementFrom(0)` to freeze the action to add or remove the list of trusted adapters (owners). Setting this parameter to 0 disables future modifications to `NativeTokenOwners` ; do this after the list is empty. In other words, it will lock the token-owner list forever: no new owners can be added, and nobody can re-enable Native Mint/Burn.
3. To verify behavior: `getAllNativeTokenOwners()` should return `[]` (empty list)
4. Canonical-bridge withdrawals resume automatically once the list of native-token owners is empty.

## Security checklist

| Risk                                 | Mitigation                                                                                          |
| ------------------------------------ | --------------------------------------------------------------------------------------------------- |
| Admin key compromise enables minting | Seven-day timelock, set up alerting on `NativeTokenManagementFromTime` updates                      |
| Buggy adapter over-mints tokens      | Remove owner would block mint/burn; users can burn & exit via canonical bridge after owners removed |
| Collateral split across two exits    | Canonical bridge auto-blocks withdrawals when owners exist; run Outbox sweep                        |

## FAQs

### Who should read this page?

- Bridge/infra engineers building an adapter that mints native gas.
- RaaS/chain operators who need to allowlist such an adapter and run the sweeper bot.

### Can I run the feature on an older ArbOS version?

While native mint/burn was technically introduced in ArbOS 41, we strongly recommend upgrading to [ArbOS 51 Dia](/run-arbitrum-node/arbos-releases/arbos51) for those enabling this feature.

### What happens to value-bearing withdrawals once I disable the feature?

When the last native-token owner is removed, Nitro automatically re-opens canonical-bridge withdrawals. No additional action is needed.

### How can developers get the timestamp value of `NativeTokenManagementFromTime`?

Filter event `OwnerActs(bytes4 indexed method, address indexed owner, bytes data)` with first index `0xbdb8f707` to get all results, and decode the latest result's data field to get the last valid timestamp. That timestamp would be the point after which `ArbOwner`'s can take action to `nativeTokenOwner` list.

<br />
:::caution Testing Responsibility

While Offchain Labs has conducted comprehensive [system tests](https://github.com/OffchainLabs/nitro/blob/master/system_tests/arbos_upgrade_test.go#L292)
to verify the core ArbOS logic for native mint/burn functionality, this does not cover your specific
implementation.

**Individual teams are responsible to:**

- Thoroughly test their own adapter contracts and app-layer solutions.
- Verify the security and collateralization of their specific third-party token providers (e.g., LayerZero, xERC20).
- Ensure their custom configurations are compatible with their chain's unique environment.

:::
