### Customizing Precompiles in Arbitrum Chains

Customizing precompiles in Arbitrum chains, including Orbit L2s and L3s, allows you to extend functionality by adding new methods to existing precompiles, creating entirely new precompiles, or modifying state interactions. Precompiles are predefined contracts at special addresses (e.g., 0x6b for ArbSys) that execute natively for efficiency, providing features like L2-specific info or custom operations. This is achieved by modifying ArbOS (the L2 operating system) within the Nitro stack, which requires forking the source code, building a custom Docker image, and deploying/upgrading with fraud proof compatibility.

This process is advanced and affects the State Transition Function (STF), so it's recommended for experienced developers or teams partnering with Rollup-as-a-Service (RaaS) providers (e.g., Caldera, Zeeve) for implementation, audits, and maintenance. Customizations must maintain backward compatibility, as WASM module roots are designed to be forward-compatible with future ArbOS versions. Offchain Labs does not review individual changes, so ensure thorough testing and security audits to avoid vulnerabilities.

#### Steps to Customize Precompiles

1. **Prepare the Nitro Source Code**:

   - Clone the Nitro repository (use the latest stable branch, e.g., v3.6.5 or higher):
     ```
     git clone --branch v3.6.5 https://github.com/OffchainLabs/nitro.git
     cd nitro
     git submodule update --init --recursive --force
     ```
   - Install Docker for building images.

2. **Modify ArbOS for Custom Precompiles**:

   - Choose an customization option based on your needs (see Decisions section below). Modifications are made in Go files like `ArbSys.go`, `precompile.go`, or `arbosstate.go`.
   - **Option 1: Add a New Method to an Existing Precompile** (e.g., add `sayHi()` to ArbSys):
     - Edit the relevant precompile file (e.g., `ArbSys.go`).
     - Update `precompile.go` for version control:
       ```
       ArbSys := insert(MakePrecompile(pgen.ArbSysMetaData, &ArbSys{Address: types.ArbSysAddress}))
       arbos.ArbSysAddress = ArbSys.address
       arbos.L2ToL1TransactionEventID = ArbSys.events["L2ToL1Transaction"].template.ID
       arbos.L2ToL1TxEventID = ArbSys.events["L2ToL1Tx"].template.ID
       // Set ArbOS version for activation
       ArbOwner.methodsByName["SayHi"].arbosVersion = ${target_arbos_version}  // e.g., 30
       ```
   - **Option 2: Create a New Precompile** (e.g., ArbHi at a new address):
     - Define the precompile in a new Go file.
     - Update `precompile.go`:
       ```
       ArbHi := insert(MakePrecompile(pgen.ArbHiMetaData, &ArbHi{Address: types.ArbHiAddress}))  // Use a free address like 0x6f
       // Set activation version for the precompile
       ArbHi.arbosVersion = ${target_arbos_version}
       // Apply to all methods
       for _, method := range ArbHi.methods {
           method.arbosVersion = ${target_arbos_version}
       }
       ```
   - **Option 3: Create or Modify ArbOS State** (e.g., add a new state variable like `myNumber`):
     - Edit `arbosstate.go` to include the state in the `UpgradeArbosVersion` switch case:
       ```
       ensure := func(err error) {
           if err != nil {
               message := fmt.Sprintf(
                   "Failed to upgrade ArbOS version %v to version %v: %v",
                   state.arbosVersion, state.arbosVersion+1, err,
               )
               panic(message)
           }
       }
       nextArbosVersion := state.arbosVersion + 1
       switch nextArbosVersion {
           case ${target_arbos_version}:
               // Initialize your new state here, e.g., state.myNumber = 42
               // Add any required logic or error handling
       }
       ```
   - These changes ensure activation only after upgrading to the specified ArbOS version.

3. **Build and Run the Custom Node (Without Fraud Proofs Initially)**:

   - Build the Docker image:
     ```
     docker build . --tag custom-nitro-node
     ```
   - Edit `nodeConfig.json` to disable fraud proofs temporarily:
     ```
     "staker": {
         "dangerous": {
             "without-block-validator": true
         }
     }
     ```
   - Run using Docker Compose (for Orbit chains) or `docker run`. Test the custom precompile functionality.

4. **Enable Fraud Proofs and Deploy**:

   - Build a dev image with the replay binary:
     ```
     docker build . --target nitro-node-dev --tag custom-nitro-node-dev
     docker run --rm --entrypoint cat custom-nitro-node-dev target/machines/latest/module-root.txt
     ```
   - Extract the new WASM module root from the output.
   - Update the on-chain WASM module root via the `upgradeExecutor` contract's `executeCall()` (call data starts with `0x89384960` followed by the root). Use deployment JSON for addresses.
   - Remove the `"dangerous"` config and run the dev image.
   - Preserve the replay binary for future builds by extracting it and modifying the Dockerfile to include it (locally or via hosted URLs).

5. **Upgrade and Test**:
   - For live chains, propose an ArbOS upgrade via governance (e.g., DAO for public chains) to activate the changes.
   - Test on a devnet using the Orbit SDK, then deploy to mainnet. Audit for security and performance impacts.

#### Decisions and Considerations

Customizations are often immutable post-deployment without upgrades, so plan carefully. Use the table below for key decisions:

| Decision Area                        | Key Considerations                                                                                                                                                             | Trade-offs                                                                                                                                                                                                  |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Customization Option**             | Choose based on needs: Add methods to existing (simpler, e.g., extend ArbSys); create new precompile (for unique addresses/functionality); modify state (for persistent data). | Adding to existing is easier/less disruptive but limited by address; new ones offer flexibility but require free addresses (e.g., avoid 0x01-0x09). State mods add persistence but increase STF complexity. |
| **ArbOS Version for Activation**     | Select a future version (e.g., 30+) to activate changes; ensure compatibility with current chain state.                                                                        | Higher versions allow phased rollouts but delay deployment; must align with chain upgrades to avoid breaking existing contracts.                                                                            |
| **Chain Type (Rollup vs. AnyTrust)** | Custom precompiles work in both, but AnyTrust may need DAC configs for DA.                                                                                                     | Rollup ensures max security for custom ops; AnyTrust lowers costs but adds trust assumptions—test fraud proofs rigorously.                                                                                  |
| **Backward Compatibility**           | Design changes to be forward-compatible; use version controls to prevent activation issues.                                                                                    | Ensures smooth upgrades but limits radical changes; incompatible mods risk chain halts or forks.                                                                                                            |
| **Resource Allocation**              | Budget for audits, maintenance, and partners; self-implement if experienced.                                                                                                   | Partnering speeds up but adds costs; in-house offers control but requires Go/Nitro expertise.                                                                                                               |
| **When to Customize**                | Use for app-specific needs (e.g., custom crypto ops in gaming); skip if standard precompiles suffice.                                                                          | Enhances efficiency/utility but increases attack surface—audit thoroughly for production.                                                                                                                   |

In summary, this process forks Nitro to modify ArbOS, builds custom nodes, and upgrades on-chain. For Orbit-specific deployments, integrate with the SDK and test extensively to ensure fraud proofs remain valid.
