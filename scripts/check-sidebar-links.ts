import path from 'path';
import fs from 'fs';
import sidebars from '../sidebars';
import { SidebarItemConfig } from '@docusaurus/plugin-content-docs/src/sidebars/types';

// Validation error tracking
interface ValidationError {
  type: 'doc' | 'link' | 'category-link' | 'html' | 'autogenerated';
  reference: string;
  location: string;
  reason: string;
}

const errors: ValidationError[] = [];
const warnings: string[] = [];
let checkCounts = {
  doc: 0,
  link: 0,
  categoryLink: 0,
  html: 0,
  autogenerated: 0,
};

// Paths that are generated at build time and should skip validation
const GENERATED_PATHS = [
  'sdk/', // SDK docs generated by typedoc
  'stylus-by-example/basic_examples/', // Generated Stylus examples
  'stylus-by-example/applications/', // Generated Stylus applications
];

// Check if a document ID is in generated content
function isGeneratedContent(docId: string): boolean {
  return GENERATED_PATHS.some((path) => docId.startsWith(path));
}

// Resolve document ID to file path and check if it exists
// Docusaurus supports numbered prefixes (01-, 02-, etc.) that can be omitted in doc IDs
// This applies to both directories and files
function resolveDocPath(docId: string): string | null {
  const docsRoot = path.join(__dirname, '../docs');

  // Try direct paths first
  const mdPath = path.join(docsRoot, `${docId}.md`);
  const mdxPath = path.join(docsRoot, `${docId}.mdx`);

  if (fs.existsSync(mdPath)) return mdPath;
  if (fs.existsSync(mdxPath)) return mdxPath;

  // Try resolving path with numbered prefixes for directories and filename
  const parts = docId.split('/');
  const filename = parts.pop();

  // Recursively resolve directory path with numbered prefixes
  let currentPath = docsRoot;
  for (const part of parts) {
    const exactPath = path.join(currentPath, part);
    if (fs.existsSync(exactPath) && fs.lstatSync(exactPath).isDirectory()) {
      currentPath = exactPath;
    } else {
      // Try to find directory with numbered prefix
      const parentDirs = fs.readdirSync(currentPath);
      const matchedDir = parentDirs.find((dir) => {
        const fullPath = path.join(currentPath, dir);
        if (!fs.lstatSync(fullPath).isDirectory()) return false;

        // Match pattern: 01-dirname, 02-dirname, etc.
        const match = dir.match(/^(\d+)-(.+)$/);
        if (match) {
          const [, , baseDirname] = match;
          return baseDirname === part;
        }
        return false;
      });

      if (matchedDir) {
        currentPath = path.join(currentPath, matchedDir);
      } else {
        // Directory not found
        return null;
      }
    }
  }

  // Now try to find the file in the resolved directory
  if (fs.existsSync(currentPath) && fs.lstatSync(currentPath).isDirectory()) {
    const files = fs.readdirSync(currentPath);

    // First try exact match
    if (files.includes(`${filename}.md`)) {
      return path.join(currentPath, `${filename}.md`);
    }
    if (files.includes(`${filename}.mdx`)) {
      return path.join(currentPath, `${filename}.mdx`);
    }

    // Look for files matching pattern: \d+-filename.{md,mdx}
    const numberedFilename = files.find((f) => {
      // Match pattern: 01-filename.md, 02-filename.mdx, etc.
      const match = f.match(/^(\d+)-(.+)\.(mdx?)$/);
      if (match) {
        const [, , baseFilename] = match;
        return baseFilename === filename;
      }
      return false;
    });

    if (numberedFilename) {
      return path.join(currentPath, numberedFilename);
    }
  }

  return null;
}

// Validate a doc type reference
function validateDocReference(docId: string, location: string): void {
  checkCounts.doc++;

  // Skip validation for generated content
  if (isGeneratedContent(docId)) {
    return;
  }

  const resolvedPath = resolveDocPath(docId);
  if (!resolvedPath) {
    errors.push({
      type: 'doc',
      reference: docId,
      location,
      reason: `Document file not found at docs/${docId}.{md,mdx}`,
    });
  }
}

// Validate an internal link reference
function validateInternalLink(href: string, location: string): void {
  checkCounts.link++;

  // Strip leading slash and any anchor
  let pathToCheck = href.startsWith('/') ? href.substring(1) : href;
  if (pathToCheck.includes('#')) {
    pathToCheck = pathToCheck.split('#')[0];
  }

  // Skip empty paths (pure anchor links)
  if (!pathToCheck) {
    return;
  }

  // Check if it's a static file (PDFs, etc.)
  if (pathToCheck.endsWith('.pdf') || pathToCheck.endsWith('.zip')) {
    const staticPath = path.join(__dirname, '../static', pathToCheck);
    if (!fs.existsSync(staticPath)) {
      errors.push({
        type: 'link',
        reference: href,
        location,
        reason: `Static file not found at static/${pathToCheck}`,
      });
    }
    return;
  }

  // Skip validation for generated content
  if (isGeneratedContent(pathToCheck)) {
    return;
  }

  // Validate as document path
  const resolvedPath = resolveDocPath(pathToCheck);
  if (!resolvedPath) {
    errors.push({
      type: 'link',
      reference: href,
      location,
      reason: `Link target not found at docs/${pathToCheck}.{md,mdx}`,
    });
  }
}

// Extract href from HTML anchor tag
function extractHrefFromHtml(htmlString: string): string | null {
  const match = htmlString.match(/href=["']([^"']+)["']/);
  return match ? match[1] : null;
}

// Validate HTML type sidebar item
function validateHtmlLink(htmlValue: string, location: string): void {
  checkCounts.html++;

  const href = extractHrefFromHtml(htmlValue);
  if (!href) {
    warnings.push(`HTML link at ${location} does not contain href attribute`);
    return;
  }

  // Skip external links
  if (href.startsWith('http://') || href.startsWith('https://')) {
    return;
  }

  // Validate as internal link
  validateInternalLink(href, location);
}

// Validate autogenerated directory
function validateAutogeneratedDir(dirName: string, location: string): void {
  checkCounts.autogenerated++;

  const dirPath = path.join(__dirname, '../docs', dirName);

  if (!fs.existsSync(dirPath)) {
    errors.push({
      type: 'autogenerated',
      reference: dirName,
      location,
      reason: `Directory not found at docs/${dirName}`,
    });
    return;
  }

  if (!fs.lstatSync(dirPath).isDirectory()) {
    errors.push({
      type: 'autogenerated',
      reference: dirName,
      location,
      reason: `Path exists but is not a directory: docs/${dirName}`,
    });
    return;
  }

  // Check if directory is empty
  const files = fs.readdirSync(dirPath);
  const markdownFiles = files.filter((f) => f.endsWith('.md') || f.endsWith('.mdx'));
  if (markdownFiles.length === 0) {
    warnings.push(`Autogenerated directory at ${location} is empty: docs/${dirName}`);
  }
}

// Validate category link
function validateCategoryLink(link: any, location: string): void {
  if (link.type === 'doc' && link.id) {
    checkCounts.categoryLink++;
    validateDocReference(link.id, location);
  } else if (link.type === 'generated-index') {
    // Generated index is okay, no validation needed
  }
}

// Process a single sidebar item
function validateSidebarItem(sidebarItem: SidebarItemConfig, location: string): void {
  if (typeof sidebarItem === 'string') {
    // String-based doc references are deprecated but still work
    validateDocReference(sidebarItem, location);
    return;
  }

  switch (sidebarItem.type) {
    case 'category':
      // Validate category link if present
      if ((sidebarItem as any).link) {
        validateCategoryLink((sidebarItem as any).link, `${location} > ${sidebarItem.label}`);
      }
      // Recursively validate items
      if (sidebarItem.items) {
        validateSidebarItems(
          sidebarItem.items as SidebarItemConfig[],
          `${location} > ${sidebarItem.label}`,
        );
      }
      break;

    case 'doc':
      validateDocReference((sidebarItem as any).id, `${location} > ${sidebarItem.label}`);
      break;

    case 'link':
      const href = (sidebarItem as any).href;
      // Only validate internal links
      if (href && !href.startsWith('http://') && !href.startsWith('https://')) {
        validateInternalLink(href, `${location} > ${sidebarItem.label}`);
      }
      break;

    case 'html':
      validateHtmlLink((sidebarItem as any).value, location);
      break;

    case 'autogenerated':
      validateAutogeneratedDir((sidebarItem as any).dirName, location);
      break;

    default:
      warnings.push(`Unknown sidebar item type at ${location}: ${(sidebarItem as any).type}`);
  }
}

// Recursively validate sidebar items
function validateSidebarItems(items: SidebarItemConfig[], location: string): void {
  items.forEach((item) => {
    validateSidebarItem(item, location);
  });
}

// Main validation function
function validateAllSidebars(): void {
  if (!sidebars || Object.keys(sidebars).length === 0) {
    console.error('‚ùå No sidebars found to validate');
    process.exit(1);
  }

  Object.entries(sidebars).forEach(([sidebarName, sidebarItems]) => {
    if (!sidebarItems || !Array.isArray(sidebarItems)) {
      warnings.push(`Sidebar ${sidebarName} is not an array or is empty`);
      return;
    }

    validateSidebarItems(sidebarItems as SidebarItemConfig[], sidebarName);
  });
}

// Print results
function printResults(): void {
  const totalChecks =
    checkCounts.doc +
    checkCounts.link +
    checkCounts.categoryLink +
    checkCounts.html +
    checkCounts.autogenerated;

  if (errors.length === 0) {
    console.log('‚úÖ Sidebar validation passed!');
    console.log(
      `\nChecked ${totalChecks} references (${checkCounts.doc} doc, ${checkCounts.link} link, ${checkCounts.categoryLink} category-link, ${checkCounts.html} html, ${checkCounts.autogenerated} autogenerated)`,
    );

    if (warnings.length > 0) {
      console.log(`\n‚ö†Ô∏è  ${warnings.length} warning(s):`);
      warnings.forEach((warning) => console.log(`  - ${warning}`));
    }

    process.exit(0);
  } else {
    console.error('‚ùå Sidebar validation failed!\n');
    console.error(`Found ${errors.length} broken reference(s):\n`);

    errors.forEach((error) => {
      console.error(`[${error.type.toUpperCase()}] '${error.reference}'`);
      console.error(`  Referenced in: ${error.location}`);
      console.error(`  Error: ${error.reason}\n`);
    });

    console.error(
      `Summary: Checked ${totalChecks} references (${checkCounts.doc} doc, ${checkCounts.link} link, ${checkCounts.categoryLink} category-link, ${checkCounts.html} html, ${checkCounts.autogenerated} autogenerated)`,
    );

    process.exit(1);
  }
}

// Run validation
console.log('üîç Validating sidebar links...\n');
validateAllSidebars();
printResults();
