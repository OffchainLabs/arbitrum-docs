#!/usr/bin/env node

/**
 * @fileoverview Sync content from stylus-by-example submodule to docs directory
 * @description Replaces the complex 897-line stylusByExampleDocsHandler.ts with a maintainable solution
 * @author sync-stylus-content.js
 * @version 2.0.0 (refactored for maintainability)
 */

const fs = require('fs-extra');
const path = require('path');
const glob = require('glob');

// ============================================================================
// CONFIGURATION - All constants and settings in one place
// ============================================================================

/**
 * @typedef {Object} SyncConfig
 * @property {Object} paths - File and directory paths
 * @property {Object} content - Content processing settings
 * @property {Object} allowLists - File filtering configurations
 * @property {Object} output - Output generation settings
 */

/** @type {SyncConfig} */
const CONFIG = {
  paths: {
    sourceDir: path.join(__dirname, '../submodules/stylus-by-example/src/app'),
    targetDir: path.join(__dirname, '../docs/stylus-by-example'),
    dontEditMarker: 'DONT-EDIT-THIS-FOLDER',
    sourcePattern: '**/page.mdx',
    sidebarFileName: 'sidebar.js',
  },

  content: {
    fileExtensions: {
      source: '.mdx',
      target: '.mdx',
      sidebar: '.js',
    },
    markers: {
      contentBegin: '{/* Begin Content */}',
      frontmatterDelimiter: '---',
    },
    patterns: {
      metadata: /export\s+const\s+metadata\s*=\s*({[\s\S]*?});/,
      relativeLink: /\[([^\]]+)\]\(\.\/([\w_]+)\)/g,
    },
  },

  allowLists: {
    basicExamples: [
      'hello_world',
      'primitive_data_types',
      'variables',
      'constants',
      'function',
      'errors',
      'events',
      'inheritance',
      'vm_affordances',
      'sending_ether',
      'function_selector',
      'abi_encode',
      'abi_decode',
      'hashing',
      'bytes_in_bytes_out',
    ],
    applications: ['erc20', 'erc721', 'vending_machine', 'multi_call'],
  },

  output: {
    sections: ['basic_examples', 'applications'],
    indexFileName: 'index.mdx',
    sidebarTemplate: {
      fileHeader: '// @ts-check',
      docString: 'Autogenerated sidebar configuration for Stylus by Example',
      typeAnnotation: "/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */",
    },
  },
};

// ============================================================================
// UTILITY FUNCTIONS - Reusable helper functions
// ============================================================================

/**
 * Creates a standardized error with context information
 * @param {string} message - Error message
 * @param {string} context - Additional context (file path, operation, etc.)
 * @param {Error} [originalError] - Original error object if available
 * @returns {Error} Enhanced error object
 */
function createError(message, context, originalError = null) {
  const errorMessage = `${message} (Context: ${context})`;
  const error = new Error(errorMessage);
  error.context = context;
  error.originalError = originalError;
  return error;
}

/**
 * Logs messages with consistent formatting and timestamps
 * @param {string} level - Log level (info, warn, error, success)
 * @param {string} message - Message to log
 * @param {Object} [details] - Additional details to log
 */
function log(level, message, details = null) {
  const timestamp = new Date().toISOString();
  const emoji =
    {
      info: '🔄',
      warn: '⚠️',
      error: '❌',
      success: '✅',
      clean: '🧹',
      file: '📁',
      write: '📝',
    }[level] || 'ℹ️';

  console.log(`${emoji} ${message}`);

  if (details) {
    console.log(`   Details: ${JSON.stringify(details, null, 2)}`);
  }
}

/**
 * Converts snake_case string to Title Case
 * @param {string} snakeCaseStr - String in snake_case format
 * @returns {string} String in Title Case format
 */
function snakeCaseToTitleCase(snakeCaseStr) {
  return snakeCaseStr
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Safely evaluates a JavaScript object literal string
 * @param {string} objectStr - String representation of JavaScript object
 * @returns {Object} Parsed object
 * @throws {Error} If evaluation fails
 */
function safeEvalObjectLiteral(objectStr) {
  try {
    // Use Function constructor to safely evaluate the object literal
    return new Function(`return ${objectStr}`)();
  } catch (error) {
    throw createError('Failed to evaluate object literal', objectStr, error);
  }
}

/**
 * Escapes single quotes in strings for YAML frontmatter
 * @param {string} str - String to escape
 * @returns {string} Escaped string
 */
function escapeYamlString(str) {
  return str.replace(/'/g, "''");
}

/**
 * Generates a timestamp string for file headers
 * @returns {string} ISO timestamp string
 */
function generateTimestamp() {
  return new Date().toISOString();
}

// ============================================================================
// PATH AND FILE UTILITIES - File system operations and path manipulation
// ============================================================================

/**
 * Extracts section name from a file path relative to source directory
 * @param {string} filePath - Full file path
 * @returns {string|null} Section name ('basic_examples' or 'applications') or null
 */
function extractSectionFromPath(filePath) {
  const relativePath = path.relative(CONFIG.paths.sourceDir, filePath);
  const segments = relativePath.split(path.sep);

  return segments.length >= 2 ? segments[0] : null;
}

/**
 * Extracts the item name (directory name) from a file path
 * @param {string} filePath - Full file path to page.mdx
 * @returns {string} Directory name containing the file
 */
function extractItemNameFromPath(filePath) {
  return path.basename(path.dirname(filePath));
}

/**
 * Gets the appropriate allowlist for a section
 * @param {string} sectionName - Section name ('basic_examples' or 'applications')
 * @returns {string[]} Array of allowed file names
 */
function getAllowListForSection(sectionName) {
  const allowListMap = {
    basic_examples: CONFIG.allowLists.basicExamples,
    applications: CONFIG.allowLists.applications,
  };

  return allowListMap[sectionName] || [];
}

/**
 * Determines if a file should be processed based on allowlists
 * @param {string} filePath - Full path to the file
 * @returns {boolean} True if file should be processed
 */
function isFileAllowed(filePath) {
  const sectionName = extractSectionFromPath(filePath);
  if (!sectionName) return false;

  const itemName = extractItemNameFromPath(filePath);
  const allowList = getAllowListForSection(sectionName);

  return allowList.includes(itemName);
}

/**
 * Generates target file path from source file path
 * @param {string} sourceFile - Source file path
 * @returns {Object} Object with targetPath and metadata
 */
function generateTargetPath(sourceFile) {
  const relativePath = path.relative(CONFIG.paths.sourceDir, sourceFile);
  const targetDir = path.dirname(relativePath);

  let targetFileName;
  let finalTargetDir;

  if (targetDir === '.') {
    // Root level file
    targetFileName = CONFIG.output.indexFileName;
    finalTargetDir = CONFIG.paths.targetDir;
  } else {
    // Section subdirectory file
    const pathParts = targetDir.split(path.sep);
    const sectionName = pathParts[0];
    const itemName = pathParts[1];

    targetFileName = `${itemName}${CONFIG.content.fileExtensions.target}`;
    finalTargetDir = path.join(CONFIG.paths.targetDir, sectionName);
  }

  return {
    targetPath: path.join(finalTargetDir, targetFileName),
    targetDir: finalTargetDir,
    fileName: targetFileName,
  };
}

// ============================================================================
// CONTENT TRANSFORMATION - Text processing and content manipulation
// ============================================================================

/**
 * Converts a metadata object to YAML frontmatter format
 * @param {Object} metadata - Metadata object to convert
 * @returns {string} YAML frontmatter string
 */
function convertMetadataToYaml(metadata) {
  const yamlLines = Object.entries(metadata).map(([key, value]) => {
    if (typeof value === 'string') {
      return `${key}: '${escapeYamlString(value)}'`;
    }
    return `${key}: ${value}`;
  });

  return yamlLines.join('\n');
}

/**
 * Transforms Next.js metadata export to Docusaurus frontmatter
 * @param {string} content - File content with metadata export
 * @returns {string} Content with frontmatter instead of metadata export
 */
function convertMetadataToFrontmatter(content) {
  const match = content.match(CONFIG.content.patterns.metadata);
  if (!match) return content;

  try {
    const metadataStr = match[1];
    const metadata = safeEvalObjectLiteral(metadataStr);
    const frontmatter = convertMetadataToYaml(metadata);

    const delimiter = CONFIG.content.markers.frontmatterDelimiter;
    const replacement = `${delimiter}\n${frontmatter}\n${delimiter}`;

    return content.replace(CONFIG.content.patterns.metadata, replacement);
  } catch (error) {
    log('warn', `Could not convert metadata: ${error.message}`);
    return content;
  }
}

/**
 * Fixes relative links to work with Docusaurus URL structure
 * @param {string} content - Content with relative links
 * @returns {string} Content with fixed absolute links
 */
function fixRelativeLinks(content) {
  return content.replace(CONFIG.content.patterns.relativeLink, (match, linkText, dirName) => {
    // Convert to absolute Docusaurus path
    return `[${linkText}](/stylus-by-example/basic_examples/${dirName})`;
  });
}

/**
 * Adds content begin marker if not already present
 * @param {string} content - File content
 * @returns {string} Content with begin marker
 */
function addContentBeginMarker(content) {
  const marker = CONFIG.content.markers.contentBegin;
  if (content.includes(marker)) return content;

  const delimiter = CONFIG.content.markers.frontmatterDelimiter;
  const frontmatterEnd = content.indexOf(delimiter, 3);

  if (frontmatterEnd === -1) return content;

  const insertPos = content.indexOf('\n', frontmatterEnd + 3) + 1;
  return content.slice(0, insertPos) + `\n${marker}\n` + content.slice(insertPos);
}

/**
 * Adds "not for production" banner import and component two lines before first rust code block
 * @param {string} content - File content
 * @returns {string} Content with banner added
 */
function addNotForProductionBanner(content) {
  const firstCodeBlock = '```rust';
  const bannerCode = `
import NotForProductionBannerPartial from '../../partials/_not-for-production-banner-partial.mdx';

<NotForProductionBannerPartial />
`;

  // Find the first occurrence of ```rust code block
  const index = content.indexOf(firstCodeBlock);
  if (index === -1) {
    // No rust code block found, return content unchanged
    return content;
  }

  // Find the position two lines before the first code block
  const lines = content.substring(0, index).split('\n');
  const insertLineIndex = lines.length - 2;

  // Insert the banner at the calculated position
  lines.splice(insertLineIndex, 0, bannerCode);

  // Reconstruct the content with the banner inserted
  const newContent = lines.join('\n') + content.substring(index);
  return newContent;
}

/**
 * Applies all content transformations to a file
 * @param {string} content - Original file content
 * @returns {string} Transformed content
 */
function transformContent(content) {
  let transformedContent = content;

  // Apply transformations in sequence
  transformedContent = convertMetadataToFrontmatter(transformedContent);
  transformedContent = fixRelativeLinks(transformedContent);
  transformedContent = addContentBeginMarker(transformedContent);
  transformedContent = addNotForProductionBanner(transformedContent);

  return transformedContent;
}

// ============================================================================
// SIDEBAR GENERATION - Sidebar configuration file generation
// ============================================================================

/**
 * Creates a sidebar item object for a file
 * @param {string} sectionName - Section name (basic_examples, applications)
 * @param {string} fileName - File name without extension
 * @returns {Object} Sidebar item configuration
 */
function createSidebarItem(sectionName, fileName) {
  return {
    type: 'doc',
    id: `stylus-by-example/${sectionName}/${fileName}`,
    label: snakeCaseToTitleCase(fileName),
  };
}

/**
 * Generates the complete sidebar JavaScript file content
 * @param {string} sectionName - Section name for the sidebar
 * @param {Object[]} sidebarItems - Array of sidebar item objects
 * @returns {string} Complete sidebar file content
 */
function generateSidebarFileContent(sectionName, sidebarItems) {
  const template = CONFIG.output.sidebarTemplate;
  const timestamp = generateTimestamp();

  return `${template.fileHeader}
/**
 * @fileoverview ${template.docString} ${sectionName}
 * @description This file is automatically generated by sync-stylus-content.js
 * @generated ${timestamp}
 * @see https://docusaurus.io/docs/sidebar
 * @see https://docusaurus.io/docs/sidebar/items
 */

${template.typeAnnotation}
const sidebar = ${JSON.stringify({ items: sidebarItems }, null, 2)};

module.exports = sidebar.items;
`;
}

/**
 * Generates sidebar configuration for a section directory
 * @param {string} sectionName - Section name (basic_examples, applications)
 * @param {string[]} files - Array of file paths
 * @returns {string} Complete sidebar JavaScript file content
 */
function generateSidebar(sectionName, files) {
  const allowList = getAllowListForSection(sectionName);
  const itemsByFileName = {};

  // Collect all items by filename, skipping index files
  files.forEach((file) => {
    const fileName = path.basename(file, CONFIG.content.fileExtensions.source);

    // Skip index files (filename matches section name)
    if (fileName === sectionName) return;

    const item = createSidebarItem(sectionName, fileName);
    itemsByFileName[fileName] = item;
  });

  // Order items according to allowlist
  const orderedItems = allowList
    .map((allowedFileName) => itemsByFileName[allowedFileName])
    .filter(Boolean); // Remove undefined items

  return generateSidebarFileContent(sectionName, orderedItems);
}

// ============================================================================
// FILE OPERATIONS - High-level file processing functions
// ============================================================================

/**
 * Processes and copies a single MDX file with transformations
 * @param {string} sourcePath - Source file path
 * @param {string} targetPath - Target file path
 * @returns {Promise<boolean>} True if processing succeeded
 */
async function processFile(sourcePath, targetPath) {
  try {
    // Read and transform content
    const content = await fs.readFile(sourcePath, 'utf8');
    const transformedContent = transformContent(content);

    // Ensure target directory exists and write file
    await fs.ensureDir(path.dirname(targetPath));
    await fs.writeFile(targetPath, transformedContent);

    return true;
  } catch (error) {
    log('error', `Failed to process file: ${sourcePath}`, {
      error: error.message,
      targetPath,
    });
    return false;
  }
}

/**
 * Creates the "don't edit" marker file in target directory
 * @param {string} targetDir - Target directory path
 * @param {boolean} isSubmoduleAvailable - Whether submodule is available
 * @returns {Promise<void>}
 */
async function createDontEditMarker(targetDir, isSubmoduleAvailable = true) {
  const timestamp = generateTimestamp();
  const markerPath = path.join(targetDir, CONFIG.paths.dontEditMarker);

  const content = isSubmoduleAvailable
    ? `This folder is auto-generated from submodules/stylus-by-example
Do not edit files directly here. Edit them in the submodule instead.
Generated: ${timestamp}
`
    : `This folder would contain auto-generated content from submodules/stylus-by-example
The submodule was not available during build.
Generated: ${timestamp}
`;

  await fs.writeFile(markerPath, content);
}

/**
 * Creates empty sidebar files for sections when submodule is unavailable
 * @param {string} targetDir - Target directory path
 * @returns {Promise<void>}
 */
async function createEmptySidebars(targetDir) {
  const timestamp = generateTimestamp();
  const template = CONFIG.output.sidebarTemplate;

  const emptySidebarContent = `${template.fileHeader}
/**
 * @fileoverview Empty sidebar configuration (submodule not available)
 * @generated ${timestamp}
 */

${template.typeAnnotation}
const sidebar = {
  items: []
};

module.exports = sidebar.items;
`;

  for (const sectionName of CONFIG.output.sections) {
    const sectionDir = path.join(targetDir, sectionName);
    await fs.ensureDir(sectionDir);

    const sidebarPath = path.join(sectionDir, CONFIG.paths.sidebarFileName);
    await fs.writeFile(sidebarPath, emptySidebarContent);
  }
}

/**
 * Generates sidebar files for all processed sections
 * @param {string} targetDir - Target directory path
 * @returns {Promise<void>}
 */
async function generateAllSidebars(targetDir) {
  for (const sectionName of CONFIG.output.sections) {
    const sectionDir = path.join(targetDir, sectionName);

    if (await fs.pathExists(sectionDir)) {
      const pattern = path.join(sectionDir, `**/*${CONFIG.content.fileExtensions.source}`);
      const sectionFiles = glob.sync(pattern);

      const sidebarContent = generateSidebar(sectionName, sectionFiles);
      const sidebarPath = path.join(sectionDir, CONFIG.paths.sidebarFileName);

      await fs.writeFile(sidebarPath, sidebarContent);
      log('write', `Generated sidebar for ${sectionName}`, {
        itemCount: sectionFiles.length,
      });
    }
  }
}

// ============================================================================
// MAIN SYNC LOGIC - Core synchronization workflow
// ============================================================================

/**
 * Handles the case when the source submodule is not available
 * @returns {Promise<void>}
 */
async function handleMissingSubmodule() {
  log('warn', `Source directory not found: ${CONFIG.paths.sourceDir}`);
  log('info', 'Skipping Stylus by Example content sync.');
  log('info', 'To include this content, initialize the submodule:');
  log('info', '  git submodule update --init --recursive');

  // Create empty structure
  await fs.ensureDir(CONFIG.paths.targetDir);
  await createDontEditMarker(CONFIG.paths.targetDir, false);
  await createEmptySidebars(CONFIG.paths.targetDir);

  log('success', 'Created empty Stylus by Example structure');
}

/**
 * Processes all allowed files from source to target directory
 * @param {string[]} allowedFiles - Array of file paths to process
 * @returns {Promise<number>} Number of successfully processed files
 */
async function processAllFiles(allowedFiles) {
  let successCount = 0;

  for (const sourceFile of allowedFiles) {
    const { targetPath } = generateTargetPath(sourceFile);

    if (await processFile(sourceFile, targetPath)) {
      successCount++;
    }
  }

  return successCount;
}

/**
 * Main synchronization function
 * @returns {Promise<void>}
 */
async function syncContent() {
  log('info', 'Syncing Stylus by Example content...');

  try {
    // Check if source exists
    if (!(await fs.pathExists(CONFIG.paths.sourceDir))) {
      await handleMissingSubmodule();
      return;
    }

    // Clean and recreate target directory
    if (await fs.pathExists(CONFIG.paths.targetDir)) {
      log('clean', 'Cleaning target directory...');
      await fs.remove(CONFIG.paths.targetDir);
    }

    await fs.ensureDir(CONFIG.paths.targetDir);
    await createDontEditMarker(CONFIG.paths.targetDir, true);

    // Find and filter files
    const sourcePattern = path.join(CONFIG.paths.sourceDir, CONFIG.paths.sourcePattern);
    const allFiles = glob.sync(sourcePattern);
    const allowedFiles = allFiles.filter(isFileAllowed);

    log(
      'file',
      `Found ${allFiles.length} total files, ${allowedFiles.length} allowed files to process`,
    );

    // Process all files
    const successCount = await processAllFiles(allowedFiles);

    // Generate sidebars
    await generateAllSidebars(CONFIG.paths.targetDir);

    log('success', `Successfully synced ${successCount}/${allowedFiles.length} files`);
  } catch (error) {
    log('error', `Sync failed: ${error.message}`, {
      stack: error.stack,
      context: error.context || 'Unknown',
    });
    process.exit(1);
  }
}

// ============================================================================
// MODULE EXPORTS AND EXECUTION
// ============================================================================

// Run if called directly
if (require.main === module) {
  syncContent();
}

module.exports = {
  syncContent,
  // Export utilities for testing
  CONFIG,
  isFileAllowed,
  transformContent,
  generateSidebar,
};
