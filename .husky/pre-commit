#!/bin/sh

# Pre-commit hook for arbitrum-docs repository
# Enforces: redirect validation, submodule updates, code formatting, and type checking
# Compatible with Husky v9+ (modern Husky architecture)
# Performance optimized with selective file processing and parallel execution

# Exit immediately on any error
set -e

# Husky environment detection and CI skip logic
if [ "$HUSKY" = "0" ] || [ "$CI" = "true" ] || [ "$GITHUB_ACTIONS" = "true" ]; then
  echo "ðŸš€ Husky pre-commit hook skipped (CI environment or HUSKY=0)"
  exit 0
fi

# Cross-platform color support detection
if [ -t 1 ] && command -v tput >/dev/null 2>&1 && [ "$(tput colors)" -ge 8 ]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  CYAN='\033[0;36m'
  BOLD='\033[1m'
  NC='\033[0m'
else
  RED=''
  GREEN=''
  YELLOW=''
  BLUE=''
  CYAN=''
  BOLD=''
  NC=''
fi

# Enhanced logging functions with emojis for better UX
log_info() {
  printf "${BLUE}â„¹ï¸  [INFO]${NC} %s\n" "$1"
}

log_success() {
  printf "${GREEN}âœ… [SUCCESS]${NC} %s\n" "$1"
}

log_error() {
  printf "${RED}âŒ [ERROR]${NC} %s\n" "$1" >&2
}

log_warning() {
  printf "${YELLOW}âš ï¸  [WARNING]${NC} %s\n" "$1"
}

log_step() {
  printf "${CYAN}${BOLD}ðŸ”„ %s${NC}\n" "$1"
}

# Enhanced error handling with rollback suggestions
exit_with_error() {
  log_error "$1"
  log_info "ðŸ’¡ Tip: Use 'git commit --no-verify' to bypass hooks (not recommended)"
  log_info "ðŸ’¡ Or set HUSKY=0 to disable all hooks temporarily"
  exit 1
}

# Function to check command availability with installation hints
check_command() {
  if ! command -v "$1" >/dev/null 2>&1; then
    case "$1" in
      yarn)
        exit_with_error "Yarn not found. Install with: npm install -g yarn"
        ;;
      node)
        exit_with_error "Node.js not found. Install from: https://nodejs.org/"
        ;;
      git)
        exit_with_error "Git not found. Install from: https://git-scm.com/"
        ;;
      *)
        exit_with_error "Command '$1' not found. Please ensure it's installed and in your PATH."
        ;;
    esac
  fi
}

# Performance timing function
time_command() {
  local start_time=$(date +%s)
  "$@"
  local end_time=$(date +%s)
  local duration=$((end_time - start_time))
  log_info "â±ï¸  Completed in ${duration}s"
}

# Get list of staged files for selective processing
get_staged_files() {
  git diff --cached --name-only --diff-filter=ACMR
}

# Check if specific file types are staged
has_staged_files() {
  get_staged_files | grep -E "$1" >/dev/null 2>&1
}

# Main pre-commit validation
main() {
  log_step "Starting pre-commit hook validation..."

  # Environment and dependency checks
  log_info "ðŸ” Checking environment and dependencies..."
  check_command "node"
  check_command "yarn"
  check_command "git"

  # Verify we're in a git repository
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    exit_with_error "Not in a git repository"
  fi

  # Get staged files for optimization
  local staged_files
  staged_files=$(get_staged_files)

  if [ -z "$staged_files" ]; then
    log_warning "No staged files found. Commit may be empty."
    exit 0
  fi

  log_info "ðŸ“ Found $(echo "$staged_files" | wc -l | tr -d ' ') staged files"

  # 1. Fast redirect validation (project-specific)
  log_step "Validating redirects..."
  time_command yarn check-redirects || exit_with_error "Redirect validation failed. Fix redirect issues before committing."
  log_success "Redirect validation passed"

  # 2. Submodule updates (only if submodules are staged or .gitmodules changed)
  if echo "$staged_files" | grep -E "(\.gitmodules|submodules/)" >/dev/null 2>&1; then
    log_step "Updating git submodules..."
    time_command git submodule update --init --recursive || exit_with_error "Git submodule update failed. Check submodule configuration."
    log_success "Git submodules updated"
  else
    log_info "â­ï¸  Skipping submodule update (no submodule changes detected)"
  fi

  # 3. Selective code formatting (only format staged files)
  if has_staged_files "\.(js|jsx|ts|tsx|json|md|mdx|scss)$"; then
    log_step "Formatting staged code files..."

    # Use git to format only staged files for better performance
    local js_files md_files
    js_files=$(echo "$staged_files" | grep -E "\.(js|jsx|ts|tsx|json|scss)$" || true)
    md_files=$(echo "$staged_files" | grep -E "\.(md|mdx)$" || true)

    # Filter out files that should be ignored by Prettier
    # When passing files explicitly to Prettier, .prettierignore is bypassed
    # So we need to manually filter them out
    filter_prettier_ignored() {
      local files="$1"
      local filtered=""
      while IFS= read -r file; do
        if [ -n "$file" ]; then
          # Check if file is ignored by Prettier
          if npx prettier --file-info "$file" 2>/dev/null | grep -q '"ignored": false'; then
            filtered="$filtered$file"$'\n'
          fi
        fi
      done <<< "$files"
      echo "$filtered"
    }

    # Format JavaScript/TypeScript files if any
    if [ -n "$js_files" ]; then
      log_info "ðŸŽ¨ Formatting JS/TS files..."
      js_files=$(filter_prettier_ignored "$js_files")
      if [ -n "$js_files" ]; then
        echo "$js_files" | xargs yarn prettier --write --config "./.prettierrc.js" || exit_with_error "JavaScript/TypeScript formatting failed"
      fi
    fi

    # Format Markdown files if any
    if [ -n "$md_files" ]; then
      log_info "ðŸ“ Formatting Markdown files..."
      md_files=$(filter_prettier_ignored "$md_files")
      if [ -n "$md_files" ]; then
        echo "$md_files" | xargs yarn prettier --write --config "./.prettierrc.js" || exit_with_error "Markdown formatting failed"
      fi
    fi

    # Re-stage formatted files
    echo "$staged_files" | grep -E "\.(js|jsx|ts|tsx|json|md|mdx|scss)$" | xargs git add || true
    log_success "Code formatting completed and files re-staged"
  else
    log_info "â­ï¸  Skipping code formatting (no formattable files staged)"
  fi

  # 4. Markdown linting (only if markdown files are staged)
  if has_staged_files "\.(md|mdx)$"; then
    log_step "Validating Markdown syntax..."
    time_command yarn lint:markdown || exit_with_error "Markdown validation failed. Fix markdown syntax errors before committing."
    log_success "Markdown validation passed"
  else
    log_info "â­ï¸  Skipping Markdown validation (no markdown files staged)"
  fi

  # 5. TypeScript type checking (only if TS files are staged)
  if has_staged_files "\.(ts|tsx)$"; then
    log_step "Running TypeScript type checking..."
    time_command yarn typecheck || exit_with_error "TypeScript type checking failed. Fix type errors before committing."
    log_success "TypeScript type checking passed"
  else
    log_info "â­ï¸  Skipping TypeScript check (no TypeScript files staged)"
  fi

  # Final success message with timing
  log_success "ðŸŽ‰ All pre-commit checks passed successfully!"
  log_info "âœ¨ Commit is ready to proceed..."
}

# Trap to handle interruptions gracefully
trap 'log_error "Pre-commit hook interrupted"; exit 130' INT TERM

# Execute main function
main "$@"
