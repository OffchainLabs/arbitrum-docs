[
  {
    "question": "How does Stylus manage security issues in smart contracts when interacting with so many different languages?",
    "answer": "All languages are compiled to WASM for them to be able to work with Stylus. So it just needs to verify that the produced WASM programs behave as they should inside the new virtual machine.\n\n\n\n",
    "key": "how-does-stylus-manage-security-issues-in-smart-contracts-when-interacting-with-so-many-different-languages"
  },
  {
    "question": "Is there any analogue of the fallback function from Solidity in the Rust Stylus SDK?",
    "answer": "Yes, starting with SDK version 0.7.0, the Router trait supports both `fallback` and `receive` methods, similar to their Solidity counterparts. The `fallback` method is called when a transaction has calldata\nthat doesn't match any defined function, while the `receive` method is called when a transaction has empty calldata. You can find more information in [Fallback and receive\nfunctions](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#fallback-and-receive-functions).\n\nFor older SDK versions (pre-0.7.0), you can use a minimal entrypoint and perform raw delegate calls, forwarding your calldata. You can find more information in [Bytes-in, bytes-out\nprogramming](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#bytes-in-bytes-out-programming) and [call, static_call and\ndelegate_call](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#call-static_call-and-delegate_call).\n\n\n\n\n\n\n\n",
    "key": "is-there-any-analogue-of-the-fallback-function-from-solidity-in-the-rust-stylus-sdk"
  },
  {
    "question": "Is it possible to verify Stylus contracts on the block explorer?",
    "answer": "Currently it is not possible to verify contracts compiled to WASM on the block explorer, but we are actively working with providers to have the verification process ready for when Stylus reaches mainnet-ready status.\n\n\n\n",
    "key": "is-it-possible-to-verify-stylus-contracts-on-the-block-explorer"
  },
  {
    "question": "Do Stylus contracts compile down to EVM bytecode like prior other attempts?",
    "answer": "No. Stylus contracts are compiled down to WASM. The user writes a program in Rust / C / C++ which is then compiled down to WebAssembly.\n\n\n\n",
    "key": "do-stylus-contracts-compile-down-to-evm-bytecode-like-prior-other-attempts"
  },
  {
    "question": "How is a Stylus contract deployed?",
    "answer": "Stylus contracts are deployed onchain as a blob of bytes, just like EVM ones. The only difference is that when the contract executes, instead of invoking the EVM, we invoke a separate WASM runtime. Note that a special EOF-inspired prefix distinguishes Stylus contracts from traditional EVM contracts: when a contract's bytecode starts with the magic `0xEFF00000` prefix, it's a Stylus WASM contract.\n\n\n\n",
    "key": "how-is-a-stylus-contract-deployed"
  },
  {
    "question": "Is there a new transaction type to deploy Stylus contracts?",
    "answer": "You deploy a Stylus contract the same way that Solidity contracts are deployed. There are no special transaction types. As a UX note: a WASM will revert until a special instrumentation operation is performed by a call to the new  `ArbWasm` precompile, which readies the program for calls on-chain.\n\nYou can find instructions for deploying a Stylus contract in our [Quickstart](https://docs.arbitrum.io/stylus/stylus-quickstart#checking-your-stylus-project-is-valid).\n\n",
    "key": "is-there-a-new-transaction-type-to-deploy-stylus-contracts"
  },
  {
    "question": "Do Stylus contracts use a different type of ABI?",
    "answer": "Stylus contracts use solidity ABIs. Methods, signatures, logs, calls, etc. work exactly as in the EVM. From a user's / explorer's perspective, it all just looks and behaves like Solidity.\n\n\n\n",
    "key": "do-stylus-contracts-use-a-different-type-of-abi"
  },
  {
    "question": "Does the Stylus SDK for Rust support custom data structures?",
    "answer": "For in-memory usage, you should be able to use any implementation of custom data structures without problems.\n\nFor storage usage, it may be more complicated. Stylus uses the EVM storage system, so you'll need to define the data structure on top of it. However, in the SDK, there's a storage trait that custom types can implement to back their collections with the EVM state trie. The SDK macros are also compatible with them, although it's still fundamentally a global key-value system.\n\nYou can read more about it in the [Stylus Rust SDK page](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#storage).\n\nAs an alternative solution, you can use [entrypoint-style contracts](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#bytes-in-bytes-out-programming) for your custom data structures.\n\n",
    "key": "does-the-stylus-sdk-for-rust-support-custom-data-structures"
  },
  {
    "question": "Why do I get an error \"no library targets found in package\" when trying to compile and old example?",
    "answer": "Some of the first Stylus examples were built and deployed using a previous version of [cargo-stylus](https://github.com/OffchainLabs/cargo-stylus) (`0.1.x`). In that version, Stylus projects were structured as regular Rust binaries.\n\nSince [cargo-stylus v0.2.1](https://github.com/OffchainLabs/cargo-stylus/releases/tag/v0.2.1), Stylus projects are structured as libraries, so when trying to compile old projects you might get an error `no library targets found in package`.\n\nTo solve this, it's usually enough to rename the `main.rs` file to a `lib.rs` file.\n\n\n\n",
    "key": "why-do-i-get-an-error-no-library-targets-found-in-package-when-trying-to-compile-and-old-example"
  },
  {
    "question": "How can I generate the ABI of my Stylus contract?",
    "answer": "The \n\n has a command that allows you to export the ABI of your Stylus contract: `cargo stylus export-abi`.\n\nIf you're using the Stylus Rust SDK, you'll need to enable the `export-abi` feature in your `Cargo.toml` file like so:\n\n```rust\n[features]\nexport-abi = [\"stylus-sdk/export-abi\"]\n```\nYou'll also need to have a `main.rs` file that selects that feature.\n\nThis is an example of a `main.rs` file that allows you to export the ABI of the [stylus-hello-world](https://github.com/OffchainLabs/stylus-hello-world) example project:\n\n```rust\n#![cfg_attr(not(feature = \"export-abi\"), no_main)]\n\n#[cfg(feature = \"export-abi\")]\nfn main() {\n    stylus_hello_world::main();\n}\n```\n\n\n\n\n",
    "key": "how-can-i-generate-the-abi-of-my-stylus-contract"
  },
  {
    "question": "How can I find out if the smart contract bytecode is from a Stylus contract or Solidity contract?",
    "answer": "You can check the first three bytes of the code at the contract address. If they read `0xEFF000`, it's a Stylus program. Otherwise, it will be from a Solidity contract.\n\n",
    "key": "how-can-i-find-out-if-the-smart-contract-bytecode-is-from-a-stylus-contract-or-solidity-contract"
  },
  {
    "question": "I'm trying to work with cargo stylus on Windows and got error: failed to resolve: could not find unix in os",
    "answer": "Cargo Stylus is just compatible with Unix operating systems and not Windows. You should install `WSL` (Windows Subsystem for Linux) before using that and then use `WSL terminal` to install and use cargo stylus.\n\n\n\n",
    "key": "im-trying-to-work-with-cargo-stylus-on-windows-and-got-error-failed-to-resolve-could-not-find-unix-in-os"
  },
  {
    "question": "How can I return a struct from a function?",
    "answer": "Currently, the SDK doesn't support external structs directly, but support is in progress. For now, you can use tuples as output instead of structs.\n\nKeep in mind that structs are mapped to tuples by the Solidity ABI. You can read more about this mapping here: [Solidity ABI Specification](https://docs.soliditylang.org/en/v0.8.19/abi-spec.html#mapping-solidity-to-abi-types).\n\nSince the current SDK macro doesn't automatically handle struct-to-tuple conversions, you'll need to manually convert your struct into a tuple in the return type.\n\n",
    "key": "how-can-i-return-a-struct-from-a-function"
  },
  {
    "question": "How can I get the WASM opcodes of the compiled Stylus contracts?",
    "answer": "To view the WASM opcodes, you can convert the WebAssembly binary (WASM) to WebAssembly Text (WAT). This conversion is possible using the WebAssembly Binary Toolkit (wabt). An easy way to do this is to use the online tool [Wasm-to-Wat converter](https://webassembly.github.io/wabt/demo/wasm2wat/), which is part of wabt.\n\nFor more information or if you'd like to use the toolkit locally, you can find wabt on [GitHub](https://github.com/WebAssembly/wabt).\n\n",
    "key": "how-can-i-get-the-wasm-opcodes-of-the-compiled-stylus-contracts"
  },
  {
    "question": "What is the difference between .set and .setter?",
    "answer": "---\n\n- **`.set`****:** This method is used directly to set a value in storage. It's a straightforward way to assign a value if you only need to perform a one-time set operation.\n- **`.setter`****:** This method provides a handle to a storage slot. It allows you to both `set` and `get` the value of the storage slot, making it more versatile if you need to access the current value and also update it.\nIf you plan to both retrieve and modify a value frequently, it's more efficient to use `.setter`, assign it to a variable, and then use the `.get` and `.set` methods on that variable. However, if you only need to set a value, you can use `.set` directly.\n\n\n\n",
    "key": "what-is-the-difference-between-set-and-setter"
  }
]
