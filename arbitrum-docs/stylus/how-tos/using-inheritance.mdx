---
title: 'Using Inheritance Patterns in Stylus Contracts'
description: 'Learn how to implement inheritance patterns in your Stylus smart contracts'
author: anegg0
sme: mahsamoosavi
content_type: how-to
sidebar_position: 1
---

import CustomDetails from '@site/src/components/CustomDetails';
import { VanillaAdmonition } from '@site/src/components/VanillaAdmonition/';


# Using Inheritance Patterns in Stylus Contracts

This guide explains how to implement inheritance patterns in Stylus smart contracts. Inheritance allows you to create more modular, reusable code by extending existing contracts.

## Introduction

Inheritance is a key feature in object-oriented programming that allows a new class (or contract) to inherit properties and methods from an existing one. In Stylus, you can use inheritance to:

- Reuse code across multiple contracts
- Implement a standardized interface
- Extend functionality of base contracts
- Create a hierarchical contract structure

<VanillaAdmonition type="note">
Stylus doesn't support contract multi-inheritance yet.
</VanillaAdmonition>


## Prerequisites

Before starting, make sure you have:

- [Rust](https://www.rust-lang.org/tools/install) installed
- [Cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html) package manager
- Basic understanding of [Stylus](https://docs.arbitrum.io/stylus/stylus-quickstart) and [Rust](https://www.rust-lang.org/learn)
- [stylus-sdk](https://github.com/OffchainLabs/stylus-sdk-rs) installed

## Basic Inheritance

Here's how to implement basic inheritance in a Stylus contract:

<CustomDetails summary="Basic Inheritance Example">
```rust
use stylus_sdk::{prelude::*, storage::StorageU256};

// Base contract #[external]
impl BaseContract { #[storage]
struct Storage {
value: StorageU256,
}

    pub fn get_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.value.get())
    }

    pub fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.value.set(new_value);
        Ok(())
    }

}

// Derived contract #[external]
impl DerivedContract { #[storage]
struct Storage {
base: BaseContract,
additional_value: StorageU256,
}

    pub fn get_value(&self) -> Result<U256, Vec<u8>> {
        self.storage.base.get_value()
    }

    pub fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.base.set_value(new_value)
    }

    pub fn get_additional_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.additional_value.get())
    }

    pub fn set_additional_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.additional_value.set(new_value);
        Ok(())
    }

}

````
</CustomDetails>

In this example, `DerivedContract` inherits from `BaseContract` by including it as a field in its storage struct. This allows `DerivedContract` to reuse the functionality defined in `BaseContract` while adding its own additional functionality.

## Using Traits for Inheritance

Rust traits provide a powerful way to implement inheritance-like patterns in Stylus:

<CustomDetails summary="Trait-Based Inheritance">
```rust
use stylus_sdk::{prelude::*, storage::StorageU256};

// Define a trait for common functionality
trait ValueOperations {
    fn get_value(&self) -> Result<U256, Vec<u8>>;
    fn set_value(&mut self, value: U256) -> Result<(), Vec<u8>>;
}

// Base contract implementing the trait
#[external]
impl BaseContract {
    #[storage]
    struct Storage {
        value: StorageU256,
    }
}

// Implement the trait for the base contract
impl ValueOperations for BaseContract {
    fn get_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.value.get())
    }

    fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.value.set(new_value);
        Ok(())
    }
}

// Derived contract also implementing the trait
#[external]
impl DerivedContract {
    #[storage]
    struct Storage {
        value: StorageU256,
        additional_value: StorageU256,
    }
}

// Implement the trait for the derived contract
impl ValueOperations for DerivedContract {
    fn get_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.value.get())
    }

    fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.value.set(new_value);
        Ok(())
    }
}

// Add additional functionality
impl DerivedContract {
    pub fn get_additional_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.additional_value.get())
    }

    pub fn set_additional_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.additional_value.set(new_value);
        Ok(())
    }
}
````

</CustomDetails>

Using traits allows you to define a common interface that multiple contracts can implement, providing a form of inheritance.

## Composition-Based Inheritance

Composition is often preferred over inheritance in Rust. Here's how to use composition to achieve similar results:

<CustomDetails summary="Composition-Based Inheritance">
```rust
use stylus_sdk::{prelude::*, storage::StorageU256};

// Base contract component
struct BaseContractComponent {
value: StorageU256,
}

impl BaseContractComponent {
fn new(value: StorageU256) -> Self {
Self { value }
}

    fn get_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.value.get())
    }

    fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.value.set(new_value);
        Ok(())
    }

}

// Main contract using composition #[external]
impl MainContract { #[storage]
struct Storage {
base_component_value: StorageU256,
additional_value: StorageU256,
}

    pub fn get_value(&self) -> Result<U256, Vec<u8>> {
        let base_component = BaseContractComponent::new(self.storage.base_component_value);
        base_component.get_value()
    }

    pub fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        let mut base_component = BaseContractComponent::new(self.storage.base_component_value);
        base_component.set_value(new_value)
    }

    pub fn get_additional_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.additional_value.get())
    }

    pub fn set_additional_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.additional_value.set(new_value);
        Ok(())
    }

}

````
</CustomDetails>

With composition, you create a component that encapsulates the functionality you want to reuse, then include and delegate to it in your main contract.

## Standard Contract Inheritance

When implementing standard contracts like ERC-20 or ERC-721, inheritance can be particularly useful:

<CustomDetails summary="ERC-20 Implementation with Inheritance">
```rust
use stylus_sdk::{prelude::*, evm, msg, storage::*, alloy_primitives::Address};

// ERC-20 interface trait
trait ERC20Interface {
    fn total_supply(&self) -> Result<U256, Vec<u8>>;
    fn balance_of(&self, account: Address) -> Result<U256, Vec<u8>>;
    fn transfer(&mut self, recipient: Address, amount: U256) -> Result<bool, Vec<u8>>;
    // Additional ERC-20 methods...
}

// Base ERC-20 implementation
struct BaseERC20 {
    total_supply: StorageU256,
    balances: StorageMap<Address, U256>,
}

impl BaseERC20 {
    fn new(total_supply: StorageU256, balances: StorageMap<Address, U256>) -> Self {
        Self { total_supply, balances }
    }
}

impl ERC20Interface for BaseERC20 {
    fn total_supply(&self) -> Result<U256, Vec<u8>> {
        Ok(self.total_supply.get())
    }

    fn balance_of(&self, account: Address) -> Result<U256, Vec<u8>> {
        Ok(self.balances.get(account))
    }

    fn transfer(&mut self, recipient: Address, amount: U256) -> Result<bool, Vec<u8>> {
        let sender = msg::sender();
        let sender_balance = self.balances.get(sender);

        require(sender_balance >= amount, "Insufficient balance");

        self.balances.insert(sender, sender_balance - amount);
        self.balances.insert(recipient, self.balances.get(recipient) + amount);

        // Emit transfer event
        evm::log(Transfer { from: sender, to: recipient, value: amount });

        Ok(true)
    }
}

// Custom token extending the base ERC-20
#[external]
impl CustomToken {
    #[storage]
    struct Storage {
        total_supply: StorageU256,
        balances: StorageMap<Address, U256>,
        // Additional fields specific to the custom token
        paused: StorageBool,
    }

    pub fn total_supply(&self) -> Result<U256, Vec<u8>> {
        let base = BaseERC20::new(self.storage.total_supply, self.storage.balances);
        base.total_supply()
    }

    pub fn balance_of(&self, account: Address) -> Result<U256, Vec<u8>> {
        let base = BaseERC20::new(self.storage.total_supply, self.storage.balances);
        base.balance_of(account)
    }

    pub fn transfer(&mut self, recipient: Address, amount: U256) -> Result<bool, Vec<u8>> {
        require(!self.storage.paused.get(), "Transfers are paused");

        let mut base = BaseERC20::new(self.storage.total_supply, self.storage.balances);
        base.transfer(recipient, amount)
    }

    pub fn pause(&mut self) -> Result<(), Vec<u8>> {
        require(msg::sender() == self.owner(), "Not authorized");
        self.storage.paused.set(true);
        Ok(())
    }

    pub fn unpause(&mut self) -> Result<(), Vec<u8>> {
        require(msg::sender() == self.owner(), "Not authorized");
        self.storage.paused.set(false);
        Ok(())
    }

    fn owner(&self) -> Address {
        // Logic to get the owner
        Address::from([0; 20]) // Placeholder
    }
}

// Event struct
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Transfer {
    pub from: Address,
    pub to: Address,
    pub value: U256,
}
````

</CustomDetails>

This example shows how to implement an ERC-20 token with additional functionality by extending a base implementation.

## Advanced Inheritance Patterns

### Multi-Level Inheritance

You can create multi-level inheritance by nesting contracts:

<CustomDetails summary="Multi-Level Inheritance">
```rust
use stylus_sdk::{prelude::*, storage::StorageU256};

// Base contract #[external]
impl BaseContract { #[storage]
struct Storage {
base_value: StorageU256,
}

    pub fn get_base_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.base_value.get())
    }

    pub fn set_base_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.base_value.set(new_value);
        Ok(())
    }

}

// Intermediate contract #[external]
impl IntermediateContract { #[storage]
struct Storage {
base: BaseContract,
intermediate_value: StorageU256,
}

    pub fn get_base_value(&self) -> Result<U256, Vec<u8>> {
        self.storage.base.get_base_value()
    }

    pub fn set_base_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.base.set_base_value(new_value)
    }

    pub fn get_intermediate_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.intermediate_value.get())
    }

    pub fn set_intermediate_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.intermediate_value.set(new_value);
        Ok(())
    }

}

// Derived contract #[external]
impl DerivedContract { #[storage]
struct Storage {
intermediate: IntermediateContract,
derived_value: StorageU256,
}

    pub fn get_base_value(&self) -> Result<U256, Vec<u8>> {
        self.storage.intermediate.get_base_value()
    }

    pub fn set_base_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.intermediate.set_base_value(new_value)
    }

    pub fn get_intermediate_value(&self) -> Result<U256, Vec<u8>> {
        self.storage.intermediate.get_intermediate_value()
    }

    pub fn set_intermediate_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.intermediate.set_intermediate_value(new_value)
    }

    pub fn get_derived_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.derived_value.get())
    }

    pub fn set_derived_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.derived_value.set(new_value);
        Ok(())
    }

}

````
</CustomDetails>

### Multiple Inheritance

Rust doesn't support traditional multiple inheritance, but you can achieve similar functionality using traits and composition:

<CustomDetails summary="Multiple Inheritance Using Traits">
```rust
use stylus_sdk::{prelude::*, storage::StorageU256};

// First trait
trait ValueOperations {
    fn get_value(&self) -> Result<U256, Vec<u8>>;
    fn set_value(&mut self, value: U256) -> Result<(), Vec<u8>>;
}

// Second trait
trait NameOperations {
    fn get_name(&self) -> Result<String, Vec<u8>>;
    fn set_name(&mut self, name: String) -> Result<(), Vec<u8>>;
}

// Contract implementing both traits
#[external]
impl MultiContract {
    #[storage]
    struct Storage {
        value: StorageU256,
        // For simplicity, we're not implementing proper string storage here
        // In a real contract, you would use StorageString or similar
    }
}

// Implement first trait
impl ValueOperations for MultiContract {
    fn get_value(&self) -> Result<U256, Vec<u8>> {
        Ok(self.storage.value.get())
    }

    fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        self.storage.value.set(new_value);
        Ok(())
    }
}

// Implement second trait (simplified)
impl NameOperations for MultiContract {
    fn get_name(&self) -> Result<String, Vec<u8>> {
        // Simplified implementation
        Ok("MultiContract".to_string())
    }

    fn set_name(&mut self, _name: String) -> Result<(), Vec<u8>> {
        // Simplified implementation
        Ok(())
    }
}

// Expose trait methods through the external interface
#[external]
impl MultiContractExternal for MultiContract {
    pub fn get_value(&self) -> Result<U256, Vec<u8>> {
        ValueOperations::get_value(self)
    }

    pub fn set_value(&mut self, new_value: U256) -> Result<(), Vec<u8>> {
        ValueOperations::set_value(self, new_value)
    }

    pub fn get_name(&self) -> Result<String, Vec<u8>> {
        NameOperations::get_name(self)
    }

    pub fn set_name(&mut self, name: String) -> Result<(), Vec<u8>> {
        NameOperations::set_name(self, name)
    }
}
````

</CustomDetails>

## Best Practices

When using inheritance patterns in Stylus contracts, consider the following best practices:

1. **Favor Composition Over Inheritance**: In Rust, composition is generally preferred over inheritance. Use composition when possible.

2. **Use Traits for Interface Definitions**: Traits provide a way to define common interfaces that multiple contracts can implement.

3. **Keep Storage Layout in Mind**: When extending contracts, be careful about storage layout to avoid conflicts.

4. **Document Inheritance Relationships**: Clearly document the inheritance structure of your contracts.

5. **Test Inherited Functionality**: Ensure that functionality inherited from base contracts is properly tested.

6. **Consider Gas Efficiency**: Deep inheritance hierarchies can lead to increased gas costs. Keep your inheritance structure efficient.

## Conclusion

Inheritance patterns in Stylus contracts provide a powerful way to create modular, reusable code. By leveraging Rust's traits and composition, you can implement sophisticated contract hierarchies while maintaining the benefits of Rust's safety and performance.

Remember that Rust's approach to inheritance differs from other languages like Solidity. Understanding these differences is key to writing effective Stylus contracts.

## Next Steps

- Explore examples of inheritance in the [Stylus SDK documentation](https://github.com/OffchainLabs/stylus-sdk-rs)
- Review implementations of standard contracts like ERC-20 and ERC-721 that use inheritance patterns
- Practice implementing your own contract hierarchies using the patterns shown in this guide
