---
title: Data Availability
description: 'Learn how data availability works in arbitrum'
author: JasonWan
sme: JasonWan
user_story: As a current or prospective Arbitrum user, I need to learn more about how data availability works on Arbitrum.
content_type: get-started
---

# How Arbitrum data availability works

## What is the general view of Arbitrum data flow?

Arbitrum currently supports two primary data availability mechanisms:

**Rollup Mode:** In this mode, all transaction data is included in either the calldata of transactions submitted to the parent chain (e.g., Ethereum mainnet for Arbitrum One) or the blobs submitted by the transaction. This inclusion ensures that all data is readily available onchain for anyone to download and verify.

**Anytrust Mode:** In Anytrust mode, transaction data initially gets submitted to a group of nodes known as the Data Availability Committee (DAC). The DAC stores and distributes the data. Instead of including the entire dataset onchain, only a cryptographic proof that the data has been stored by the DAC (called a Data Availability Certificate, or DACert) is submitted to the parent chain. This proof significantly reduces the amount of data stored onchain, reducing costs.

Because of those data availability mechanisms, Arbitrum Nitro nodes synchronize their data differently than Ethereum nodes or other layer-one network nodes. While Go-Ethereum nodes utilize a sophisticated P2P network to synchronize with the Ethereum blockchain by discovering other nodes, exchanging data, and participating in the consensus mechanism, Arbitrum nodes diverge from this traditional approach and use a trustless process.

Here's how Arbitrum data flow works:

1. Batching and submission:
   1. The sequencer queues transactions and batches them together.
   2. These batches get submitted to the parent chain:
      1. In Rollup mode, the sequencer submits the batch of transactions directly to the sequencer inbox contract on the parent chain. (Blob or calldata directly)
      2. In Anytrust mode, the sequencer sends the batch to the Data Availability Committee (DAC) and then submits the Data Availability Certificate (DACert) which is returned and generated by the DAS to the parent chain.
2. Node synchronization:
   1. Upon joining the network, a full node:
      1. In Rollup mode, data is read directly from the parent chain calldata or blobs (depending on how the sequencer posts the data).
      2. In Anytrust mode, it checks the DACert to verify data availability and queries the data from the DAC.
   2. The node continues to follow this process to catch up with the latest chain height.
   3. Once caught up, the node receives updates on new sequencer-queued messages directly from the sequencer feed (we will provide details of this process in the last section).
3. Catching up:
   1. If a node falls behind the chain, it reverts to the process described in step 2 to resynchronize with the latest state.

In essence, Arbitrum nodes prioritize data retrieval from the parent chain and rely on the sequencer for real-time updates, deviating from the traditional P2P synchronization approach used by Ethereum nodes.

## How full nodes decode the data from the parent chain

Arbitrum full nodes decode data received from the parent chain (and, in the case of AnyTrust chains, the DAC) to update their local state. This process involves monitoring events, parsing data, and processing messages.

1. Event querying:
   1. Full nodes subscribe to the `SequencerBatchDelivered` event emitted by the inbox contract on the parent chain. This event signifies the arrival of a new batch of transactions.
2. Event parsing:
   1. Upon receiving the `SequencerBatchDelivered` event, the node parses the event data into a `SequencerInboxBatch` struct. This struct typically includes:
      1. `BlockHash`: The hash of the parent chain block containing the batch.
      2. `ParentChainBlockNumber`: The block number of the parent chain block.
      3. `SequenceNumber`: The sequence number of the batch.
      4. `TimeBounds`: Time constraints for the batch.
      5. `AfterDelayedAcc`: Accumulator hash after processing delayed messages.
      6. `AfterDelayedCount`: Count of delayed messages.
      7. `rawLog`: The raw event log data.
3. Data serialization:
   1. The `SequencerInboxBatch` struct serializes into a byte array.
   2. The serialized data adheres to a specific format:
      1. `TimeBounds.MinTimestamp` (8 bytes)
      2. `TimeBounds.MaxTimestamp` (8 bytes)
      3. `TimeBounds.MinBlockNumber` (8 bytes)
      4. `TimeBounds.MaxBlockNumber` (8 bytes)
      5. `AfterDelayedCount` (8 bytes)
      6. `payload` (variable length)
         1. The `payload` field further contains the following:
            1. **Type:** Indicates the header of payload (e.g., DACert, blob message).
            2. **Content:** The actual data associated with the payload header (e.g., DACert, BlobHashes, brotli compressed data).
4. Data decoding and retrieval:
   1. Based on the `payload` header:
      1. **DAS Message header:** The node queries the Data Availability Servers (DAS) to retrieve the raw data.
      2. **Blob message header:** The node decodes the blob message to obtain the raw data.
      3. **Brotli Message header:** No extra steps are needed here; continue to the next step.
   2. Data decompression: If the raw data is Brotli-compressed, the node decompresses it. It's worth noting that the raw data we get from above i and ii might also be Brotli-compressed data.
5. Message processing:

   1. After decoding and decompressing the data, the node obtains a series of batch segment messages.

      1. Message Types:

         | Batch Segment Message type             | What is the usage of this message                                                                        |
         | -------------------------------------- | -------------------------------------------------------------------------------------------------------- |
         | `BatchSegmentKindL2Message`            | This message will contain raw data on a series of transactions. Usually, this is a single block.         |
         | `BatchSegmentKindL2MessageBrotli`      | The message is the same as the above one, but this is brotli compressed data.                            |
         | `BatchSegmentKindDelayedMessages`      | This message contains a new delayed message read from the parent chain delayed inbox.                    |
         | `BatchSegmentKindAdvanceTimestamp`     | This message will notify the State Transition Function (STF) to advance a second of the timestamp state. |
         | `BatchSegmentKindAdvanceL1BlockNumber` | This message will notify STF to advance a new parent chain block number.                                 |

   2. State transition: finally, the State Transition Function (STF) processes these messages, and the STF will follow the rules to execute and update the Arbitrum node's local state.

## How full nodes sync the data from the sequencer feed

Once Arbitrum full nodes have caught up with the chain, they switch from initial synchronization to a real-time update mode. This switch involves receiving data from the sequencer feed, which continuously broadcasts updates about newly queued transactions.

1. Data acquisition:
   1. Full nodes maintain a connection to the sequencer feed or your private feed. For how to run a private feed, please refer to [**How to run a feed relay**](/run-arbitrum-node/sequencer/01-run-feed-relay.mdx)
   2. The sequencer feed transmits data packets containing information about the latest queued transactions.
2. Data decoding:
   1. Full nodes decode the received data packets using the methods described in [How to read the sequencer feed](/run-arbitrum-node/sequencer/02-read-sequencer-feed.mdx).
3. Message processing:

   1. After successful decoding, the full nodes obtain the same type of data as outlined in the previous section's Step 5.
   2. Send the message to the State Transition Function (STF) and execute.

   (This step is the same as the previous section's Step 5)
