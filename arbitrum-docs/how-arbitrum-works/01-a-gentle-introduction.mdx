---
title: 'A gentle introduction'
description: 'Learn the fundamentals of Nitro, Arbitrum stack.'
author: dzgoldman
sme: dzgoldman
user_story: As a current or prospective Arbitrum user, I need learn more about Nitros design.
content_type: get-started
---

import ImageWithCaption from '@site/src/components/ImageCaptions/';
import ImageZoom from '@site/src/components/ImageZoom';

:::info

This page gives a high-level overview. It explains <a data-quicklook-from="arbitrum">Arbitrum</a>, its purpose, and a brief "how it works." As you progress through the articles in this section, the content will get more technical and dive deeper into each component(s) and function(s) of the Arbitrum technology stack.

:::

Arbitrum is a high-throughput, trustless Layer 2 scaling solution for Ethereum, built on the Optimistic Rollup model. It achieves scalable execution with Ethereum-level security by combining offchain sequencing, deterministic computation, and onchain validation via interactive fraud proofs.

This article provides a comprehensive look at how Arbitrum processes transactions from start to finish, covering the lifecycle of a transaction as it flows through the protocol. From the moment it is submitted to the Sequencer, through execution, bridging, validation, and finalization –– the design of each stage upholds correctness, efficiency, and decentralization.

The following diagram provides a high-level system overview, showing how transactions and messages flow between Arbitrum and Ethereum. It illustrates the roles of the Sequencer, validator, State Transition Function (STF), bridging infrastructure, and proving mechanism.

The diagram is interactive –– you can click on each component to navigate to the corresponding section of the document and learn more about how that part of the system works.

<ImageZoom
  src="/img/haw-transaction-lifecycle-interactive.svg"
  alt="Interactive diagram of the transaction lifecycle"
  className="img-600px"
/>

## The transaction lifecycle: from submission to finalization
At the most basic level, an Arbitrum chain works like this:

<ImageWithCaption
  caption="Original napkin sketch drawn by Arbitrum co-founder Ed Felten"
  src="https://lh4.googleusercontent.com/qwf_aYyB1AfX9s-_PQysOmPNtWB164_qA6isj3NhkDnmcro6J75f6MC2_AjlN60lpSkSw6DtZwNfrt13F3E_G8jdvjeWHX8EophDA2oUM0mEpPVeTlMbsjUCMmztEM0WvDpyWZ6R"
/>

The original napkin drawing seems primitive, but the core idea remains true. Four big ideas make up the Arbitrum protocol:

### Sequencing, followed by deterministic execution
When a user submits a transaction to Arbitrum, it first enters the Sequencer, which establishes a global ordering of transactions.

Once ordered, transactions may interact with the parent chain via Arbitrum's canonical bridges. These interactions include moving funds or sending messages from Ethereum to Arbitrum.

### Geth at the core
After transactions are sequenced, the Arbitrum State Transition Function (STF) consumes them, thereby computing the next state of the chain. The STF operates deterministically, ensuring all validators arrive at the same result when replaying the same input.

### Separate execution from proving
At periodic intervals, validators take the resulting post-state and submit assertions (summarizing the executed state) to the parent chain. `ETH` bonds back these assertions, and other validators may challenge them in a fraud-proof dispute game.

### Optimistic Rollup with interactive fraud proofs
Once an assertion passes the challenge window without being disputed, it becomes finalized. Only then can messages originating from the child chain be executed on the parent chain. These include `ETH` or token withdrawals, as well as arbitrary cross-chain messages.


## Document structure
We take the four big ideas and break them into six key parts, each corresponding to a critical phase (or big idea) in the Arbitrum system:

### [1. Sequencing, followed by deterministic execution](/how-arbitrum-works/02-transaction-lifecycle.mdx)
Describes how the Sequencer receives user transactions and posts them to Ethereum in batches. Arbitrum's STF then processes these transactions deterministically offchain.

### [2. The Sequencer and censorship resistance](/how-arbitrum-works/03-sequencer.mdx)
Explains how users are protected against censorship via the Delayed Inbox, allowing fallback transaction submission directly to the child chain for guaranteed inclusion.

### [3. Bridging from a parent chain to a child chain](/how-arbitrum-works/10-l1-to-l2-messaging.mdx)
This section covers the inbound messaging system, including retryables, token bridging via canonical contracts, and the mechanisms that allow Ethereum to communicate with Arbitrum.

### [4. State Transition Function (STF)](/how-arbitrum-works/04-state-transition-function/01-stf-gentle-intro.mdx)
Unpacks the core state computation logic in Arbitrum –– how input messages become state updates, and how Arbitrum supports multiple execution languages like Solidity and Stylus.

### [5. Validation and proving](/how-arbitrum-works/05-validation-and-proving/01-validation-and-proving.mdx)
Describes how validators confirm chain correctness using assertions and fraud proofs. Includes bonding mechanics, challenge games, and the role of WAVM in proving execution.

### [6. Child to parent chain bridging](/how-arbitrum-works/11-l2-to-l1-messaging.mdx)
Explains outbound messaging from the child chain to the parent chain –– including `ETH` and token withdrawals, Merkle proofs, and the Outbox execution model.


## Bringing it all together
Each component of the Arbitrum system contributes to a secure, efficient, and trustless pipeline for transaction processing. From submission to sequencing, bridging, execution, validation, and withdrawal, Arbitrum ensures that every transaction is verifiable, censorship-resistant, and anchored in Ethereum's security.

These articles connect each step, from low-level protocol internals to real-world application –– offering a complete picture of how Arbitrum works under the hood.