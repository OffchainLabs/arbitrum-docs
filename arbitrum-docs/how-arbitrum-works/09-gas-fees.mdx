---
title: Gas and Fees
description: 'Learn the fundamentals of how to calculate fees on Arbitrum.'
author: pete-vielhaber
sme: TucksonDev
user_story: As a current or prospective Arbitrum user, I need to learn more about gas/fee calculations on Arbitrum.
content_type: get-started
---

<a data-quicklook-from="arbitrum">Arbitrum</a> uses gas to track the cost of execution on a Nitro chain.
It works similarly to Ethereum gas, in that every EVM instruction incurs the same amount of gas as it
would on Ethereum.

There are two parties a user pays when submitting a transaction:

- The poster, if reimbursable, for the parent chain resources, such as the parent chain calldata needed to post the transaction
- The network fee accounts for the child chain resources, which include the computation, storage, and other burdens child chain nodes must bear to service the transaction

## Allocating costs among transactions

To approximate each transaction's contribution to parent chain costs, Arbitrum employs the following method:

- **Compression estimation**:

  - Each transaction individually compresses using the Brotli compressor at its lowest compression level (fastest setting).

  - This approach reduces computational overhead within the STF.

- **Data unit calculation**:

  - The size of the compressed transaction is multiplied by 16 (since Ethereum charges 16 gas per non-zero byte).

  - This product represents the transaction's estimated footprint in data units.

- **Rationale**:

  - This method approximates the transaction's size after full batch compression.

  - While not exact, it's computationally efficient and suitable for real-time processing.

## Determining cost per data unit

Charging a transaction based on the parent chain base fee is not viable due to:

- **ArbOS limitations**:

  - ArbOS cannot directly measure the parent chain base fee

  - Relying on the Sequencer to report the parent chain base fee isn't secure, as it could manipulate fees for profit

- **Approximation errors**:

  - The estimated data units per transaction don't precisely reflect parent chain costs

  - The total number of data units charged may not be directly proportional to the Sequencer's expenses

### Adaptive pricing algorithm

To align collected fees with actual costs, Arbitrum uses an adaptive algorithm with two primary goals:

1. **Cost alignment**

   - Minimize the long-term difference between collected fees and the Sequencer's parent chain costs

2. **Stability**

   - Avoid sudden fluctuations in the data price, ensuring a stable fee environment

### Pricer components

The pricer module within ArbOS tracks:

- **Amount owed to the Sequencer**:

  - The cumulative parent chain costs incurred by the Sequencer for batch posting

- **Reimbursement fund**:

  - Collects all funds charged to transactions for parent chain fees

  - Acts as a pool to reimburse the Sequencer

- **Data unit count**:

  - The total number of recent data units processed

  - Increases with each transaction's estimated data units

- **Current parent chain data unit price**:

  - The adaptive fee per data unit expressed in `wei`

### Algorithm for price adjustment

When the Sequencer posts a batch to the parent chain inbox:

1. **Batch posting report generation**:

   - The parent chain inbox inserts a "batch posting report" transaction into the chain's <a data-quicklook-from="delayed-inbox">Delayed Inbox</a>

   - After a delay, this report gets processed by ArbOS's pricer module

2. **Processing the batch posting report**:

   - **Compute batch cost**:

     - ArbOS calculates the actual cost of posting the batch by:

       - Retrieving the batch data from the inbox state

       - Counting zero and non-zero bytes to determine parent chain gas usage

     - The cost is added to the amount owed to the Sequencer

   - **Update data units**:

     - Calculate the data units assigned to this update $(U_{\text{upd}})$

       $$
       U_{\text{upd}} = U \times \frac{T_{\text{upd}} - T_{\text{prev}}}{T - T_{\text{prev}}}
       $$

     - $U$: Total recent data units

     - $T$: Current time

     - $T_{\text{upd}}$: Time when the update occurred

     - $T_{\text{prev}}$: Time of the previous update

     - Subtract $U_{\text{upd}}$ from the total $U$

   - **Reimburse the Sequencer**:

     - Pay the Sequencer from the reimbursement fund:

       - The amount paid is the lesser of the amount owed or the fund balance.

     - Deduct the paid amount from both the reimbursement fund and the amount owed

   - **Compute surplus and derivative**:

     - Surplus ($S$):

       $$
       S = \text{Reimbursement Fund Balance} - \text{Amount Owed}
       $$

     - Derivative of surplus ($D$):

       - $D = \frac{S - S_{\text{prev}}}{U_{\text{upd}}}$

       - $S_{\text{prev}}$: Surplus at the previous update

   - **Compute derivative goal($D'$)**:

     - Establish a target derivative to eliminate surplus over time:

       - $D' = -\frac{S}{E}$

       - $E$: Equilibration constant (time horizon for balancing surplus).

   - **Adjust price ($\Delta P)$)**:

     - Calculate the change in the data unit price:

       - $\Delta P = \frac{(D' - D) \times U_{\text{upd}}}{\alpha + U_{\text{upd}}}$

       - $\alpha$: Smoothing parameter to prevent abrupt changes

     - Update the price:

       - $P = \max(0, P_{\text{prev}} + \Delta P)$

   - **Outcome**:

     - The adaptive algorithm adjusts the parent chain-data unit price to align collected fees with actual costs.

     - Ensures that the Sequencer gets fairly reimbursed while avoiding surpluses or deficits.

### Additional Considerations

- **Per-unit rewards**:

  - An optional per-unit reward can be included and payable to a designated address.

  - Useful for covering additional expenses such as infrastructure or operations.

- **Recompression scenarios**:

  - Recompression of existing batch segments may occur if:

    - The batch exceeds the maximum size limits

    - The batch hasn't been properly closed

- **Compression levels**:

  - Dynamic adjustments of compression levels based on backlog size ($B$):

    - **Compression level ($CL$)**:

      - For $B \leq 20$

        - $CL = \min(6, UC)$

      - For $20 < B < 60$

        - $CL = UC$

      - For $B > 60$

        - $CL = \min(4, UC)$

    - **Recompression level ($RL$)**:

      - For $B < 40$:

        - $RL = UC$

      - For $B \geq 40$:

        - $RL = \min(6, UC)$

    - $UC$: User-configured compression level

## Parent chain gas pricing

ArbOS dynamically prices the parent chain gas, adjusting the price to ensure that the amount collected in parent chain gas fees is as close as possible to the costs required over time.

### Parent chain costs

There are two types of parent chain costs: batch posting costs and rewards.

Batch posting costs reflect the actual cost a batch poster pays to post batch data on the parent chain. Whenever a batch posts, the parent chain contract that records the batch sends a special "batch posting report" message to the child chain ArbOS, reporting who paid for the batch and what the parent chain's base fee was at the time. This message gets sent to the chain's <a data-quicklook-from="delayed-inbox">Delayed Inbox</a>, so it will be delivered to the child chain ArbOS after a delay.

When a batch posting report message arrives at the child chain, ArbOS computes the cost of the referenced batch by multiplying the reported base fee by the batch's data cost. (ArbOS retrieves the batch's data from its inbox state and computes the parent chain gas that the batch would have used by counting the number of zero bytes and non-zero bytes in the batch.) The pricer records the resulting cost as funds due to the party who submitted the batch.

The second type of parent chain cost is an optional (per chain) per-unit reward for handling transaction calldata. In general, the reward might go to the <a data-quicklook-from="sequencer">Sequencer</a>, or members of the Data Availability Committee in an AnyTrust chain, or to anyone else who incurs per-calldata-byte costs on behalf of the chain. The reward is a fixed number of `wei` per data unit and gets disbursed to a single address.

The parent chain pricer tracks the funds due to the reward address, based on the number of data units processed so far. This amount is updated whenever a batch posting report arrives at the child chain.

### Parent chain calldata fees

The parent chain calldata fees exist because the Sequencer, or the batch poster, which posts the Sequencer's transaction batches on Ethereum, incurs costs in the parent chain gas to post transactions on Ethereum as calldata. Funds collected in the parent chain's calldata fees are credited to the batch poster to cover its costs.

Every transaction that comes in through the Sequencer will pay a parent chain calldata fee. Transactions that come in through the Delayed Inbox don't incur this fee because they don't contribute to batch posting costs; however, these transactions do pay gas fees to Ethereum when they get added to the Delayed Inbox.

The parent chain pricing algorithm assigns a parent chain calldata fee to each Sequencer transaction. First, it computes the transaction's size, which is an estimate of the number of bytes the transaction will add to the compressed batch it is in; the formula for this calculation includes an estimate of how compressible the transaction is. Second, it multiplies the computed size estimate by the current price per estimated byte to determine the transaction's parent chain calldata `wei`, in `wei`. Finally, it divides this cost by the current child chain basefee to translate the fee into the child chain gas units. The result gets reported as the "poster fee" for the transaction.

The price per estimated byte is determined by a dynamic algorithm that compares the total parent chain calldata fees collected to the total fees paid by batch posters, aiming to bring the two as close to equality as possible. If the batch poster costs are less than the fee receipts, the price will increase; if the batch poster costs exceed the fee receipts, the price will decrease.

### Parent chain fee collection

A transaction is charged for the parent chain gas only if it arrives as part of a sequencer batch, meaning that someone would have paid for the parent chain gas to post the transaction on the parent chain.

The estimated cost of posting a transaction on the parent chain is the product of the transaction's estimated size and the current parent chain gas basefee. To determine the amount of child chain gas corresponding to the parent chain operation, `the estimated cost / current child chain gas basefee`. To learn more about this process, you can read the ["Understanding Arbitrum 2-dimensional fees"](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) article.

The parent chain gas currency determines the estimated size. The calculation is as follows: first, compress the transaction's data using the Brotli-zero algorithm, and then multiply the result's size by 16. (16 is because the parent chain charges 16 gas per byte. The parent chain charges less for bytes that are zero, but that doesn't make sense here.) Brotli-zero is used to reward users for posting transactions that are compressible. Ideally, we would like to reward posting transactions that contribute to the compressibility (using the Brotli compressor) of the entire batch; however, this is a complex notion to define, and in any case, it would be too expensive to compute at the child chain. Brotli-zero is a computationally inexpensive approximation.

Parent chain gas fee funds that get collected from transactions are transferred to a special [`L1PricerFundsPool`](https://github.com/OffchainLabs/nitro/blob/3f4939df1990320310e7f39e8abb32d5c4d8045f/arbos/l1pricing/l1pricing.go#L46) account, so that account's balance represents the amount of funds that have been collected and are available to pay for costs.

The parent chain pricer also records the total number of "data units" (the sum of the estimated sizes, after multiplying by 16) received.

### Retrieving parent chain fee information

Users and developers can access parent chain fee-related data through the following methods:

- Parent chain gas base fee estimate:

  - **Method**: `ArbGasInfo.getL1BaseFeeEstimate()`

  - **Purpose**: Retrieves the current estimated parent–gas base fee for calculating transaction costs.

- Estimating transaction parent chain fees:

  - **Methods**:

    - `NodeInterface.gasEstimateComponents()`

    - `NodeInterface.gasEstimateL1Component()`

  - **Purpose**: Provides an estimate of the parent chain gas a transaction will consume.

- Transaction receipts:

  - **Field**: `gasUsedForL1`

  - **Description**: Indicates the child chain gas used to cover parent chain costs.

#### [`l2PricingState`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/l2pricing/l2pricing.go#L14)

The child chain pricing state tracks child chain resource usage to determine a reasonable child chain gas price. This process considers various factors, including user demand, the state of Geth, and the computational <a data-quicklook-from="speed-limit">speed limit</a>. The primary mechanism for doing so consists of a pair of pools, one larger than the other, that drain as child chain–specific resources are consumed and replenished over time. Parent chain-specific resources, such as parent chain `calldata`, are not accounted for in the pools since they do not directly impact the computational workload of network actors. Instead, the design of the speed limit mechanism regulates execution resources to ensure consistent system performance and synchronization.

While much of this state is accessible through the [`ArbGasInfo`](/build-decentralized-apps/precompiles/02-reference.mdx#arbgasinfo) and [`ArbOwner`](/build-decentralized-apps/precompiles/02-reference.mdx#arbowner) precompiles, most changes are automatic and happen during [block production](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L77) and the [transaction hooks](/how-arbitrum-works/04-state-transition-function/07-hooks.mdx). Each transaction in an incoming message removes the parent chain component of the gas it uses from the pool. Afterward, the message's timestamp [informs the pricing mechanism](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L336) of the time passed as ArbOS [finalizes the block](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L350).

ArbOS's larger gas pool [determines](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/l2pricing/pools.go#L98) the per-block gas limit, setting a dynamic [upper limit](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L146) on the amount of compute gas a child chain block may have. The limit is enforceable using [`GasChargingHook`](/how-arbitrum-works/04-state-transition-function/07-hooks.mdx) for the first transaction to avoid sharp decreases in the parent chain gas price from over-inflating the compute component purchased to above the gas limit. Enforcing this improves the user experience by allowing the first transaction to succeed rather than requiring a resubmission. Because the first transaction reduces the space available in the block, subsequent transactions may not employ this strategy and may fail due to compute-component inflation. This space is acceptable because such transactions are only present in cases where the system is under heavy load. The result is that the user's transaction is dropped without incurring charges, as the state transition fails early. Those trusting the sequencer can rely on the transaction getting automatically resubmitted in such a scenario.

We need a per-block gas limit because arbitrator WAVM execution is much slower than native transaction execution. This limit means there can only be a limited amount of gas, roughly translating to wall-block time, in a child chain block. It also allows ArbOS to limit the size of blocks should demand continue to surge even as the price rises.

ArbOS's per-block gas limit is distinct from Geth's block limit, which ArbOS [sets sufficiently high](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L166) never to run out. This approach is safe since Geth's block limit exists to constrain the work done per block, which ArbOS already does via its per-block gas limit. Though it'll never run out, a block's transactions use the [same Geth gas pool](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L199) to maintain the invariant that the pool decreases monotonically after each transaction. Block headers [use the Geth block limit](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L67) for internal consistency and to ensure gas estimation works. They are distinct from the [`gasLeft`](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L146) variable, which ephemerally exists outside of the global state to keep child chain blocks from exceeding ArbOS's per-block gas limit and to deduct space where the state transition failed or used negligible amounts (https://github.com/OffchainLabs/nitro/blob/faf55a1da8afcabb1f3c406b291e721bfde71a05/arbos/block_processor.go#L328) of compute gas. ArbOS does not need to persist `gasLeft` because its pool induces a revert, and transactions use the Geth block limit during EVM execution.

## Child chain gas pricing

The child chain gas price on a given Arbitrum chain has a set floor, which is queriable via [`ArbGasInfo`](/build-decentralized-apps/precompiles/02-reference.mdx#arbgasinfo)'s `getMinimumGasPrice` method (currently 0.01 `gwei` on Arbitrum One and 0.01 `gwei` on Nova).

## Estimating child chain gas

Calling an Arbitrum Node's `eth_estimateGas` RPC returns a value sufficient to cover the full transaction fee at the given child chain gas price. In other words, the value returned from `eth_estimateGas` multiplied by the child chain gas price indicates the total Ether required for the transaction to succeed. Note that this means that for a given operation, the value returned by `eth_estimateGas` will change over time (as the parent chain calldata price fluctuates). See [2-D fees](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) and [How to estimate gas in Arbitrum](/build-decentralized-apps/02-how-to-estimate-gas.mdx) for more information.

## Child chain gas fees

Child chain gas fees work very similarly to gas on Ethereum. The `amount of gas * by the current basefee` to determine the child chain gas fee charged to the transaction.

The child chain basefee gets set by a version of the "exponential mechanism" widely discussed in the Ethereum community and shown to be equivalent to Ethereum's `EIP-1559` gas pricing mechanism.

The algorithm compares gas usage against the [speed limit](/how-arbitrum-works/04-state-transition-function/05-arbos.mdx#the-speed-limit) parameter, the target amount of gas per second that the chain can handle sustainably over time. (The speed limit on Arbitrum One is 7,000,000 gas per second.) The algorithm tracks a gas backlog. Whenever a transaction consumes gas, it gets added to the backlog. Whenever the clock ticks one second, the speed limit subtracts from the backlog, but the backlog can never go below zero.

Intuitively, if the backlog grows, the algorithm should increase the gas price to slow gas usage, as usage exceeds the sustainable level. If the backlog shrinks, the price should decrease again because usage has been below the sustainable limit, allowing for more gas usage.

More precisely, the basefee is an exponential function of the backlog, `F = exp(-a(B-b))`, where `a` and `b` are suitably chosen constants: `a` controls how rapidly the price escalates with the backlog, and `b` allows a small backlog before the basefee escalation begins.
