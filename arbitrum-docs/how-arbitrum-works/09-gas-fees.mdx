---
title: Gas and Fees
description: 'Learn the fundamentals of how to calculate fees on Arbitrum.'
author: pete-vielhaber
sme: TucksonDev
user_story: As a current or prospective Arbitrum user, I need to learn more about gas/fee calculations on Arbitrum.
content_type: get-started
---

Gas is used by <a data-quicklook-from="arbitrum">Arbitrum</a> to track the cost of execution on a Nitro chain. It works the same as Ethereum gas, in the sense that every EVM instruction costs the same amount of gas that it would on Ethereum.

There are two parties a user pays when submitting a transaction:

- the poster, if reimbursable, for the parent chain resources such as the parent chain calldata needed to post the transaction
- the network fee account for the child chain resources, which include the computation, storage, and other burdens child chain nodes must bear to service the transaction

## Apprortioning costs among transactions

To approximate each transaction's contribution to parent chain costs, Arbitrum employs the following method:

- **Compression estimation**:

  - Each transaction individually compresses using the Brotli compressor at its lowest compression level (fastest setting).

  - This approach reduces computational overhead within the STF.

- **Data unit calculation**:

  - The size of the compressed transaction is multiplied by 16 (since Ethereum charges 16 gas per non-zero byte).

  - This product represents the transaction's estimated footprint in data units.

- **Rationale**:

  - This method approximates the transaction's size after full batch compression.

  - While not exact, it's computationally efficient and suitable for real-time processing.

## Determining cost per data unit

Charging a transaction based on the parent chain base fee is not viable due to:

- **ArbOS limitations**:

  - ArbOS cannot directly measure the parent chain base fee

  - Relying on the Sequencer to report the parent chain base fee isn't secure, as it could manipulate fees for profit

- **Approximation errors**:

  - The estimated data units per transaction don't precisely reflect parent chain costs

  - The total number of data units charged may not be directly proportional to the Sequencer's expenses

### Adaptive pricing algorithm

To align collected fees with actual costs, Arbitrum uses an adaptive algorithm with two primary goals:

1. **Cost alignment**

   - Minimize the long-term difference between collected fees and the Sequencer's parent chain costs

2. **Stability**

   - Avoid sudden fluctuations in the data price, ensuring a stable fee environment

### Pricer components

The pricer module within ArbOS tracks:

- **Amount owed to the Sequencer**:

  - The cumulative parent chain costs incurred by the Sequencer for batch posting

- **Reimbursement fund**:

  - Collects all funds charged to transactions for parent chain fees

  - Acts as a pool to reimburse the Sequencer

- **Data unit count**:

  - The total number of recent data units processed

  - Increases with each transaction's estimated data units

- **Current parent chain data unit price**:

  - The adaptive fee per data unit expressed in `wei`

### Algorithm for price adjustment

When the Sequencer posts a batch to the parent chain inbox:

1. **Batch posting report generation**:

   - The parent chain inbox inserts a "batch posting report" transaction into the chain's <a data-quicklook-from="delayed-inbox">Delayed Inbox</a>

   - After a delay, this report gets processed by ArbOS's pricer module

2. **Processing the batch posting report**:

   - **Compute batch cost**:

     - ArbOS calculates the actual cost of posting the batch by:

       - Retrieving the batch data from the inbox state

       - Counting zero and non-zero bytes to determine parent chain gas usage

     - The cost is added to the amount owed to the Sequencer

   - **Update data units**:

     - Calculate the data units assigned to this update $(U_{\text{upd}})$

       $$
       U_{\text{upd}} = U \times \frac{T_{\text{upd}} - T_{\text{prev}}}{T - T_{\text{prev}}}
       $$

     - $U$: Total recent data units

     - $T$: Current time

     - $T_{\text{upd}}$: Time when the update occurred

     - $T_{\text{prev}}$: Time of the previous update

     - Subtract $U_{\text{upd}}$ from the total $U$

   - **Reimburse the Sequencer**:

     - Pay the Sequencer from the reimbursement fund:

       - The amount paid is the lesser of the amount owed or the fund balance.

     - Deduct the paid amount from both the reimbursement fund and the amount owed

   - **Compute surplus and derivative**:

     - Surplus ($S$):

       $$
       S = \text{Reimbursement Fund Balance} - \text{Amount Owed}
       $$

     - Derivative of surplus ($D$):

       - $D = \frac{S - S_{\text{prev}}}{U_{\text{upd}}}$

       - $S_{\text{prev}}$: Surplus at the previous update

   - **Compute derivative goal($D'$)**:

     - Establish a target derivative to eliminate surplus over time:

       - $D' = -\frac{S}{E}$

       - $E$: Equilibration constant (time horizon for balancing surplus).

   - **Adjust price ($\Delta P)$)**:

     - Calculate the change in the data unit price:

       - $\Delta P = \frac{(D' - D) \times U_{\text{upd}}}{\alpha + U_{\text{upd}}}$

       - $\alpha$: Smoothing parameter to prevent abrupt changes

     - Update the price:

       - $P = \max(0, P_{\text{prev}} + \Delta P)$

   - **Outcome**:

     - The adaptive algorithm adjusts the parent chain-data unit price to align collected fees with actual costs.

     - Ensures that the Sequencer gets fairly reimbursed while avoiding surpluses or deficits.

### Additional Considerations

- **Per-unit rewards**:

  - An optional per-unit reward can be included and payable to a designated address.

  - Useful for covering additional expenses such as infrastructure or operations.

- **Recompression scenarios**:

  - Recompression of existing batch segments may occur if:

    - The batch exceeds the maximum size limits

    - The batch hasn't been properly closed

- **Compression levels**:

  - Dynamic adjustments of compression levels based on backlog size ($B$):

    - **Compression level ($CL$)**:

      - For $B \leq 20$

        - $CL = \min(6, UC)$

      - For $20 < B < 60$

        - $CL = UC$

      - For $B > 60$

        - $CL = \min(4, UC)$

    - **Recompression level ($RL$)**:

      - For $B < 40$:

        - $RL = UC$

      - For $B \geq 40$:

        - $RL = \min(6, UC)$

    - $UC$: User-configured compression level

## Parent chain gas pricing

ArbOS dynamically prices the parent chain gas, with the price adjusting to ensure that the amount collected in the parent chain gas fees is as close as possible to the costs that must be covered, over time.

### Parent chain costs

There are two types of parent chain costs: batch posting costs, and rewards.

Batch posting costs reflect the actual cost a batch poster pays to post batch data on the parent chain. Whenever a batch is posted, the parent chain contract that records the batch will send a special "batch posting report" message to child chain ArbOS, reporting who paid for the batch and what the parent chain basefee was at the time. This message is placed in the chain's <a data-quicklook-from="delayed-inbox">Delayed Inbox</a>, so it will be delivered to child chain ArbOS after some delay.

When a batch posting report message arrives to the child chain, ArbOS computes the cost of the referenced batch by multiplying the reported basefee by the batch's data cost. (ArbOS retrieves the batch's data from its inbox state, and computes the parent chain gas that the batch would have used by counting the number of zero bytes and non-zero bytes in the batch.) The resulting cost is recorded by the pricer as funds due to the party who is reported to have submitted the batch.

The second type of parent chain cost is an optional (per chain) per-unit reward for handling transaction calldata. In general the reward might be paid to the <a data-quicklook-from="sequencer">Sequencer</a>, or to members of the Data Availability Committee in an AnyTrust chain, or to anyone else who incurs per-calldata-byte costs on behalf of the chain. The reward is a fixed number of `wei` per data unit, and is paid to a single address.

The parent chain pricer keeps track of the funds due to the reward address, based on the number of data units handled so far. This amount is updated whenever a batch posting report arrives at the child chain.

### Parent chain calldata fees

The parent chain calldata fees exist because the Sequencer, or the batch poster which posts the Sequencer's transaction batches on Ethereum, incurs costs in the parent chain gas to post transactions on Ethereum as calldata. Funds collected in the parent chain calldata fees are credited to the batch poster to cover its costs.

Every transaction that comes in through the Sequencer will pay a parent chain calldata fee. Transactions that come in through the Delayed Inbox do not pay this fee because they don't add to batch posting costs--but these transactions pay gas fees to Ethereum when they are put into the Delayed Inbox.

The parent chain pricing algorithm assigns a parent chain calldata fee to each Sequencer transaction. First, it computes the transaction's size, which is an estimate of how many bytes the transaction will add to the compressed batch it is in; the formula for this includes an estimate of how compressible the transaction is. Second, it multiplies the computed size estimate by the current price per estimated byte, to determine the transaction's parent chain calldata `wei`, in `wei`. Finally, it divides this cost by the current child chain basefee to translate the fee into the child chain gas units. The result is reported as the "poster fee" for the transaction.

The price per estimated byte is set by a dynamic algorithm that compares the total parent chain calldata fees collected to the total fees actually paid by batch posters, and tries to bring the two as close to equality as possible. If the batch posters' costs have been less than fee receipts, the price will increase, and if batch poster costs have exceeded fee receipts, the price will decrease.

### Parent chain fee collection

A transaction is charged for the parent chain gas if and only if it arrived as part of a sequencer batch. This means that someone would have paid for the parent chain gas to post the transaction on the parent chain chain.

The estimated cost of posting a transaction on the parent chain is the product of the transaction's estimated size, and the current parent chain Gas Basefee. This estimated cost is divided by the current child chain gas basefee to obtain the amount of child chain gas that corresponds to the parent chain operation (more information about this can be found in [this article](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9).

The estimated size is measured in the parent chain gas and is calculated as follows: first, compress the transaction's data using the brotli-zero algorithm, then multiply the size of the result by 16. (16 is because the parent chain charges 16 gas per byte. The parent chain charges less for bytes that are zero, but that doesn't make sense here.) Brotli-zero is used in order to reward users for posting transactions that are compressible. Ideally we would like to reward for posting transactions that contribute to the compressibility (using the brotli compressor) of the entire batch, but that is a difficult notion to define and in any case would be too expensive to compute at the child chain. Brotli-zero is an approximation that is cheap enough to compute.

Parent chain gas fee funds that are collected from transactions are transferred to a special [`L1PricerFundsPool`](https://github.com/OffchainLabs/nitro/blob/3f4939df1990320310e7f39e8abb32d5c4d8045f/arbos/l1pricing/l1pricing.go#L46) account, so that account's balance represents the amount of funds that have been collected and are available to pay for costs.

The parent chain pricer also records the total number of "data units" (the sum of the estimated sizes, after multiplying by 16) that have been received.

### Retrieving parent chain fee information

Users and developers can access parent chain fee-related data through the following methods:

- Parent chain gas base fee estimate:

  - **Method**: `ArbGasInfo.getL1BaseFeeEstimate()`

  - **Purpose**: Retrieves the current estimated parent–gas base fee for calculating transaction costs.

- Estimating transaction parent chain fees:

  - **Methods**:

    - `NodeInterface.gasEstimateComponents()`

    - `NodeInterface.gasEstimateL1Component()`

  - **Purpose**: Provides an estimate of the parent chain gas a transaction will consume.

- Transaction receipts:

  - **Field**: `gasUsedForL1`

  - **Description**: Indicates the child chain gas used to cover parent chain costs.

#### [`l2PricingState`](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/l2pricing/l2pricing.go#L14)

The child chain pricing state tracks child chain resource usage to determine a reasonable child chain gas price. This process considers various factors, including user demand, the state of Geth, and the computational <a data-quicklook-from="speed-limit">speed limit</a>. The primary mechanism for doing so consists of a pair of pools, one larger than the other, that drain as child chain–specific resources are consumed and filled as time passes. Parent chain-specific resources, such as parent chain `calldata`, are not accounted for in the pools since they do not directly impact the computational workload of network actors. Instead, the design of the speed limit mechanism regulates execution resources to ensure consistent system performance and synchronization.

While much of this state is accessible through the [`ArbGasInfo`](/build-decentralized-apps/precompiles/02-reference.mdx#arbgasinfo) and [`ArbOwner`](/build-decentralized-apps/precompiles/02-reference.mdx#arbowner) precompiles, most changes are automatic and happen during [block production](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L77) and the [transaction hooks](/how-arbitrum-works/04-state-transition-function/07-hooks.mdx#hooks). Each of an incoming message's transactions removes the parent chain component of the gas it uses from the pool. Afterward, the message's timestamp [informs the pricing mechanism](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L336) of the time passed as ArbOS [finalizes the block](https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L350).

ArbOS's larger gas pool [determines](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/l2pricing/pools.go#L98) the per-block gas limit, setting a dynamic [upper limit](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L146) on the amount of compute gas a child chain block may have. This limit is always enforced, though it's done in the [`GasChargingHook`](/how-arbitrum-works/04-state-transition-function/07-hooks.mdx#gascharginghook) for the first transaction to avoid sharp decreases in the parent chain gas price from over-inflating the compute component purchased to above the gas limit. Enforicng this improves UX by allowing the first transaction to succeed rather than requiring a resubmission. Because the first transaction lowers the space left in the block, subsequent transactions do not employ this strategy and may fail from such compute-component inflation. This space is acceptable because such transactions are only present in cases where the system is under heavy load. The result is that the user's transaction is dropped without charges since the state transition fails early. Those trusting the Sequencer can rely on the transaction being automatically resubmitted in such a scenario.

We need a per-block gas limit because arbitrator WAVM execution is much slower than native transaction execution. This limit means there can only be so much gas, roughly translating to wall-block time–in a child chain block. It also allows ArbOS to limit the size of blocks should demand continue to surge even as the price rises.

ArbOS's per-block gas limit is distinct from Geth's block limit, which ArbOS [sets sufficiently high](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L166) to never run out. This approach is safe since Geth's block limit exists to constrain the work done per block, which ArbOS already does via its own per-block gas limit. Though it'll never run out, a block's transactions use the [same Geth gas pool](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L199) to maintain the invariant that the pool decreases monotonically after each transaction. Block headers [use the Geth block limit](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L67) for internal consistency and to ensure gas estimation works. There are distinct from the [`gasLeft`](https://github.com/OffchainLabs/nitro/blob/2ba6d1aa45abcc46c28f3d4f560691ce5a396af8/arbos/block_processor.go#L146) variable, which ephemerally exists outside of the global state to keep child chain blocks from exceeding ArbOS's per-block gas limit and to deduct space where the state transition failed or [used negligible amounts](https://github.com/OffchainLabs/nitro/blob/faf55a1da8afcabb1f3c406b291e721bfde71a05/arbos/block_processor.go#L328) of compute gas. ArbOS does not need to persist `gasLeft` because its pool induces a revert, and transactions use the Geth block limit during EVM execution.

## Child chain gas pricing

The child chain gas price on a given Arbitrum chain has a set floor, which is queriable via [`ArbGasInfo`](/build-decentralized-apps/precompiles/02-reference.mdx#arbgasinfo)'s `getMinimumGasPrice` method (currently 0.01 `gwei` on Arbitrum One and 0.01 `gwei` on Nova).

## Estimating child chain gas

Calling an Arbitrum Node's `eth_estimateGas` RPC gives a value sufficient to cover the full transaction fee at the given child chain gas price, i.e., the value returned from `eth_estimateGas` multiplied by the child chain gas price tells you how much total Ether is required for the transaction to succeed. Note that this means that for a given operation the value returned by `eth_estimateGas` will change over time (as the parent chain calldata price fluctuates). See [2-D fees](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) and [How to estimate gas in Arbitrum](/build-decentralized-apps/02-how-to-estimate-gas.mdx) for more information.

## Child chain gas fees

Child chain gas fees work very similarly to gas on Ethereum. The amount of gas is multiplied by the current basefee to get the child chain gas fee charged to the transaction.

The child chain basefee is set by a version of the "exponential mechanism" widely discussed in the Ethereum community and shown to be equivalent to Ethereum's `EIP-1559` gas pricing mechanism.

The algorithm compares gas usage against the [speed limit](/how-arbitrum-works/04-state-transition-function/05-arbos.mdx#the-speed-limit) parameter, the target amount of gas per second that the chain can handle sustainably over time. (The speed limit on Arbitrum One is 7,000,000 gas per second.) The algorithm tracks a gas backlog. Whenever a transaction consumes gas, it gets added to the backlog. Whenever the clock ticks one second, the speed limit subtracts from the backlog, but the backlog can never go below zero.

Intuitively, if the backlog grows, the algorithm should increase the gas price to slow gas usage because usage is above the sustainable level. If the backlog shrinks, the price should decrease again because usage has been below the sustainable limit so more gas usage can be welcomed.

More precisely, the basefee is an exponential function of the backlog, `F = exp(-a(B-b))`, where `a` and `b` are suitably chosen constants: `a` controls how rapidly the price escalates with the backlog, and `b` allows a small backlog before the basefee escalation begins.
