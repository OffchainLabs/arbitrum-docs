# FAQs

_This page is targeted toward devs and researchers who already have some familiarity with Arbitrum; if you're new here, you may want to start with our [gentle introduction](./intro/intro.mdx) (Also, welcome!)_

## Gas {#cat--gas}

### How does gas work on Arbitrum chains? {#q-gas}

Fees on Arbitrum chains are collected on L2 in the chains' native currency (ETH on both Arbitrum One and Nova).

A transaction fee is comprised of both an L1 and an L2 component:

The L1 component is meant to compensate the Sequencer for the cost of posting transactions on L1 (but no more). (See [L1 Pricing](./arbos/l1-pricing.mdx).)

The L2 component covers the cost of operating the L2 chain; it uses Geth for gas calculation and thus behaves nearly identically to L1 Ethereum (See [Gas](./arbos/gas.mdx)).

L2 Gas price adjusts responsively to chain congestion, ala EIP 1559.

### Why does it look like two identical transactions consume a different amount of gas? {#q-gas-changes}

Calling an Arbitrum node's `eth_estimateGas` RPC returns a value sufficient to cover both the L1 and L2 components of the fee for the current gas price; this is the value that, e.g., will appear in users' wallets in the "gas limit" field.

Thus, if the L1 calldata price changes over time, it will appear (in e.g., a wallet) that a transaction's gas limit is changing. In fact, the L2 gas limit isn't changing, merely the total gas required to cover the transaction's L1 + L2 fees.

See [2-D fees](https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9) for more.

### How is the L1 portion of an Arbitrum transaction’s gas fee computed? {#q-gas-l1}

The L1 fee that a transaction is required to pay is determined by compressing its data with brotli and multiplying the size of the result (in bytes) by ArbOS’s current call data price; the later value can be queried via the `getPricesInWei` method of the `ArbGasInfo` precompile.

### Does Arbitrum have a mempool? {#q-mempool}

The Arbitrum Sequencer orders transactions on a first come, first served basis; the Sequencer inserts transactions into a queue based on the order they are received and executes them accordingly. This queue thus exists in lieu of a mempool. The Sequencer’s queue has no space limit; transactions on the queue will eventually timeout and be discarded if not executed in time.

### Do I need to pay a Priority fee for my Arbitrum transactions? {#q-priority}

Since transactions are processed in the order that the Sequencer receives them, no priority fee is necessary for Arbitrum transactions; if a transaction does include a priority fee, it will be refunded to the transaction’s origin address at the end of execution.

## Running Nodes {#cat-nodes}

### How do I run a nitro node locally for development? {#q-node-local}

See instructions [here](./node-running/local-dev-node.mdx).

We recommend running nitro nodes via docker; to compile directly / run without docker, you can follow the steps in this file then run the executable directly.

### Can I run an Arbitrum Node in p2p mode? {#q-node-p2p}

Arbitrum doesn’t have a consensus mechanism, so “p2p mode” doesn’t apply. For nodes to sync to the latest chain state, they connect to an L1 node to sync the chain’s history that’s been posted in calldata and connect to the Sequencer feed for the transactions that have yet to be posted in batches. In no case do nodes need to peer up and sync with each other.

## Cross Chain Messaging

### How can I check the status of my cross chain message? {#q-xchain-status}

Visit https://retryable-dashboard.arbitrum.io/ to check the status of a cross chain message (and execute it, if applicable). You’ll need the transaction hash of the initiating transaction (i.e., the L1 transaction hash for an L1-to-L2 message, and the L2 transaction hash for an L2-to-L1 message).

### When I initiate withdrawal from Arbitrum, how long does it take before I receive my funds? {#q-withdrawal-time}

It will typically be _roughly_ one week.

There's some variability in the exact wall-clock time of the dispute window, plus there's some expected additional "padding" time on both ends (no more than about an hour, typically).

The variability of the dispute window comes from the slight variance of block times. Arbitrum One's dispute window is 45818 blocks; this converts to ~1 week assuming 13.2 seconds per block, which was the average block time when Ethereum used Proof of Work (with the switch to Proof of Stake, average block times are about 12 seconds)

The "padding on both ends" involves three events that have to occur between a client receiving their transaction receipt from a Sequencer and their L2-to-L1 message being executable. After getting their receipt,

1. The Sequencer posts their transaction in a batch (usually within a few minutes, though the Sequencer will wait a bit longer if the L1 is congested). Then,
2. A validator includes their transaction in an RBlock (usually within the hour). Then, after the ~week long dispute window passes, the RBlock is confirmable, and
3. Somebody (anybody) confirms the RBlock on L1. (usually within ~15 minutes)

Additionally, in the rare and unlikely event of a dispute, this delay period will be extended for the dispute to resolve.

### What is a retryable ticket’s “submission fee”? How can I calculate it? What happens if I the fee I provide is insufficient? {#q-submission-fee}

A [retryable’s](./arbos/l1-to-l2-messaging.mdx) submission fee is a special fee a user must pay to create a retryable ticket. The fee is directly proportional to the size of the L1 calldata the retryable ticket uses. The fee can be queried using the `Inbox.calculateRetryableSubmissionFee` method. If insufficient fee is provided, the transactions will revert on L1, and the ticket won't get created.

### Which method in the Inbox contract should I use to submit a retryable ticket? {#q-retry-methods}

The method you should (almost certainly) use is `Inbox.createRetryableTicket`. There is an alternative method, `Inbox.unsafeCreateRetryableTicket`, which, as the name suggests, should only be used by those who fully understand its implications.

There are two differences between `createRetryableTicket` and `unsafeCreateRetryableTicket`:

1. `createRetryableTicket` will check that provided callvalue is sufficient to cover the costs of creating and executing the retryable ticket (at the specified parameters) and otherwise revert directly at L1. `unsafeCreateRetryableTicket`, in contrast, will allow a retryable ticket to be created that is guaranteed to revert on L2.

2. `createRetryableTicket` will check if either the provided `excessFeeRefundAddress` or the `callValueRefundAddress` are contracts on L1; if they are, to prevent the situation where refunds are _guaranteed_ to be irrecoverable on L2, it will convert them to their [address alias](./arbos/l1-to-l2-messaging.mdx#address-aliasing), providing a _potential_ path for fund recovery. `unsafeCreateRetryableTicket` will allow the creation of a retryable ticket with refund addresses that are L1 contracts; since no L1 contract can alias to an address that is also itself an L1 contract, refunds to these addresses on L2 will be irrecoverable.

(Astute observers may note a third ticket creation method, `createRetryableTicketNoRefundAliasRewrite`; this is included only for backwards compatibility, but should be considered deprecated in favor of `unsafeCreateRetryableTicket`)

## Protocol

### What's the difference between Arbitrum Rollup and Arbitrum AnyTrust? {#q-rollup-vs-anytrust}

Arbitrum Rollup is an Optimistic Rollup protocol; it is trustless and permissionless. Part of how these properties are achieved is by requiring all chain data to be posted on layer 1. This means the availability of this data follows directly from the security properties of Ethereum itself, and, in turn, that any party can participate in validating the chain and ensuring its safely.

By contrast, Arbitrum AnyTrust introduces a trust assumption in exchange for lower fees; data availability is managed by a Data Availability Committee (DAC), a fixed, permissioned set of entities. We introduced some threshold, K, with the assumption that at least K members of the committee are honest. For simplicity, we'll hereby assume a committee of size 20 and a K value of 2:

If 19 out of the 20 committee members *and* the Sequencer are malicious and colluding together, they can break the chain's safety (and, e.g., steal users' funds); this is the new trust assumption.

If anywhere between 2 and 18 of the committee members are well behaved, the AnyTrust chain operates in "Rollup mode"; i.e., data gets posted on L1.

In what should be the common and happy case, however, in which at least 19 of the 20 committee members are well behaved, the system operates without the posting the L2 chain's data on L1, and thus, users pay significantly lower fees. This is the core upside of AnyTrust chains over rollups.

Variants of the AnyTrust model in which the new trust assumption is minimized are under consideration; stay tuned.

For more, see [Inside AnyTrust](./inside-anytrust.mdx).

### Are “Sequencers” the same thing as “Validators”? Can a centralized Sequencer do bad things like steal all my money? {#q-seq-vs-val}

No and no!

An Arbitrum Chain's Sequencer(s) and Validators and completely distinct entities, with their own distinct roles.

The [Sequencer](./sequencer.mdx) is the entity granted specific privileges over ordering transactions; once the Sequencer commits to an ordering (by posting a batch on Ethereum), it has no say over what happens next (i.e., execution). A malicious/faulty Sequencer can do things like reorder transactions or *temporarily* delay a transaction's inclusion — things which could be, to be sure, annoying and bad — but can do nothing to compromise the chain's safety.

The *Validators* are the ones responsible for the safety of the chain; i.e., making staked claims about the chain state, disputing each other, etc.

Currently, on Arbitrum One, the Sequencer is a centralized entity maintained by Offchain Labs. Eventually, the single Sequencer will be replaced by a distributed committee of Sequencers who come to consensus on transaction ordering. This upgrade be an improvement; we don't want you to have to trust us not to reorder your transactions. However, it also isn't *strictly* necessary for Arbitrum One to achieve its most fundamental properties.

In other words: **_An Arbitrum Rollup chain with a centralized Sequencer could theoretically still be trustless!_**

Which is to say — the more important thing than decentralizing the Sequencer i.e., the thing you ought to care more about — is decentralizing the *Validators*.

Arbitrum One's Validator set is currently whitelisted; overtime, the whitelist will grow and then be removed entirely. For more info see ["Mainnet Beta"](/mainnet-beta.mdx).

### If there is a dispute, can my L2 transaction get reorged / throw out / "yeeted"? {#q-dispute-reorg}

Nope; once an Arbitrum transaction is included on L1, there is no way it can be reorged (unless the L1 itself reorgs, of course). A "dispute" involves Validators disagreeing over execution, i.e., the outputted state of a chain. The inputs, however, can't be disputed; they are determined by the Inbox on L1. (See [Transaction Lifecycle](https://developer.arbitrum.io/tx-lifecycle))

### ...okay but if there's a dispute, will my transaction get delayed? {#q-dispute-delay}

The only thing that a dispute can add delay to is the confirmation of L2-to-L1 messages. All other transactions continue to be processed, even while a dispute is still undergoing. (Additionally: in practice, most L2-to-L1 messages represent withdrawals of fungible assets; these can be trustlessly completed *even during a dispute* via trustless fast "liquidity exit" applications. See [L2-to-L1 Messages](./arbos/l2-to-l1-messaging)).

### Why was “one week” chosen for Arbitrum One’s dispute window? {#q-why-one-week}

Generally, some dispute period is necessary for Arbitrum Rollup so that validators have time to dispute an invalid assertion.

A week is expected to be more than enough time for validators to carry out an interactive dispute, assuming they don’t encounter difficulty in getting their transactions included on L1. One week was chosen following the general consensus among the Ethereum research community — as well as other layer 2 projects — to provide enough time for the community to socially coordinate in the case of a coordinated Ethereum-staker censorship attack.

## Dev Tooling {#cat-dev-tooling}

### Do I need to download any special npm libraries in order to use web3.js or ethers-js on Arbitrum? {#q-ethers-web3}

Nope; web3.js and ethers.js will work out of the box just like they do on L1 Ethereum.

Once upon a time, Arbitrum developers were required to download supplemental packages with names like “arb-provider-ethers” and “arb-ethers-web3-bridge”, but these packages are deprecated and no longer required! Any guide that directs devs to use them should be considered out-dated.

### Why do I get “custom tx type” errors when I use hardhat? {#q-hardhat}

In Arbitrum, we uses a number of non-standard [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) typed transactions. See [here](./arbos/geth.mdx#transaction-types) for the full list and the rationale.

[Hardhat v2.12.2](https://www.notion.so/Why-do-I-get-custom-tx-type-errors-when-I-use-hardhat-5a0827c7250b449089e2a69a2f8daa2d) added supports for forking networks like Arbitrum with custom transaction types, so if you’re using hardhat, upgrade to 2.12.2!

## Misc {#cat-misc}

### How do block.timestamp and block.number work on Arbitrum? {#q-blocknum}

Solidity calls to `block.number` and `block.timestamp` on Arbitrum will return the block number/ timestamp of the under lying L1 on a slight delay; ie., updated every few minutes. Note that L2 block numbers (i.e., as seen in block explorers / returned by RPCs) are different, and are typically updated roughly every second.

For more info, see [block numbers and time](./time.mdx).

### What’s the state of Arbitrum One’s decentralization? {#q-dentralization}

Arbitrum One runs on a [full, feature complete implementation](https://github.com/OffchainLabs/nitro) of the Arbitrum Rollup protocol; given that this is still fairly new technology, however, we currently maintain administrative "training wheels." The centralized components of the system will be progressively phased out over time.

For status updates, see ["Mainnet Beta"](./mainnet-beta.mdx), or check out the work of our friends at [L2BEAT](https://l2beat.com/scaling/risk/).
