import { AddressAliasHelper } from '@site/src/components/AddressAliasHelper'
import { MermaidWithHtml, Nodes, Node, Connection, NodeDescriptions, NodeDescription } from '/src/components/MermaidWithHtml/MermaidWithHtml';


# L1 To L2 Messaging

## Retryable Tickets

Retryable tickets are Arbitrum's canonical method for creating L1 to L2 messages, i.e., L1 transactions that initiate a message to be executed on L2. A retryable can be submitted for a fixed cost (dependent only on its calldata size) paid at L1; its _submission_ on L1 is separable / asynchronous with its _execution_ on L2. Retryables provide atomicity between the cross chain operations; if the L1 transaction to request submission succeeds (i.e. does not revert) then the execution of the Retryable on L2 has a strong guarantee to ultimately succeed as well.

## Retryable Tickets Lifecycle

Here we walk through the different stages of the lifecycle of a retryable ticket; (1) submission, (2) auto-redemption, and (3) manual redemption.


<MermaidWithHtml>
  <Nodes title="Ticket Submission">
    <Node id="1">üßç</Node>
    <Node id="2">Initiating an L1-L2 message</Node>
    <Node id="3">Does the user's deposit make the ticket creation succeed?</Node>
    <Node id="4">Ticket creation fails</Node>
    <Node id="5">Ticket is created</Node>
    <Connection from="1" to="2"/>
    <Connection from="2" to="3"/>
    <Connection from="3" to="4" label="no"/>
    <Connection from="3" to="5" label="yes"/>
  </Nodes>
  <NodeDescriptions>
    <NodeDescription for='1'><code>üßç</code> The user who initiates an L1-L2 message</NodeDescription>
    <NodeDescription for='2'><code>Initiating an L1-L2 message</code> A call to `inbox.createRetryable` function that puts the message in the L2 inbox that can be re-executed for some fixed amount of time if it reverts</NodeDescription>
    <NodeDescription for='3'><code>Check user's deposit</code> Logic that checks if the user have enough funds to create a ticket. This is done by checking if the `msg.value` provided by the user is greater than or equal to <code>maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas</code></NodeDescription>
    <NodeDescription for='4'><code>Ticket creation fails</code> Ticket creation fails and no funds are deducted from the user</NodeDescription>
    <NodeDescription for='5'><code>Ticket is created</code> A  ticket is created and added to the retryable buffer on L2.
                          Funds (<code>l2CallValue + submissionCost</code>) are deducted to cover the callvalue from the user and 
                          placed into escrow (on L2) for later use in redeeming the ticket</NodeDescription>
  </NodeDescriptions>
</MermaidWithHtml>

Once the ticket is successfully cretaed, the two following conditions are checked: (1) if the user's L2 balance is greater than (or equal to) `l2Basefee * gasLimit` **and** (2) if the `maxFeePerGas` (provided by the user in the ticket submission process) is greater than (or equal to) the `l2Basefee`. If these conditions are both met, the ticket will be scheduled for the auto-redeem (see Automatic Redemption of the Ticket). Otherwise it'll follow th steps in Manual Redemption of the Ticket diagram.


<MermaidWithHtml>
  <Nodes title="Automatic Redemption of the Ticket">
    <Node id="1">Does the auto-redeem succeed?</Node>
    <Node id="2">Ticket is executed</Node>
    <Node id="3">Ticket is deleted</Node>
    <Node id="4">excessFeeRefundAddress gets refunded</Node>
    <Connection from="1" to="2" label="yes"/>
    <Connection from="2" to="3"/>
    <Connection from="1" to="4" label="no"/>
  </Nodes>
  <NodeDescriptions>
    <NodeDescription for='1'><code>Does the auto-redeem succeed?</code> Logic that determines if the user's L2 Balance is greater than (or equal to) <code>l2Basefee * gasLimit</code> && <code>maxFeePerGas</code> is greater than (or equal to) the <code>l2Basefee</code></NodeDescription>
    <NodeDescription for='2'><code>Ticket is executed</code> Ticket is executed, the actual  <code>submissionFee</code> is refunded to the  <code>excessFeeRefundAddress</code> since the ticket was not kept in the buffer on L2</NodeDescription>
    <NodeDescription for='3'><code>Ticket is deleted</code> Ticket gets deleted from the L2 retryable buffer</NodeDescription>
    <NodeDescription for='4'><code>excessFeeRefundAddress gets refunded</code> <code>excessFeeRefundAddress</code> gets refunded with <code>(maxGas - gasUsed) * gasPrice</code>. Note that this amount is capped by <code>gasUsed * baseFee</code> in the auto-reddem</NodeDescription>
  </NodeDescriptions>
</MermaidWithHtml>


<MermaidWithHtml>
  <Nodes title="Manual Redemption of the Ticket">
    <Node id="1">Is the ticket manually cancelled or not redeemed within 7 days?</Node>
    <Node id="2">excessFeeRefundAddress gets refunded</Node>
    <Node id="3">Ticket is deleted</Node>
    <Node id="4">Is the ticket manually redeemed?</Node>
    <Connection from="1" to="2" label="yes"/>
    <Connection from="2" to="3"/>
    <Connection from="1" to="4" label="no"/>
    <Connection from="4" to="3" label="yes"/> 
    <Connection from="4" to="1" label="no"/> 
  </Nodes>
  <NodeDescriptions>
    <NodeDescription for='1'><code>Is the ticket manually cancelled or not redeemed within 7 days?</code> Logic that determines if the ticket is manually cancelled or not redeemed within 7 days (i.e., is expired)</NodeDescription>
    <NodeDescription for='2'><code>excessFeeRefundAddress gets refunded</code> excessFeeRefundAddress is refunded with the <code>l2CallValue</code></NodeDescription>
    <NodeDescription for='3'><code>Ticket is deleted</code> Ticket gets deleted from the L2 retryable buffer</NodeDescription>
    <NodeDescription for='4'><code>Is the ticket manually redeemed</code> Logic that determines if the ticket is manually redeemed</NodeDescription>
  </NodeDescriptions>
</MermaidWithHtml>


    
1. Creating a retryable ticket is initiated with a transaction call to the `createRetryableTicket` function of the `inbox` contract. This function has a set of parameters which lead to a succesfull creation (and redemption) of the ticket if set carefully:

    - `address to`: The destination L2 contract address
    - `uint256 l2CallValue`: The callvalue for retryable L2 message
    - `uint256 maxSubmissionCost`: The maximum amount of gas to be paid for submitting the ticket. This amount is deducted from sender's L2 balance and is directly proportional to the size of the retryable‚Äôs data  
    - `address excessFeeRefundAddress`: The L2 address to which the excess fee is credited (gasLimit * maxFeePerGas - ticket execution cost)
    - `address callValueRefundAddress`: The L2 address to which the l2Callvalue is credited if the ticket times out or gets cancelled
    - `uint256 gasLimit`: Maximum amount of  gas deducted from sender's L2 balance to cover L2 execution of the ticket
    - `uint256 maxFeePerGas`: The Price bid for L2 execution of the ticket
    - `bytes calldata data`: ABI encoded data of L2 message

2. As shown in the diagram above, the sender's deposit must be enough to make the submission succeed (i.e, cover the L1 submission and L2 execution of the ticket).
3. If provided correctly, a new ticket with a unique `TicketID` is created and added to retryable buffer. Also, funds (`submissionCost` + `l2CallValue`) are deducted from the sender and placed into the escrow for later use in redeeming the ticket.
4. Ticket creation causes the [`ArbRetryableTx`](./precompiles#ArbRetryableTx) precompile to emit a `TicketCreated` event containing the `TicketID`.
5. It is very important to note that the submission of a ticket on L1 is separable / asynchronous from its execution on L2, i.e., a successful L1 ticket creation does not guarantee a successful redemption. Assuming the sender has provided enough gas that can cover the L2 execution/redemption of the ticket on step 1,  ticket's submission is followed by an attempt to execute it on L2 (i.e., an **auto-redeem** using the supplied gas, as if the [`redeem`](./precompiles#ArbRetryableTx) method of the ArbRetryableTx precompile had been called). Depending on how much gas the sender has provided in step 1, ticket's redemption can either (1) immediately succeed or (2) fail. We explain both situations here:

- If the ticket is sucessfully auto-redeemed, it will execute with the sender, destination, callvalue, and calldata of the original submission. The submission fee is refunded to the user on L2 (`excessFeeRefundAddress`). Note that to ensure successful auto-redeem of the ticket, one could use the Arbitrum SDK which provides a [convenience function](https://github.com/OffchainLabs/arbitrum-sdk/blob/4cedb1fcf1c7302a4c3d0f8e75fb33d82bc8338d/src/lib/message/L1ToL2MessageGasEstimator.ts#L215) that returns the desired gas parameters when sending L2-L1 messages.

- If a redeem is not done at submission or the submission's initial redeem fails (for example, because the L2 gas price has increased unexpectedly), the submission fee is collected on L2 to cover the resources required to temporarily keep the ticket in memory for a fixed period (currently one week).
At this point, _anyone_ can attempt to redeem the ticket again by calling `ArbRetryableTx`'s redeem precompile method, which donates the call's gas to the next attempt. 
ArbOS will [enqueue the redeem][enqueue_link], which is its own special `ArbitrumRetryTx` type, to its list of redeems that ArbOS [guarantees to exhaust][exhaust_link] before moving on to the next non-redeem transaction in the block its forming. In this manner redeems are scheduled to happen as soon as possible, and will always be in the same block as the tx that scheduled it. 
Note that the redeem attempt's gas comes from the call to redeem, so there's no chance the block's gas limit is reached before execution.
If the fixed period (one week) elapses without a successful redeem, the ticket **expires** and will be [automatically **discarded**][discard_link], unless some party has paid a fee to [**renew**][renew_link] the ticket for another full period. A ticket can live indefinitely as long as it is renewed each time before it expires.

[enqueue_link]: https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L245
[exhaust_link]: https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L135
[discard_link]: https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/retryables/retryable.go#L262
[renew_link]: https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/retryables/retryable.go#L207



:::caution Avoid Losing Funds!

If a ticket expires after 7 days without being redeemed or re-scheduled to a future date, any value it carries will get lost without possibility of recovering them.

:::

On success, the `To` address keeps the escrowed callvalue, and any unused gas is returned to ArbOS's gas pools. On failure, the callvalue is returned to the escrow for the next redeemer. In either case, the network fee was paid during the scheduling tx, so no fees are charged and no refunds are made.


Note that during redemption of a ticket, attempts to cancel the same ticket, or to schedule another redeem of the same ticket, will revert. In this manner retryable tickets are not self-modifying.


If a ticket with a callvalue is eventually discarded, having never successfully run, the escrowed callvalue will be paid out to a `callValueRefundAddress` account that was specified in the initial submission (step 1).

:::note Important Notes:

If a redeem is not done at submission or the submission's initial redeem fails, anyone can attempt to redeem the retryable again by calling [`ArbRetryableTx`](precompiles#ArbRetryableTx)'s [`redeem`](./precompiles#ArbRetryableTx) precompile method, which donates the call's gas to the next attempt. ArbOS will [enqueue the redeem][enqueue_link], which is its own special `ArbitrumRetryTx` type, to its list of redeems that ArbOS [guarantees to exhaust][exhaust_link] before moving on to the next non-redeem transaction in the block its forming. In this manner redeems are scheduled to happen as soon as possible, and will always be in the same block as the transaction that scheduled it. Note that the redeem attempt's gas comes from the call to [`redeem`](./precompiles#ArbRetryableTx), so there's no chance the block's gas limit is reached before execution.

- One can redeem live tickets using the [Arbitrum Retryables Transaction Panel][retryable_dashboard_link]
- The calldata of a ticket is saved on L2 until it is redeemed or expired 
- Redeeming cost of a ticket will not increase over time, it only depends on the size of the calldata being kept on L2
- The reason a ticket expires after one week is so it frees up the space it is no longer using after that period

:::

[retryable_dashboard_link]: https://retryable-tx-panel-nitro.arbitrum.io


### Receipts

In the lifecycle of a retryable ticket, two types of L2 transaction receipts will be emitted:

- **Ticket Creation Receipt**: This receipt indicates that a ticket was successfully created; any successful L1 call to the `Inbox`'s `createRetryableTicket` method is guaranteed to create a ticket. The ticket creation receipt includes a `TicketCreated` event (from [`ArbRetryableTx`](./precompiles#ArbRetryableTx)), which includes a `ticketId` field. This `ticketId` is computable via RLP encoding and hashing the transaction; see [calculateSubmitRetryableId](https://github.com/OffchainLabs/arbitrum-sdk/blob/6cc143a3bb019dc4c39c8bcc4aeac9f1a48acb01/src/lib/message/L1ToL2Message.ts#L109).
- **Redeem Attempt**: A redeem attempt receipt represents the result of an attempted L2 execution of a ticket. It includes a `RedeemScheduled` event from [`ArbRetryableTx`](./precompiles#ArbRetryableTx), with a `ticketId` field. At most, one successful redeem attempt can ever exist for a given ticket; if, e.g., the auto-redeem upon initial creation succeeds, only the receipt from the auto-redeem will ever get emitted for that ticket. If the auto-redeem fails (or was never attempted ‚Äî i.e., the provided L2 gas limit \* L2 gas price = 0), each initial attempt will emit a redeem attempt receipt until one succeeds.


### Alternative "unsafe" Retryable Ticket Creation

The `Inbox.createRetryableTicket` convenience method includes sanity checks to help minimize the risk of user error: the method will ensure that enough funds are provided directly from L1 to cover the current cost of ticket creation / execution. It also will convert the provided `beneficiary` or `excessFeeRefundAddress` to its address alias (see below) if either is a contract, providing a path for the L1 contract to recover funds. A power-user may bypass these sanity-check measures via the `Inbox`'s `unsafeCreateRetryableTicket` method; as the method's name desperately attempts to warn you, it should only be accessed by a user who truly knows what they're doing.

## Eth deposits

A special message type exists for simple Eth deposits; i.e., sending Eth from L1 to L2. Eth can be deposited via a call to the `Inbox`'s `depositEth` method. If the L1 caller is EOA, the Eth will be deposited to the same EOA address on L2; the L1 caller is a contract, the funds will deposited to the contract's aliased address (see below).

Note that depositing Eth via `depositEth` into a contract on L2 will _not_ trigger the contract's fallback function.

In principle, retryable tickets can alternatively be used to deposit Ether; this could be preferable to the special eth-deposit message type if, e.g., more flexibility for the destination address is needed, or if one wants to trigger the fallback function on the L2 side.

## Transacting via the Delayed Inbox

While Retryables and Eth deposits _must_ be submitted through the delayed inbox, in principle, _any_ message can be included this way; this is a necessary recourse to ensure the Arbitrum chain preserves censorship resistance even if the Sequencer misbehaves (see [The Sequencer and Censorship Resistance](../sequencer.mdx)). However, under ordinary/happy circumstances, the expectation/recommendation is that clients use the delayed inbox only for Retryables and Eth deposits, and transact via the Sequencer for all other messages.

## Address Aliasing

All messages submitted via the Delayed Inbox get their sender's addressed "aliased": when these unsigned messages are executed on L2, the sender's address ‚Äîi.e., that which is returned by `msg.sender` ‚Äî will _not_ simply be the L1 address that sent the message; rather it will be the address's "L2 Alias." An address's L2 alias is its value increased by the hex value `0x1111000000000000000000000000000000001111`:

```sol
L2_Alias = L1_Contract_Address + 0x1111000000000000000000000000000000001111
```

:::tip Try it out

<AddressAliasHelper />
:::
<br />
The Arbitrum protocol's usage of L2 Aliases for L1-to-L2 messages prevents cross-chain
exploits that would otherwise be possible if we simply reused the same L1 addresses
as the L2 sender; i.e., tricking an L2 contract that expects a call from a given
contract address by sending retryable ticket from the expected contract address on
L1.

If for some reason you need to compute the L1 address from an L2 alias on chain, you can use our `AddressAliasHelper` library:

```sol
modifier onlyFromMyL1Contract() override {
    require(AddressAliasHelper.undoL1ToL2Alias(msg.sender) == myL1ContractAddress, "ONLY_COUNTERPART_CONTRACT");
    _;
}

