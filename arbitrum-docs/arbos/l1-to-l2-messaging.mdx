---
title: "L1-to-L2 messaging on Arbitrum: A conceptual overview"
sidebar_label: "L1-to-L2 messaging"
description: "Learn how Arbitrum's Layer 2 (L2) chains communicate with Ethereum's Layer 1 (L1) chain using retryable tickets."
author: mahsamoosavi
reader_audience: new developers who want to build Arbitrum dApps
content_type: concept
---

import { AddressAliasHelper } from '@site/src/components/AddressAliasHelper'
import { MermaidWithHtml, Nodes, Node, Connection, NodeDescriptions, NodeDescription } from '/src/components/MermaidWithHtml/MermaidWithHtml';


<a data-quicklook-from='arbitrum-one'>Arbitrum One</a> and <a data-quicklook-from='arbitrum-nova'>Arbitrum Nova</a> are Layer 2 (L2) chains that continuously exchange information with Ethereum's Layer 1 (L1) chain. This concept doc explains when and how information is sent from Ethereum's L1 chain to Arbitrum's L2 chains.

<br /> <br />

Cross-layer messaging is a complex topic, so this is a lengthy concept doc that progressively discloses technical complexity. Here's what we'll cover:

1. **Why this information is important**.
2. **The conceptual primitives** that work together to enable L1-to-L2 messaging on Arbitrum.
3. **An example smart contract** that exposes two functions.
4. **Properties across deployment scenarios** in terms of our conceptual primitives and example smart contract.
5. **Tying it all together** through an elaboration upon each of the conceptual primitives and how they relate to one another in the context of cross-layer messaging.


:::caution Editor note

 - We can link to the individual sections from these keys

:::

Although this doc doesn't assume prior knowledge, it does assume that you're comfortable exploring the supporting documentation linked throughout, as needed. Let's dive in!




## 1: Why this information is important

Cross-layer communication is a core feature of Arbitrum's L2 chains. From the perspective of decentralized application (dApp) development, it enables two key capabilities:

 1. **L1-to-L2 messaging**: L1 contracts can send messages to L2 contracts, which can trigger the execution of L2-hosted smart contracts.
 2. **L2-to-L1 messaging**: L2 contracts can send messages to L1 contracts, which can trigger the execution of L1-hosted smart contracts.

Without cross-layer messaging, it would be impossible to build dApps that interact with both layers, which would severely limit the value and reach of your dApps.

:::caution Editor note

 - This could be improved through more concrete / compelling examples

:::


## 2: The conceptual primitives

Let's start with some definitions - we'll connect the dots as we go:

 1. **Layers**: We'll focus on the first two: L1 (Ethereum's chains) and L2 (Arbitrum's chains). Both layers host multiple chains; each chain is supported by its own decentralized network of nodes.
 2. **Nodes**: Computers running p2p client software that implements a particular chain's protocol. The protocol tells the nodes how to execute transactions, manage state, and exchange information. 
 3. **State**: A distributed record of Ethereum's "world state" - the canonical, trustworthy representation of transaction history, account balances, token ownership, and other contract data.
 4. **Smart contracts**: Programs that can be deployed to a chain and whose code is hosted and executed by nodes on that chain.
 5. **Contract execution**: The process of executing a smart contract's code and updating the state of the layer(s) on which the contract is deployed.
 6. **Messages**: Pieces of information that are sent from one contract to another, and/or one layer to another.
 7. **Retryable tickets**: A type of message sent from L1 chains to L2 chains in order to trigger the execution of an L2-hosted smart contract. Think of these as special-purpose DTOs (data transfer objects) that encapsulate the information needed to execute a smart contract: the contract's address, the function to call, the function's arguments, etc.
 8. **Outbox contracts**: Smart contracts that are deployed to L1 chains and are responsible for transmitting retryable tickets to L2's inbox contracts. The Arbitrum DAO owns these.
 9.  **Inbox contracts**: Smart contracts that are deployed to L2 chains and are responsible for receiving retryable tickets from L1's outbox contracts. The Arbitrum DAO owns these.
 10. **Gateway contracts**: Smart contracts that are deployed to both L1 and L2 and are responsible for managing the flow of information between the two layers. The Arbitrum DAO owns these, but you can create your own.


:::caution Editor note

 - Low-confidence about the claims in 8/9/10
 - Each of these could use a dedicated concept doc
 - We could hide this list behind a hidden-by-default toggle that says "Click to expand for a list of conceptual primitives that will help you flow through this doc"
 - We could trim this list down to the most important concepts, using quicklooks to offer just-in-case elaborations inline
 - We could illustrate the relationship between these core primitives with a diagram
 - We could attach quicklooks to each, and/or link to supporting docs
  
:::



## 3: An example smart contract

In *[Quickstart: Build a decentralized app with Arbitrum](/for-devs/quickstart-solidity-hardhat.md)*, we deploy a cupcake vending machine to an Arbitrum L2 chain. The vending machine's business logic is encapsulated within a smart contract that increases the `cupcakeBalance` associated with your Ethereum address when you click a button. This smart contract exposes two functions:

 1. `giveCupcakeTo(address userAddress)`: increases the specified address's `cupcakeBalance` by 1
 2. `getCupcakeBalanceFor(address userAddress)`: returns the number of cupcakes associated with the specified address


Don't worry about the guts of the contract - its interface is all we need to understand for now. We'll refer to this contract as the **cupcake contract** throughout the rest of this doc.


## 4: Properties across deployment scenarios

Let's compare a number of properties across **two deployment scenarios**: 

1. The cupcake contract is deployed straight to **Ethereum L1**
2. The cupcake contract is deployed straight to **Arbitrum L2**

<br />

Each of the below questions are asked within the context of our cupcake contract deployment. We'll reference our **conceptual primitives** and **contract functions** in our answers:

<br />

:::caution Editor note

 - If we feel like this table is a value-add, we can fill it in, partialize it, and embed it elsewhere
 - We could implement it as an expandable table that only reveals the first *n* rows by default
 - If there are better questions to ask, we can swap them in, and trim/consolidate the low-value rows

:::

|                                                                            | Straight to L1                                                                                                                                      | Straight to L2                                                                                                                                                |
| -------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Where is the contract deployed?**                                        | Ethereum L1                                                                                                                                         | Arbitrum L2                                                                                                                                                   |
| **Where is the executable code hosted?**                                   | ‚Ä¢ On L1 nodes<br />‚Ä¢ Available for execution by every full Ethereum node                                                                            | ‚Ä¢ On L2 nodes<br />‚Ä¢ Available for execution by every full Arbitrum node                                                                                      |
| **Can the contract code be executed by L1 nodes?**                         | ‚Ä¢ Yes<br />‚Ä¢ Any Ethereum node can execute the contract code                                                                                        | ‚Ä¢ No<br />‚Ä¢ Ethereum nodes cannot directly execute L2 contracts<br />‚Ä¢ But can indirectly interact via Retryable Tickets                                      |
| **Can the contract code be executed by L2 nodes?**                         | ‚Ä¢ No<br />‚Ä¢ L2 nodes cannot execute L1 contracts directly<br />‚Ä¢ But can indirectly interact via Outbox mechanism                                   | ‚Ä¢ Yes<br />‚Ä¢ Any Arbitrum node can execute the contract code                                                                                                  |
| **Can the contract state be read from L1 nodes?**                          | ‚Ä¢ Yes<br />‚Ä¢ L1 nodes maintain the full state of L1 contracts                                                                                       | ‚Ä¢ No<br />‚Ä¢ L1 nodes cannot read L2 state directly<br />‚Ä¢ But state changes can be inferred from finalized Outbox messages                                    |
| **Can the contract state be read from L2 nodes?**                          | ‚Ä¢ No<br />‚Ä¢ L2 nodes cannot read L1 state directly<br />‚Ä¢ But state changes can be inferred from incoming Retryable Tickets                         | ‚Ä¢ Yes<br />‚Ä¢ L2 nodes maintain the full state of L2 contracts                                                                                                 |
| **To what degree is state mirrored between L1 and L2 nodes?**              | ‚Ä¢ No direct state mirroring<br />‚Ä¢ L1 nodes maintain the root hash of L2 state as part of optimistic rollup mechanism                               | ‚Ä¢ No direct state mirroring<br />‚Ä¢ L2 state changes are represented in L1 via root hash updates                                                               |
| **Where is the contract's state stored?**                                  | ‚Ä¢ On L1 nodes<br />‚Ä¢ Each Ethereum node stores the full state                                                                                       | ‚Ä¢ On L2 nodes<br />‚Ä¢ Each Arbitrum node stores the full state                                                                                                 |
| **How does the contract deployment impact L1's physical state?**           | ‚Ä¢ Increases storage size<br />‚Ä¢ Changes account balances as per the contract deployment cost                                                        | ‚Ä¢ Indirectly, by generating a commitment on L1<br />‚Ä¢ The contract's bytecode, deployed on L2, results in a Merkle proof on L1                                |
| **How does the contract deployment impact L2's physical state?**           | ‚Ä¢ Indirectly, if the L1 contract interacts with L2<br />‚Ä¢ Changes in L1 contracts could be relayed to L2 via Retryable Tickets                      | ‚Ä¢ Increases storage size<br />‚Ä¢ Changes account balances as per the contract deployment cost                                                                  |
| **When is gas paid?**                                                      | ‚Ä¢ During contract deployment<br />‚Ä¢ During contract execution                                                                                       | ‚Ä¢ During contract deployment<br />‚Ä¢ During contract execution                                                                                                 |
| **Where is gas paid?**                                                     | ‚Ä¢ On Ethereum L1<br />‚Ä¢ Paid to Ethereum miners                                                                                                     | ‚Ä¢ On Arbitrum L2<br />‚Ä¢ Paid to Arbitrum validators                                                                                                           |
| **Who pays gas?**                                                          | ‚Ä¢ Contract deployer<br />‚Ä¢ Transaction initiator                                                                                                    | ‚Ä¢ Contract deployer<br />‚Ä¢ Transaction initiator                                                                                                              |
| **Can another L1 contract call the deployed contract's methods directly?** | ‚Ä¢ Yes<br />‚Ä¢ Direct interaction between L1 contracts is possible                                                                                    | ‚Ä¢ No<br />‚Ä¢ L1 contracts can't directly call methods of L2 contracts<br />‚Ä¢ But can interact via Gateway contracts and Retryable Tickets                      |
| **Can another L2 contract call the deployed contract's methods directly?** | ‚Ä¢ No<br />‚Ä¢ L2 contracts can't directly call methods of L1 contracts<br />‚Ä¢ But can interact via Gateway contracts and Outbox mechanism             | ‚Ä¢ Yes<br />‚Ä¢ Direct interaction between L2 contracts is possible                                                                                              |
| **When is information sent from L1 to L2?**                                | ‚Ä¢ When a L1 contract sends a message via a Gateway contract<br />‚Ä¢ When a L1 contract creates a Retryable Ticket for L2                             | ‚Ä¢ When the contract is deployed on L2<br />‚Ä¢ When a L1 contract sends a message via a Gateway contract or creates a Retryable Ticket                          |
| **When is information sent from L2 to L1?**                                | ‚Ä¢ When a L2 contract sends a message via Outbox mechanism<br />‚Ä¢ When the contract state on L2 changes (state updates are hashed and stored on L1)  | ‚Ä¢ When the contract is deployed on L2<br />‚Ä¢ When a L2 contract sends a message via Outbox mechanism                                                          |
| **What primitives are involved with L1-L2 messages?**                      | ‚Ä¢ Gateway contracts<br />‚Ä¢ Retryable Tickets                                                                                                        | ‚Ä¢ Gateway contracts<br />‚Ä¢ Retryable Tickets                                                                                                                  |
| **What primitives are involved with L2-L1 messages?**                      | ‚Ä¢ Gateway contracts<br />‚Ä¢ Outbox mechanism<br />‚Ä¢ Merkle proofs of L2 state updates                                                                | ‚Ä¢ Gateway contracts<br />‚Ä¢ Outbox mechanism<br />‚Ä¢ Merkle proofs of L2 state updates                                                                          |
| **When does L1's state change?**                                           | ‚Ä¢ When the contract is deployed<br />‚Ä¢ When contract state is modified<br />‚Ä¢ When the contract sends a message to L2 (creates a Retryable Ticket)  | ‚Ä¢ Indirectly, when a message is sent from L2 via Outbox mechanism<br />‚Ä¢ When a L2 state root hash update is confirmed on L1                                  |
| **When does L2's state change?**                                           | ‚Ä¢ Indirectly, when a message is sent from L1 via a Gateway contract or a Retryable Ticket                                                           | ‚Ä¢ When the contract is deployed<br />‚Ä¢ When contract state is modified<br />‚Ä¢ When a message is received from L1 via a Gateway contract or a Retryable Ticket |
| **Can I query L1 state via L2?**                                           | ‚Ä¢ No direct querying<br />‚Ä¢ But can infer L1 state changes from incoming Retryable Tickets                                                          | ‚Ä¢ No direct querying<br />‚Ä¢ But can infer L1 state changes from incoming Retryable Tickets                                                                    |
| **Can I query L2 state via L1?**                                           | ‚Ä¢ No direct querying<br />‚Ä¢ But can infer L2 state changes from Outbox messages and confirmed L2 state root hash                                    | ‚Ä¢ Yes<br />‚Ä¢ Can query state directly from L2 nodes<br />‚Ä¢ Can also infer L2 state changes from Outbox messages and confirmed L2 state root hash              |
| **When are retryable tickets involved?**                                   | ‚Ä¢ When L1 contracts send messages to L2<br />‚Ä¢ During cross-layer interactions                                                                      | ‚Ä¢ When L1 contracts send messages to L2<br />‚Ä¢ During cross-layer interactions                                                                                |
| **How are retryable tickets involved?**                                    | ‚Ä¢ Retryable Tickets encapsulate L1 messages for L2<br />‚Ä¢ These tickets can be retried if not immediately executed                                  | ‚Ä¢ Retryable Tickets encapsulate L1 messages for L2<br />‚Ä¢ These tickets can be retried if not immediately executed                                            |
| **When are outbox contracts involved?**                                    | ‚Ä¢ When L2 contracts send messages to L1<br />‚Ä¢ During cross-layer interactions                                                                      | ‚Ä¢ When L2 contracts send messages to L1<br />‚Ä¢ During cross-layer interactions                                                                                |
| **How are outbox contracts involved?**                                     | ‚Ä¢ Outbox contracts encapsulate L2 messages for L1<br />‚Ä¢ They help in updating the L2 state root hash on L1                                         | ‚Ä¢ Outbox contracts encapsulate L2 messages for L1<br />‚Ä¢ They help in updating the L2 state root hash on L1                                                   |
| **When are inbox contracts involved?**                                     | ‚Ä¢ When L1 contracts send messages to L2<br />‚Ä¢ During cross-layer interactions                                                                      | ‚Ä¢ When L1 contracts send messages to L2<br />‚Ä¢ During cross-layer interactions                                                                                |
| **How are inbox contracts involved?**                                      | ‚Ä¢ Inbox contracts receive Retryable Tickets from L1<br />‚Ä¢ They help in updating the L2 state                                                       | ‚Ä¢ Inbox contracts receive Retryable Tickets from L1<br />‚Ä¢ They help in updating the L2 state                                                                 |
| **When are bridge contracts involved?**                                    | ‚Ä¢ During cross-layer interactions<br />‚Ä¢ When there is a need for synchronizing state between L1 and L2                                             | ‚Ä¢ During cross-layer interactions<br />‚Ä¢ When there is a need for synchronizing state between L1 and L2                                                       |
| **How are bridge contracts involved?**                                     | ‚Ä¢ Bridge contracts handle message passing and state synchronization between L1 and L2<br />‚Ä¢ They use Retryable Tickets, Outbox and Inbox contracts | ‚Ä¢ Bridge contracts handle message passing and state synchronization between L1 and L2<br />‚Ä¢ They use Retryable Tickets, Outbox and Inbox contracts           |
| **How are gateway contracts involved?**                                    | ‚Ä¢ Gateway contracts enable communication between L1 and L2<br />‚Ä¢ They wrap messages into Retryable Tickets or pass them to Outbox contracts        | ‚Ä¢ Gateway contracts enable communication between L1 and L2<br />‚Ä¢ They wrap messages into Retryable Tickets or pass them to Outbox contracts                  |


<br />

## 5: Tying it all together

Let's now elaborate upon each of our conceptual primitives by defining them more precisely and exploring how they relate to one another in the context of cross-layer communication.

### 5.1: Messages

 - A **message** is a data structure that contains information about a transaction that was initiated on L1, but that needs to be executed on L2. Messages are sent from L1 to L2, and they're used to trigger contract calls on L2.
 - This primitive is important to understand if you're building a dApp that... <!-- todo -->


:::caution Editor note

 - Unsure about whether or not these things apply only to L1-to-L2 messages, or if they apply to L2-to-L1 messages as well
 - We could evaluate consolidating cross-layer messaging into this single concept doc
   - This would allow us to replace the `Cross-chain messaging` node with a single `Cross-chain messaging` document, reducing the number of sidebar clicks required to get to the content

:::


### 5.2: Retryable tickets

 - Retryable tickets (retryables) are the canonical data structure that Arbitrum uses to facilitate L1-to-L2 messages. 
 - Using our cupcake vending machine example, a retryable could be used to solve the following problem: The cupcake contract was deployed to Arbitrum L2, but Alice is an L1 user who isn't comfortable with L2. She wants to give a cupcake to Bob, who is an L2 user. Retryable tickets allow Alice to initiate the transaction on L1, without knowing about L2, and then have the transaction executed on L2.
 - The retryable ticket lifecycle in a nutshell:
   1. **Submission**: The ticket is submitted to Arbitrum's canonical inbox contract on L2
   2. **Execution**: The ticket is executed by a sequencer on L2
      1. **Automatic redemption**: If the ticket is executed successfully, it's automatically redeemed. This is the happy path.
      2. **Manual redemption**: If the ticket fails to execute, it can be redeemed manually.
      3. **Expiration**: If the ticket isn't redeemed within a certain timeframe, it expires.
 - One of the most important properties of retryables is that **they logically separate submission from execution**. In other words, they ensure that these operations are atomic but related: if the L1 transaction that requests the submission of a retryable ticket succeeds, then the execution of the retryable on L2 has a strong guarantee to ultimately succeed as well.
 - This atomicity is important because it means that the L1 transaction that requests the **submission** of a retryable ticket can be submitted for a fixed cost, which is a function of its calldata size, and is usually paid by end-users at L1. The cost of **executing** the retryable's transaction on L2 is paid by the sequencer (todo - learn/clarify), and is a function of the transaction's gas usage (as opposed to calldata size).
 - This separation of concerns is one of the many ingredients that makes Arbitrum's gas efficiency and strong security guarantees possible.

Let's now take a breezy walk through the different stages of a retryable ticket's lifecycle.

#### 5.2.1: Retryable ticket lifecycle: Submission

:::caution Editor note

 - There were some procedural instructions here in the original version; these have been hidden using HTML comments; intent is to move the hidden procedural instructions into a dedicated procedural doc (how-to)

:::

<!-- todo: move this to procedural guidance (how-to), consider what the blockers are to relying on auto-generated API/SDK docs for the bulleted information -->

<!--

Note that, this function forces the sender to provide a _reasonable_ amount of funds (at least enough to submitting, and _attempting_ to executing the ticket), but that doesn't guarantee a successful auto-redemption.

    - `l1CallValue (also referred to as deposit)`: Not a real function parameter, it is rather the callValue that is sent along with the transaction
    - `address to`: The destination L2 address
    - `uint256 l2CallValue`: The callvalue for retryable L2 message that is supplied within the deposit (l1CallValue)
    - `uint256 maxSubmissionCost`: The maximum amount of ETH to be paid for submitting the ticket. This amount is (1) supplied within the deposit (l1CallValue) to be later deducted from sender's L2 balance and is (2) directly proportional to the size of the retryable‚Äôs data and L1 basefee  
    - `address excessFeeRefundAddress`: The L2 address to which the excess fee is credited (l1CallValue - (autoredeem ? ticket execution cost : submission cost) - l2CallValue)
    - `address callValueRefundAddress`: The L2 address to which the l2CallValue is credited if the ticket times out or gets cancelled (this is also called the `beneficiary`, who's got a critical permission to cancel the ticket)
    - `uint256 gasLimit`: Maximum amount of gas used to cover L2 execution of the ticket
    - `uint256 maxFeePerGas`: The gas price bid for L2 execution of the ticket that is supplied within the deposit (l1CallValue)
    - `bytes calldata data`: The calldata to the destination L2 address



1. Sender's deposit must be enough to make the L1 submission succeed and for the L2 execution to be _attempted_. If provided correctly, a new ticket with a unique `TicketID` is created and added to retryable buffer. Also, funds (`submissionCost` + `l2CallValue`) are deducted from the sender and placed into the escrow for later use in redeeming the ticket.
2. Ticket creation causes the [`ArbRetryableTx`](./precompiles#ArbRetryableTx) precompile to emit a `TicketCreated` event containing the `TicketID` on L2.

[inbox_link]: https://github.com/OffchainLabs/nitro-contracts/blob/67127e2c2fd0943d9d87a05915d77b1f220906aa/src/bridge/Inbox.sol

-->


<MermaidWithHtml>
  <Nodes title="Ticket Submission">
    <Node id="1">üßç</Node>
    <Node id="2">Initiating an L1-L2 message</Node>
    <Node id="3">Enough deposit?</Node>
    <Node id="4">Ticket creation fails</Node>
    <Node id="5">Ticket is created</Node>
    <Connection from="1" to="2"/>
    <Connection from="2" to="3"/>
    <Connection from="3" to="4" label="no"/>
    <Connection from="3" to="5" label="yes"/>
  </Nodes>
  <NodeDescriptions>
    <NodeDescription for='1'><code>üßç</code> The user who initiates an L1-L2 message</NodeDescription>
    <NodeDescription for='2'><code>Initiating an L1-L2 message</code> A call to `inbox.createRetryableTicket` function that puts the message in the L2 inbox that can be re-executed for some fixed amount of time if it reverts</NodeDescription>
    <NodeDescription for='3'><code>Check user's deposit</code> Logic that checks if the user have enough funds to create a ticket. This is done by checking if the `msg.value` provided by the user is greater than or equal to <code>maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas</code></NodeDescription>
    <NodeDescription for='4'><code>Ticket creation fails</code> Ticket creation fails and no funds are deducted from the user</NodeDescription>
    <NodeDescription for='5'><code>Ticket is created</code> A  ticket is created and added to the retryable buffer on L2
                          Funds (<code>l2CallValue + submissionCost</code>) are deducted to cover the callvalue from the user and 
                          placed into escrow (on L2) for later use in redeeming the ticket</NodeDescription>
  </NodeDescriptions>
</MermaidWithHtml>


 - Retryable ticket submissions are initiated by calling the `createRetryableTicket` function of the L2 [`inbox` contract](inbox_link). 
 - A retryable is guaranteed to be submitted if this call succeeds.
 - For step-by-step instructions and code snippets that walk you through this process, see [How to submit an L1-to-L2 retryable ticket](#todo).


:::caution Editor note: Editing paused here

See [PR description](https://github.com/OffchainLabs/arbitrum-docs/pull/286) for **full edit notes**.

:::


#### 5.2.2: Retryable ticket lifecycle: Automatic redemption

The submission of a ticket on L1 is separable / asynchronous from its execution on L2, i.e., a successful L1 ticket creation does not guarantee a successful redemption. 
Once the ticket is successfully created, the two following conditions are checked: (1) if the user's L2 balance is greater than (or equal to) `maxFeePerGas * gasLimit` **and** (2) if the `maxFeePerGas` (provided by the user in the ticket submission process) is greater than (or equal to) the `l2Basefee`.
If these conditions are both met, ticket's submission is followed by an attempt to execute it on L2 (i.e., an **auto-redeem** using the supplied gas, as if the [`redeem`](./precompiles#ArbRetryableTx) method of the ArbRetryableTx precompile had been called). 
Depending on how much gas the sender has provided in step 1, ticket's redemption can either (1) immediately succeed or (2) fail. We explain both situations here:

  - If the ticket is sucessfully auto-redeemed, it will execute with the sender, destination, callvalue, and calldata of the original submission. The submission fee is refunded to the user on L2 (`excessFeeRefundAddress`). Note that to ensure successful auto-redeem of the ticket, one could use the Arbitrum SDK which provides a [convenience function](https://github.com/OffchainLabs/arbitrum-sdk/blob/4cedb1fcf1c7302a4c3d0f8e75fb33d82bc8338d/src/lib/message/L1ToL2MessageGasEstimator.ts#L215) that returns the desired gas parameters when sending L1-L2 messages.

  - If a redeem is not done at submission or the submission's initial redeem fails (for example, because the L2 gas price has increased unexpectedly), the submission fee is collected on L2 to cover the resources required to temporarily keep the ticket in memory for a fixed period (one week), and only in this case, a manual redemption of the ticket is required (see next section).


<MermaidWithHtml>
  <Nodes title="Automatic Redemption of the Ticket">
    <Node id="1">Auto-redeem succeeds?</Node>
    <Node id="2">Ticket is executed</Node>
    <Node id="3">Ticket is deleted</Node>
    <Node id="4">callValueRefundAddress gets refunded</Node>
    <Connection from="1" to="2" label="yes"/>
    <Connection from="2" to="3"/>
    <Connection from="1" to="4" label="no"/>
  </Nodes>
  <NodeDescriptions>
    <NodeDescription for='1'><code>Does the auto-redeem succeed?</code> Logic that determines if the user's L2 Balance is greater than (or equal to) <code>maxFeePerGas * gasLimit</code> && <code>maxFeePerGas</code> is greater than (or equal to) the <code>l2Basefee</code></NodeDescription>
    <NodeDescription for='2'><code>Ticket is executed</code> Ticket is executed, the actual <code>submissionFee</code> is refunded to the  <code>excessFeeRefundAddress</code> since the ticket was not kept in the buffer on L2</NodeDescription>
    <NodeDescription for='3'><code>Ticket is deleted</code> Ticket gets deleted from the L2 retryable buffer</NodeDescription>
    <NodeDescription for='4'><code>callValueRefundAddress gets refunded</code> <code>callValueRefundAddress</code> gets refunded with <code>(maxGas - gasUsed) * gasPrice</code>. Note that this amount is capped by <code>l1CallValue</code> in the auto-redeem</NodeDescription>
  </NodeDescriptions>
</MermaidWithHtml>

### Manual Redemption

5. At this point, _anyone_ can attempt to manually redeem the ticket again by calling `ArbRetryableTx`'s redeem precompile method, which donates the call's gas to the next attempt. Note that the amount of gas is NOT limited by the original gasLimit set during the ticket creation.
ArbOS will [enqueue the redeem][enqueue_link], which is its own special `ArbitrumRetryTx` type, to its list of redeems that ArbOS [guarantees to exhaust][exhaust_link] before moving on to the next non-redeem transaction in the block its forming. In this manner redeems are scheduled to happen as soon as possible, and will always be in the same block as the tx that scheduled it. 
Note that the redeem attempt's gas comes from the call to redeem, so there's no chance the block's gas limit is reached before execution.
6. If the fixed period (one week) elapses without a successful redeem, the ticket **expires** and will be [automatically **discarded**][discard_link], unless some party has paid a fee to [**keep the ticket alive**][renew_link] for another full period. A ticket can live indefinitely as long as it is renewed each time before it expires.

[enqueue_link]: https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L245
[exhaust_link]: https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/block_processor.go#L135
[discard_link]: https://github.com/OffchainLabs/nitro/blob/fa36a0f138b8a7e684194f9840315d80c390f324/arbos/retryables/retryable.go#L262
[renew_link]: https://github.com/OffchainLabs/nitro-contracts/blob/a68783436b5105a64f54efe5fbd55174704a7618/src/precompiles/ArbRetryableTx.sol#L41


<MermaidWithHtml>
  <Nodes title="Manual Redemption of the Ticket">
    <Node id="1">Ticket manually cancelled or not redeemed in 7 days?</Node>
    <Node id="2">callValueRefundAddress gets refunded</Node>
    <Node id="3">Ticket is deleted</Node>
    <Node id="4">Ticket manually redeemed?</Node>
    <Connection from="1" to="2" label="yes"/>
    <Connection from="2" to="3"/>
    <Connection from="1" to="4" label="no"/>
    <Connection from="4" to="3" label="yes"/> 
    <Connection from="4" to="1" label="no"/> 
  </Nodes>
  <NodeDescriptions>
    <NodeDescription for='1'><code>Is the ticket manually cancelled or not redeemed within 7 days?</code> Logic that determines if the ticket is manually cancelled or not redeemed within 7 days (i.e., is expired)</NodeDescription>
    <NodeDescription for='2'><code>callValueRefundAddress gets refunded</code> callValueRefundAddress is refunded with the <code>l2CallValue</code></NodeDescription>
    <NodeDescription for='3'><code>Ticket is deleted</code> Ticket gets deleted from the L2 retryable buffer</NodeDescription>
    <NodeDescription for='4'><code>Is the ticket manually redeemed</code> Logic that determines if the ticket is manually redeemed</NodeDescription>
  </NodeDescriptions>
</MermaidWithHtml>


:::caution Avoid Losing Funds!

If a ticket expires after 7 days without being redeemed or re-scheduled to a future date, any message and value (other than the escrowed `callvalue`) it carries could be lost without possibility of being recovered.

:::

On success, the `To` address receives the escrowed callvalue, and any unused gas is returned to ArbOS's gas pools. On failure, the callvalue is returned to the escrow for the future redeem attempt. In either case, the network fee was paid during the scheduling tx, so no fees are charged and no refunds are made.


Note that during redemption of a ticket, attempts to cancel the same ticket, or to schedule another redeem of the same ticket, will revert. In this manner retryable tickets are not self-modifying.


If a ticket with a callvalue is eventually discarded (cancelled or expired), having never successfully run, the escrowed callvalue will be paid out to a `callValueRefundAddress` account that was specified in the initial submission (step 1).

:::note Important Notes:

If a redeem is not done at submission or the submission's initial redeem fails, anyone can attempt to redeem the retryable again by calling [`ArbRetryableTx`](precompiles#ArbRetryableTx)'s [`redeem`](./precompiles#ArbRetryableTx) precompile method, which donates the call's gas to the next attempt. ArbOS will [enqueue the redeem][enqueue_link], which is its own special `ArbitrumRetryTx` type, to its list of redeems that ArbOS [guarantees to exhaust][exhaust_link] before moving on to the next non-redeem transaction in the block its forming. In this manner redeems are scheduled to happen as soon as possible, and will always be in the same block as the transaction that scheduled it. Note that the redeem attempt's gas comes from the call to [`redeem`](./precompiles#ArbRetryableTx), so there's no chance the block's gas limit is reached before execution.

- One can redeem live tickets using the [Arbitrum Retryables Transaction Panel][retryable_dashboard_link]
- The calldata of a ticket is saved on L2 until it is redeemed or expired 
- Redeeming cost of a ticket will not increase over time, it only depends on the current gas price and gas required for execution
:::

[retryable_dashboard_link]: https://retryable-dashboard.arbitrum.io/tx


### Receipts

In the lifecycle of a retryable ticket, two types of L2 transaction receipts will be emitted:

- **Ticket Creation Receipt**: This receipt indicates that a ticket was successfully created; any successful L1 call to the `Inbox`'s `createRetryableTicket` method is guaranteed to create a ticket. The ticket creation receipt includes a `TicketCreated` event (from [`ArbRetryableTx`](./precompiles#ArbRetryableTx)), which includes a `ticketId` field. This `ticketId` is computable via RLP encoding and hashing the transaction; see [calculateSubmitRetryableId](https://github.com/OffchainLabs/arbitrum-sdk/blob/6cc143a3bb019dc4c39c8bcc4aeac9f1a48acb01/src/lib/message/L1ToL2Message.ts#L109).
- **Redeem Attempt**: A redeem attempt receipt represents the result of an attempted L2 execution of a ticket, i.e, success / failure of that specific redeem attempt. It includes a `RedeemScheduled` event from [`ArbRetryableTx`](./precompiles#ArbRetryableTx), with a `ticketId` field. At most, one successful redeem attempt can ever exist for a given ticket; if, e.g., the auto-redeem upon initial creation succeeds, only the receipt from the auto-redeem will ever get emitted for that ticket. If the auto-redeem fails (or was never attempted ‚Äî i.e., the provided L2 gas limit \* L2 gas price = 0), each initial attempt will emit a redeem attempt receipt until one succeeds.


### Alternative "unsafe" Retryable Ticket Creation

The `Inbox.createRetryableTicket` convenience method includes sanity checks to help minimize the risk of user error: the method will ensure that enough funds are provided directly from L1 to cover the current cost of ticket creation. It also will convert the provided `callValueRefundAddress` and `excessFeeRefundAddress` to ther address alias (see below) if either is a contract (determined by if the address has code during the call), providing a path for the L1 contract to recover funds. A power-user may bypass these sanity-check measures via the `Inbox`'s `unsafeCreateRetryableTicket` method; as the method's name desperately attempts to warn you, it should only be accessed by a user who truly knows what they're doing.

## Eth deposits

A special message type exists for simple Eth deposits; i.e., sending Eth from L1 to L2. Eth can be deposited via a call to the `Inbox`'s `depositEth` method. If the L1 caller is EOA, the Eth will be deposited to the same EOA address on L2; the L1 caller is a contract, the funds will deposited to the contract's aliased address (see below).

Note that depositing Eth via `depositEth` into a contract on L2 will _not_ trigger the contract's fallback function.

In principle, retryable tickets can alternatively be used to deposit Ether; this could be preferable to the special eth-deposit message type if, e.g., more flexibility for the destination address is needed, or if one wants to trigger the fallback function on the L2 side.

## Transacting via the Delayed Inbox

While retryables and Eth deposits _must_ be submitted through the delayed inbox, in principle, _any_ message can be included this way; this is a necessary recourse to ensure the Arbitrum chain preserves censorship resistance even if the Sequencer misbehaves (see [The Sequencer and Censorship Resistance](../sequencer.mdx)). However, under ordinary/happy circumstances, the expectation/recommendation is that clients use the delayed inbox only for Retryables and Eth deposits, and transact via the Sequencer for all other messages.

## Address Aliasing

All messages submitted via the Delayed Inbox get their sender's addressed "aliased": when these unsigned messages are executed on L2, the sender's address ‚Äîi.e., that which is returned by `msg.sender` ‚Äî will _not_ simply be the L1 address that sent the message; rather it will be the address's "L2 Alias." An address's L2 alias is its value increased by the hex value `0x1111000000000000000000000000000000001111`:

```sol
L2_Alias = L1_Contract_Address + 0x1111000000000000000000000000000000001111
```

:::tip Try it out

<AddressAliasHelper />
:::
<br />
The Arbitrum protocol's usage of L2 Aliases for L1-to-L2 messages prevents cross-chain
exploits that would otherwise be possible if we simply reused the same L1 addresses
as the L2 sender; i.e., tricking an L2 contract that expects a call from a given
contract address by sending retryable ticket from the expected contract address on
L1.

If for some reason you need to compute the L1 address from an L2 alias on chain, you can use our `AddressAliasHelper` library:

```sol
modifier onlyFromMyL1Contract() override {
    require(AddressAliasHelper.undoL1ToL2Alias(msg.sender) == myL1ContractAddress, "ONLY_COUNTERPART_CONTRACT");
    _;
}
