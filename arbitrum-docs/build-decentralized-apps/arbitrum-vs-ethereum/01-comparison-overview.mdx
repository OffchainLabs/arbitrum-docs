---
title: 'Differences between Arbitrum and Ethereum: Overview'
sidebar_position: 1
description: This concept page provides information about the differences between Arbitrum and Ethereum so developers can easily understand what to expect when deploying to Arbitrum
author: jose-franco
sme: jose-franco
target_audience: developers who want to build on Arbitrum
content_type: concept
---

Arbitrum is designed to be as compatible and consistent with Ethereum as possible, from its high-level RPCs to its low-level bytecode and everything in between. <a data-quicklook-from="dapp">Decentralized app (dApp)</a> developers with experience building on Ethereum will likely find that little-to-no new specific knowledge is required to build on Arbitrum.

This section describes the differences, perks, and gotchas that devs are advised to be aware of when working with Arbitrum. This first page serves as an overview of where you might find these differences, with links to the relevant pages when needed.

## Block numbers and time

Time in Arbitrum chains is tricky. The timing assumptions one is used to making about Ethereum blocks don't exactly carry over into the timing of Arbitrum blocks. See [Block numbers and time](/build-decentralized-apps/arbitrum-vs-ethereum/02-block-numbers-and-time.mdx) for details about how block numbers and time are handled in Arbitrum.

## RPC methods

Although the majority of RPC methods follow the same behavior as Ethereum, some methods might produce a different result, or add more information, when used on an Arbitrum chain. You can find more information about these differences in [RPC methods](/build-decentralized-apps/arbitrum-vs-ethereum/03-rpc-methods.mdx).

## Solidity support

You can deploy Solidity contracts onto Arbitrum just like you do on Ethereum. There are only a few minor differences in behavior. Find more information about it in [Solidity support](/build-decentralized-apps/arbitrum-vs-ethereum/04-solidity-support.mdx).

## Fees

The fees for executing an Arbitrum transaction work like gas fees on Ethereum. However, Arbitrum transactions must also pay a fee component to cover the cost of posting their calldata to the parent chain (for example, calldata on Arbitrum One, a child chain, is posted to Ethereum, a parent chain). Find more information about the two components of gas fees in [Gas and fees](/how-arbitrum-works/09-gas-fees.mdx) and parent chain pricing.

## Cross-chain messaging

Arbitrum chains support arbitrary message passing from a parent chain (for example, a parent chain like Ethereum) to a child chain (for example, a child chain like Arbitrum One or Arbitrum Nova). These are commonly known as "parent chain to child chain messages". Developers using this functionality should familiarize themselves with how they work. Find more information about it in [Parent chain to child chain messaging](/how-arbitrum-works/10-l1-to-l2-messaging.mdx).

Similarly, Arbitrum chains can also send messages to the parent chain. Find more information about them in [Child chain to parent chain messaging and the outbox](/how-arbitrum-works/11-l2-to-l1-messaging.mdx).

## Precompiles

Besides supporting all precompiles available in Ethereum, Arbitrum provides child chain-specific precompiles with methods smart contracts can call the same way they can solidity functions. You can find a full reference of them in [Precompiles](/build-decentralized-apps/precompiles/01-overview.mdx).

## NodeInterface

The Arbitrum Nitro software includes a special `NodeInterface` contract available at address `0xc8` that is only accessible via RPCs (it's not actually deployed onchain, and thus can't be called by smart contracts). Find more information about this interface in [NodeInterface](/build-decentralized-apps/nodeinterface/01-overview.mdx).
